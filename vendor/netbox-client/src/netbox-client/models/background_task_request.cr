# #NetBox REST API
#
# #No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
#
# The version of the OpenAPI document: 4.4.9 (4.4)
#
# Generated by: https://openapi-generator.tech
# Generator version: 7.19.0-SNAPSHOT
#

module NetboxClient
  class BackgroundTaskRequest
    include JSON::Serializable
    include YAML::Serializable

    # Required properties
    @[JSON::Field(key: "id", type: String, nillable: false, emit_null: false)]
    property id : String

    @[JSON::Field(key: "description", type: String, nillable: false, emit_null: false)]
    property description : String

    @[JSON::Field(key: "origin", type: String, nillable: false, emit_null: false)]
    property origin : String

    @[JSON::Field(key: "func_name", type: String, nillable: false, emit_null: false)]
    property func_name : String

    @[JSON::Field(key: "result", type: String, nillable: false, emit_null: false)]
    property result : String

    @[JSON::Field(key: "timeout", type: Int32, nillable: false, emit_null: false)]
    property timeout : Int32

    @[JSON::Field(key: "result_ttl", type: Int32, nillable: false, emit_null: false)]
    property result_ttl : Int32

    @[JSON::Field(key: "created_at", type: Time, nillable: false, emit_null: false)]
    property created_at : Time

    @[JSON::Field(key: "enqueued_at", type: Time, nillable: false, emit_null: false)]
    property enqueued_at : Time

    @[JSON::Field(key: "started_at", type: Time, nillable: false, emit_null: false)]
    property started_at : Time

    @[JSON::Field(key: "ended_at", type: Time, nillable: false, emit_null: false)]
    property ended_at : Time

    @[JSON::Field(key: "worker_name", type: String, nillable: false, emit_null: false)]
    property worker_name : String

    @[JSON::Field(key: "meta", type: Hash(String, JSON::Any), nillable: false, emit_null: false)]
    property meta : Hash(String, JSON::Any)

    @[JSON::Field(key: "last_heartbeat", type: String, nillable: false, emit_null: false)]
    property last_heartbeat : String

    @[JSON::Field(key: "is_finished", type: Bool, nillable: false, emit_null: false)]
    property is_finished : Bool

    @[JSON::Field(key: "is_queued", type: Bool, nillable: false, emit_null: false)]
    property is_queued : Bool

    @[JSON::Field(key: "is_failed", type: Bool, nillable: false, emit_null: false)]
    property is_failed : Bool

    @[JSON::Field(key: "is_started", type: Bool, nillable: false, emit_null: false)]
    property is_started : Bool

    @[JSON::Field(key: "is_deferred", type: Bool, nillable: false, emit_null: false)]
    property is_deferred : Bool

    @[JSON::Field(key: "is_canceled", type: Bool, nillable: false, emit_null: false)]
    property is_canceled : Bool

    @[JSON::Field(key: "is_scheduled", type: Bool, nillable: false, emit_null: false)]
    property is_scheduled : Bool

    @[JSON::Field(key: "is_stopped", type: Bool, nillable: false, emit_null: false)]
    property is_stopped : Bool

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(@id : String, @description : String, @origin : String, @func_name : String, @result : String, @timeout : Int32, @result_ttl : Int32, @created_at : Time, @enqueued_at : Time, @started_at : Time, @ended_at : Time, @worker_name : String, @meta : Hash(String, JSON::Any), @last_heartbeat : String, @is_finished : Bool, @is_queued : Bool, @is_failed : Bool, @is_started : Bool, @is_deferred : Bool, @is_canceled : Bool, @is_scheduled : Bool, @is_stopped : Bool)
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array(String).new
      if @id.try &.to_s.try &.size.try &.< 1
        invalid_properties.push("invalid value for \"id\", the character length must be greater than or equal to 1.")
      end

      if @description.try &.to_s.try &.size.try &.< 1
        invalid_properties.push("invalid value for \"description\", the character length must be greater than or equal to 1.")
      end

      if @origin.try &.to_s.try &.size.try &.< 1
        invalid_properties.push("invalid value for \"origin\", the character length must be greater than or equal to 1.")
      end

      if @func_name.try &.to_s.try &.size.try &.< 1
        invalid_properties.push("invalid value for \"func_name\", the character length must be greater than or equal to 1.")
      end

      if @result.try &.to_s.try &.size.try &.< 1
        invalid_properties.push("invalid value for \"result\", the character length must be greater than or equal to 1.")
      end

      if @worker_name.try &.to_s.try &.size.try &.< 1
        invalid_properties.push("invalid value for \"worker_name\", the character length must be greater than or equal to 1.")
      end

      if @last_heartbeat.try &.to_s.try &.size.try &.< 1
        invalid_properties.push("invalid value for \"last_heartbeat\", the character length must be greater than or equal to 1.")
      end

      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      return false if @id.try &.to_s.try &.size.try &.< 1
      return false if @description.try &.to_s.try &.size.try &.< 1
      return false if @origin.try &.to_s.try &.size.try &.< 1
      return false if @func_name.try &.to_s.try &.size.try &.< 1
      return false if @result.try &.to_s.try &.size.try &.< 1
      return false if @worker_name.try &.to_s.try &.size.try &.< 1
      return false if @last_heartbeat.try &.to_s.try &.size.try &.< 1
      true
    end

    # Custom attribute writer method with validation
    # @param [Object] id Value to be assigned
    def id=(id)
      if id.to_s.size < 1
        raise ArgumentError.new("invalid value for \"id\", the character length must be greater than or equal to 1.")
      end

      @id = id
    end

    # Custom attribute writer method with validation
    # @param [Object] description Value to be assigned
    def description=(description)
      if description.to_s.size < 1
        raise ArgumentError.new("invalid value for \"description\", the character length must be greater than or equal to 1.")
      end

      @description = description
    end

    # Custom attribute writer method with validation
    # @param [Object] origin Value to be assigned
    def origin=(origin)
      if origin.to_s.size < 1
        raise ArgumentError.new("invalid value for \"origin\", the character length must be greater than or equal to 1.")
      end

      @origin = origin
    end

    # Custom attribute writer method with validation
    # @param [Object] func_name Value to be assigned
    def func_name=(func_name)
      if func_name.to_s.size < 1
        raise ArgumentError.new("invalid value for \"func_name\", the character length must be greater than or equal to 1.")
      end

      @func_name = func_name
    end

    # Custom attribute writer method with validation
    # @param [Object] result Value to be assigned
    def result=(result)
      if result.to_s.size < 1
        raise ArgumentError.new("invalid value for \"result\", the character length must be greater than or equal to 1.")
      end

      @result = result
    end

    # Custom attribute writer method with validation
    # @param [Object] worker_name Value to be assigned
    def worker_name=(worker_name)
      if worker_name.to_s.size < 1
        raise ArgumentError.new("invalid value for \"worker_name\", the character length must be greater than or equal to 1.")
      end

      @worker_name = worker_name
    end

    # Custom attribute writer method with validation
    # @param [Object] last_heartbeat Value to be assigned
    def last_heartbeat=(last_heartbeat)
      if last_heartbeat.to_s.size < 1
        raise ArgumentError.new("invalid value for \"last_heartbeat\", the character length must be greater than or equal to 1.")
      end

      @last_heartbeat = last_heartbeat
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(other)
      return true if self.same?(other)
      self.class == other.class &&
        id == other.id &&
        description == other.description &&
        origin == other.origin &&
        func_name == other.func_name &&
        result == other.result &&
        timeout == other.timeout &&
        result_ttl == other.result_ttl &&
        created_at == other.created_at &&
        enqueued_at == other.enqueued_at &&
        started_at == other.started_at &&
        ended_at == other.ended_at &&
        worker_name == other.worker_name &&
        meta == other.meta &&
        last_heartbeat == other.last_heartbeat &&
        is_finished == other.is_finished &&
        is_queued == other.is_queued &&
        is_failed == other.is_failed &&
        is_started == other.is_started &&
        is_deferred == other.is_deferred &&
        is_canceled == other.is_canceled &&
        is_scheduled == other.is_scheduled &&
        is_stopped == other.is_stopped
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(other)
      self == other
    end

    # Calculates hash code according to all attributes.
    # @return [Integer] Hash code
    def hash
      [id, description, origin, func_name, result, timeout, result_ttl, created_at, enqueued_at, started_at, ended_at, worker_name, meta, last_heartbeat, is_finished, is_queued, is_failed, is_started, is_deferred, is_canceled, is_scheduled, is_stopped].hash
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_h.to_s
    end

    # to_body is an alias to to_h (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_h
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_h
      hash = NetboxClient::RecursiveHash.new
      hash["id"] = _to_h(id)
      hash["description"] = _to_h(description)
      hash["origin"] = _to_h(origin)
      hash["func_name"] = _to_h(func_name)
      hash["result"] = _to_h(result)
      hash["timeout"] = _to_h(timeout)
      hash["result_ttl"] = _to_h(result_ttl)
      hash["created_at"] = _to_h(created_at)
      hash["enqueued_at"] = _to_h(enqueued_at)
      hash["started_at"] = _to_h(started_at)
      hash["ended_at"] = _to_h(ended_at)
      hash["worker_name"] = _to_h(worker_name)
      hash["meta"] = _to_h(meta)
      hash["last_heartbeat"] = _to_h(last_heartbeat)
      hash["is_finished"] = _to_h(is_finished)
      hash["is_queued"] = _to_h(is_queued)
      hash["is_failed"] = _to_h(is_failed)
      hash["is_started"] = _to_h(is_started)
      hash["is_deferred"] = _to_h(is_deferred)
      hash["is_canceled"] = _to_h(is_canceled)
      hash["is_scheduled"] = _to_h(is_scheduled)
      hash["is_stopped"] = _to_h(is_stopped)
      hash.to_h
    end

    # Outputs non-array value in the form of hash
    # For object, use to_h. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    private def _to_h(value)
      return nil if value.nil?

      if value.is_a?(Hash)
        hash = NetboxClient::RecursiveHash.new
        value.each { |k, v| hash[k] = _to_h(v) }
        hash
      elsif value.is_a?(Array)
        value.compact.map { |v| _to_h(v) }
      elsif value.responds_to?(:to_h)
        value.to_h
      else
        value
      end
    end
  end
end
