# #NetBox REST API
#
# #No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
#
# The version of the OpenAPI document: 4.4.9 (4.4)
#
# Generated by: https://openapi-generator.tech
# Generator version: 7.19.0-SNAPSHOT
#

module NetboxClient
  class DcimCablesCreateRequest
    include JSON::Serializable
    include YAML::Serializable

    class SchemaMismatchError < Exception
    end

    # List of class defined in oneOf (OpenAPI v3)
    def self.openapi_one_of
      [
        Array(WritableCableRequest),
        WritableCableRequest,
      ]
    end

    def self.build(data)
      openapi_one_of.each do |klass|
        begin
          typed_data = find_and_cast_into_type(klass, data)
          return typed_data if typed_data
        rescue ex
          # rescue all errors so we keep iterating even if the current item lookup raises
          Log.trace { ex.message }
        end
      end

      nil
    end

    private def self.find_and_cast_into_type(klass : Array(WritableCableRequest).class, data)
      return if data.nil?

      Log.trace { "INSPECTING DATA" }
      Log.trace { data.inspect }

      case data
      when NetboxClient::RecursiveHash
        if value = cast_value(array_data: false, array_class: array_class?(klass), klass: klass, data: data)
          return new(value)
        end
      when Array(NetboxClient::RecursiveHash)
        if value = cast_value(array_data: true, array_class: array_class?(klass), klass: klass, data: data)
          return new(value)
        end
      else
        raise SchemaMismatchError.new("#{data} doesn't match the #{klass} type")
      end
    end

    private def self.find_and_cast_into_type(klass : WritableCableRequest.class, data)
      return if data.nil?

      Log.trace { "INSPECTING DATA" }
      Log.trace { data.inspect }

      case data
      when NetboxClient::RecursiveHash
        if value = cast_value(array_data: false, array_class: array_class?(klass), klass: klass, data: data)
          return new(value)
        end
      when Array(NetboxClient::RecursiveHash)
        if value = cast_value(array_data: true, array_class: array_class?(klass), klass: klass, data: data)
          return new(value)
        end
      else
        raise SchemaMismatchError.new("#{data} doesn't match the #{klass} type")
      end
    end

    private def self.cast_value(array_data : Bool, array_class : Bool, klass, data)
      if array_class == true && array_data == true
        Log.debug { "Building array of classes: #{klass} / #{data}" }

        klass.from_json(data.to_json)
      elsif array_class == false && array_data == false
        Log.debug { "Building single class: #{klass} / #{data}" }

        klass.from_json(data.to_json)
      end
    end

    private def self.array_class?(klass)
      klass.name.starts_with?("Array(")
    end

    def initialize(@value : Array(WritableCableRequest))
    end

    def initialize(@value : WritableCableRequest)
    end

    delegate :to_yaml, to: @value
    delegate :to_json, to: @value

    def to_any_h
      {"value" => to_h}
    end

    def to_h
      val = @value
      if val.is_a?(Int32)
        val
      else
        val.to_h
      end
    end
  end
end
