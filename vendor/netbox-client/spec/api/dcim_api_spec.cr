# #NetBox REST API
#
# #No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
#
# The version of the OpenAPI document: 4.4.9 (4.4)
#
# Generated by: https://openapi-generator.tech
# Generator version: 7.19.0-SNAPSHOT
#

require "../spec_helper"

# Unit tests for NetboxClient::DcimApi
# Automatically generated by openapi-generator (https://openapi-generator.tech)
# Please update as you see appropriate
Spectator.describe "DcimApi" do
  describe "test an instance of DcimApi" do
    it "should create an instance of DcimApi" do
      api_instance = NetboxClient::DcimApi.new
      expect(api_instance).to be_instance_of(NetboxClient::DcimApi)
    end
  end

  # unit tests for dcim_cable_terminations_bulk_destroy
  # Delete a list of cable termination objects.
  # @param cable_termination_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_cable_terminations_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_cable_terminations_bulk_partial_update
  # Patch a list of cable termination objects.
  # @param cable_termination_request
  # @param [Hash] opts the optional parameters
  # @return [Array(CableTermination)]
  describe "dcim_cable_terminations_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_cable_terminations_bulk_update
  # Put a list of cable termination objects.
  # @param cable_termination_request
  # @param [Hash] opts the optional parameters
  # @return [Array(CableTermination)]
  describe "dcim_cable_terminations_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_cable_terminations_create
  # Post a list of cable termination objects.
  # @param dcim_cable_terminations_create_request
  # @param [Hash] opts the optional parameters
  # @return [CableTermination]
  describe "dcim_cable_terminations_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_cable_terminations_destroy
  # Delete a cable termination object.
  # @param id A unique integer value identifying this cable termination.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_cable_terminations_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_cable_terminations_list
  # Get a list of cable termination objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Int32] :cable
  # @option opts [Int32] :cable__n
  # @option opts [String] :cable_end * &#x60;A&#x60; - A * &#x60;B&#x60; - B
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [String] :modified_by_request
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Array(Int32)] :termination_id
  # @option opts [Bool] :termination_id__empty
  # @option opts [Array(Int32)] :termination_id__gt
  # @option opts [Array(Int32)] :termination_id__gte
  # @option opts [Array(Int32)] :termination_id__lt
  # @option opts [Array(Int32)] :termination_id__lte
  # @option opts [Array(Int32)] :termination_id__n
  # @option opts [String] :termination_type
  # @option opts [String] :termination_type__n
  # @option opts [String] :updated_by_request
  # @return [PaginatedCableTerminationList]
  describe "dcim_cable_terminations_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_cable_terminations_partial_update
  # Patch a cable termination object.
  # @param id A unique integer value identifying this cable termination.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedCableTerminationRequest] :patched_cable_termination_request
  # @return [CableTermination]
  describe "dcim_cable_terminations_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_cable_terminations_retrieve
  # Get a cable termination object.
  # @param id A unique integer value identifying this cable termination.
  # @param [Hash] opts the optional parameters
  # @return [CableTermination]
  describe "dcim_cable_terminations_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_cable_terminations_update
  # Put a cable termination object.
  # @param id A unique integer value identifying this cable termination.
  # @param cable_termination_request
  # @param [Hash] opts the optional parameters
  # @return [CableTermination]
  describe "dcim_cable_terminations_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_cables_bulk_destroy
  # Delete a list of cable objects.
  # @param cable_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_cables_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_cables_bulk_partial_update
  # Patch a list of cable objects.
  # @param cable_request
  # @param [Hash] opts the optional parameters
  # @return [Array(Cable)]
  describe "dcim_cables_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_cables_bulk_update
  # Put a list of cable objects.
  # @param cable_request
  # @param [Hash] opts the optional parameters
  # @return [Array(Cable)]
  describe "dcim_cables_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_cables_create
  # Post a list of cable objects.
  # @param [Hash] opts the optional parameters
  # @option opts [DcimCablesCreateRequest] :dcim_cables_create_request
  # @return [Cable]
  describe "dcim_cables_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_cables_destroy
  # Delete a cable object.
  # @param id A unique integer value identifying this cable.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_cables_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_cables_list
  # Get a list of cable objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Int32)] :circuittermination_id
  # @option opts [Array(String)] :color
  # @option opts [Bool] :color__empty
  # @option opts [Array(String)] :color__ic
  # @option opts [Array(String)] :color__ie
  # @option opts [Array(String)] :color__iew
  # @option opts [Array(String)] :color__iregex
  # @option opts [Array(String)] :color__isw
  # @option opts [Array(String)] :color__n
  # @option opts [Array(String)] :color__nic
  # @option opts [Array(String)] :color__nie
  # @option opts [Array(String)] :color__niew
  # @option opts [Array(String)] :color__nisw
  # @option opts [Array(String)] :color__regex
  # @option opts [Array(Int32)] :consoleport_id
  # @option opts [Array(Int32)] :consoleserverport_id
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(String)] :device
  # @option opts [Array(Int32)] :device_id
  # @option opts [Array(Int32)] :frontport_id
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(Int32)] :interface_id
  # @option opts [Array(String)] :label
  # @option opts [Bool] :label__empty
  # @option opts [Array(String)] :label__ic
  # @option opts [Array(String)] :label__ie
  # @option opts [Array(String)] :label__iew
  # @option opts [Array(String)] :label__iregex
  # @option opts [Array(String)] :label__isw
  # @option opts [Array(String)] :label__n
  # @option opts [Array(String)] :label__nic
  # @option opts [Array(String)] :label__nie
  # @option opts [Array(String)] :label__niew
  # @option opts [Array(String)] :label__nisw
  # @option opts [Array(String)] :label__regex
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Array(Float64)] :length
  # @option opts [Bool] :length__empty
  # @option opts [Array(Float64)] :length__gt
  # @option opts [Array(Float64)] :length__gte
  # @option opts [Array(Float64)] :length__lt
  # @option opts [Array(Float64)] :length__lte
  # @option opts [Array(Float64)] :length__n
  # @option opts [String] :length_unit * &#x60;km&#x60; - Kilometers * &#x60;m&#x60; - Meters * &#x60;cm&#x60; - Centimeters * &#x60;mi&#x60; - Miles * &#x60;ft&#x60; - Feet * &#x60;in&#x60; - Inches
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(String)] :location
  # @option opts [Array(Int32)] :location_id
  # @option opts [String] :modified_by_request
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Array(Int32)] :powerfeed_id
  # @option opts [Array(Int32)] :poweroutlet_id
  # @option opts [Array(Int32)] :powerport_id
  # @option opts [String] :q Search
  # @option opts [Array(String)] :rack
  # @option opts [Array(Int32)] :rack_id
  # @option opts [Array(Int32)] :rearport_id
  # @option opts [Array(String)] :site
  # @option opts [Array(Int32)] :site_id
  # @option opts [Array(String)] :status
  # @option opts [Bool] :status__empty
  # @option opts [Array(String)] :status__ic
  # @option opts [Array(String)] :status__ie
  # @option opts [Array(String)] :status__iew
  # @option opts [Array(String)] :status__iregex
  # @option opts [Array(String)] :status__isw
  # @option opts [Array(String)] :status__n
  # @option opts [Array(String)] :status__nic
  # @option opts [Array(String)] :status__nie
  # @option opts [Array(String)] :status__niew
  # @option opts [Array(String)] :status__nisw
  # @option opts [Array(String)] :status__regex
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [Array(String)] :tenant Tenant (slug)
  # @option opts [Array(String)] :tenant__n Tenant (slug)
  # @option opts [Array(String)] :tenant_group
  # @option opts [Array(String)] :tenant_group__n
  # @option opts [Array(String)] :tenant_group_id
  # @option opts [Array(String)] :tenant_group_id__n
  # @option opts [Array(Int32)] :tenant_id Tenant (ID)
  # @option opts [Array(Int32)] :tenant_id__n Tenant (ID)
  # @option opts [Array(Int32)] :termination_a_id
  # @option opts [String] :termination_a_type
  # @option opts [String] :termination_a_type__n
  # @option opts [Array(Int32)] :termination_b_id
  # @option opts [String] :termination_b_type
  # @option opts [String] :termination_b_type__n
  # @option opts [Array(String)] :_type
  # @option opts [Bool] :type__empty
  # @option opts [Array(String)] :type__ic
  # @option opts [Array(String)] :type__ie
  # @option opts [Array(String)] :type__iew
  # @option opts [Array(String)] :type__iregex
  # @option opts [Array(String)] :type__isw
  # @option opts [Array(String)] :type__n
  # @option opts [Array(String)] :type__nic
  # @option opts [Array(String)] :type__nie
  # @option opts [Array(String)] :type__niew
  # @option opts [Array(String)] :type__nisw
  # @option opts [Array(String)] :type__regex
  # @option opts [Bool] :unterminated Unterminated
  # @option opts [String] :updated_by_request
  # @return [PaginatedCableList]
  describe "dcim_cables_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_cables_partial_update
  # Patch a cable object.
  # @param id A unique integer value identifying this cable.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableCableRequest] :patched_writable_cable_request
  # @return [Cable]
  describe "dcim_cables_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_cables_retrieve
  # Get a cable object.
  # @param id A unique integer value identifying this cable.
  # @param [Hash] opts the optional parameters
  # @return [Cable]
  describe "dcim_cables_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_cables_update
  # Put a cable object.
  # @param id A unique integer value identifying this cable.
  # @param [Hash] opts the optional parameters
  # @option opts [WritableCableRequest] :writable_cable_request
  # @return [Cable]
  describe "dcim_cables_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_connected_device_list
  # This endpoint allows a user to determine what device (if any) is connected to a given peer device and peer interface. This is useful in a situation where a device boots with no configuration, but can detect its neighbors via a protocol such as LLDP. Two query parameters must be included in the request:  * &#x60;peer_device&#x60;: The name of the peer device * &#x60;peer_interface&#x60;: The name of the peer interface
  # @param peer_device The name of the peer device
  # @param peer_interface The name of the peer interface
  # @param [Hash] opts the optional parameters
  # @return [Array(Device)]
  describe "dcim_connected_device_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_port_templates_bulk_destroy
  # Delete a list of console port template objects.
  # @param console_port_template_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_console_port_templates_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_port_templates_bulk_partial_update
  # Patch a list of console port template objects.
  # @param console_port_template_request
  # @param [Hash] opts the optional parameters
  # @return [Array(ConsolePortTemplate)]
  describe "dcim_console_port_templates_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_port_templates_bulk_update
  # Put a list of console port template objects.
  # @param console_port_template_request
  # @param [Hash] opts the optional parameters
  # @return [Array(ConsolePortTemplate)]
  describe "dcim_console_port_templates_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_port_templates_create
  # Post a list of console port template objects.
  # @param dcim_console_port_templates_create_request
  # @param [Hash] opts the optional parameters
  # @return [ConsolePortTemplate]
  describe "dcim_console_port_templates_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_port_templates_destroy
  # Delete a console port template object.
  # @param id A unique integer value identifying this console port template.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_console_port_templates_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_port_templates_list
  # Get a list of console port template objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :device_type_id Device type (ID)
  # @option opts [Array(Int32)] :device_type_id__n Device type (ID)
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :label
  # @option opts [Bool] :label__empty
  # @option opts [Array(String)] :label__ic
  # @option opts [Array(String)] :label__ie
  # @option opts [Array(String)] :label__iew
  # @option opts [Array(String)] :label__iregex
  # @option opts [Array(String)] :label__isw
  # @option opts [Array(String)] :label__n
  # @option opts [Array(String)] :label__nic
  # @option opts [Array(String)] :label__nie
  # @option opts [Array(String)] :label__niew
  # @option opts [Array(String)] :label__nisw
  # @option opts [Array(String)] :label__regex
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [String] :modified_by_request
  # @option opts [Array(Int32)] :module_type_id Module type (ID)
  # @option opts [Array(Int32)] :module_type_id__n Module type (ID)
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [String] :_type * &#x60;Serial&#x60; - [(&#39;de-9&#39;, &#39;DE-9&#39;), (&#39;db-25&#39;, &#39;DB-25&#39;), (&#39;rj-11&#39;, &#39;RJ-11&#39;), (&#39;rj-12&#39;, &#39;RJ-12&#39;), (&#39;rj-45&#39;, &#39;RJ-45&#39;), (&#39;mini-din-8&#39;, &#39;Mini-DIN 8&#39;)] * &#x60;USB&#x60; - [(&#39;usb-a&#39;, &#39;USB Type A&#39;), (&#39;usb-b&#39;, &#39;USB Type B&#39;), (&#39;usb-c&#39;, &#39;USB Type C&#39;), (&#39;usb-mini-a&#39;, &#39;USB Mini A&#39;), (&#39;usb-mini-b&#39;, &#39;USB Mini B&#39;), (&#39;usb-micro-a&#39;, &#39;USB Micro A&#39;), (&#39;usb-micro-b&#39;, &#39;USB Micro B&#39;), (&#39;usb-micro-ab&#39;, &#39;USB Micro AB&#39;)] * &#x60;Other&#x60; - [(&#39;other&#39;, &#39;Other&#39;)]
  # @option opts [String] :updated_by_request
  # @return [PaginatedConsolePortTemplateList]
  describe "dcim_console_port_templates_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_port_templates_partial_update
  # Patch a console port template object.
  # @param id A unique integer value identifying this console port template.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableConsolePortTemplateRequest] :patched_writable_console_port_template_request
  # @return [ConsolePortTemplate]
  describe "dcim_console_port_templates_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_port_templates_retrieve
  # Get a console port template object.
  # @param id A unique integer value identifying this console port template.
  # @param [Hash] opts the optional parameters
  # @return [ConsolePortTemplate]
  describe "dcim_console_port_templates_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_port_templates_update
  # Put a console port template object.
  # @param id A unique integer value identifying this console port template.
  # @param writable_console_port_template_request
  # @param [Hash] opts the optional parameters
  # @return [ConsolePortTemplate]
  describe "dcim_console_port_templates_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_ports_bulk_destroy
  # Delete a list of console port objects.
  # @param console_port_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_console_ports_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_ports_bulk_partial_update
  # Patch a list of console port objects.
  # @param console_port_request
  # @param [Hash] opts the optional parameters
  # @return [Array(ConsolePort)]
  describe "dcim_console_ports_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_ports_bulk_update
  # Put a list of console port objects.
  # @param console_port_request
  # @param [Hash] opts the optional parameters
  # @return [Array(ConsolePort)]
  describe "dcim_console_ports_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_ports_create
  # Post a list of console port objects.
  # @param dcim_console_ports_create_request
  # @param [Hash] opts the optional parameters
  # @return [ConsolePort]
  describe "dcim_console_ports_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_ports_destroy
  # Delete a console port object.
  # @param id A unique integer value identifying this console port.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_console_ports_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_ports_list
  # Get a list of console port objects.
  # @param [Hash] opts the optional parameters
  # @option opts [String] :cable_end * &#x60;A&#x60; - A * &#x60;B&#x60; - B
  # @option opts [Array(Int32)] :cable_id Cable (ID)
  # @option opts [Array(Int32)] :cable_id__n Cable (ID)
  # @option opts [Bool] :cabled
  # @option opts [Bool] :connected
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(String)] :device Device (name)
  # @option opts [Array(String)] :device__n Device (name)
  # @option opts [Array(Int32)] :device_id Device (ID)
  # @option opts [Array(Int32)] :device_id__n Device (ID)
  # @option opts [Array(String)] :device_role Device role (slug)
  # @option opts [Array(String)] :device_role__n Device role (slug)
  # @option opts [Array(Int32)] :device_role_id Device role (ID)
  # @option opts [Array(Int32)] :device_role_id__n Device role (ID)
  # @option opts [Array(String)] :device_status
  # @option opts [Bool] :device_status__empty
  # @option opts [Array(String)] :device_status__ic
  # @option opts [Array(String)] :device_status__ie
  # @option opts [Array(String)] :device_status__iew
  # @option opts [Array(String)] :device_status__iregex
  # @option opts [Array(String)] :device_status__isw
  # @option opts [Array(String)] :device_status__n
  # @option opts [Array(String)] :device_status__nic
  # @option opts [Array(String)] :device_status__nie
  # @option opts [Array(String)] :device_status__niew
  # @option opts [Array(String)] :device_status__nisw
  # @option opts [Array(String)] :device_status__regex
  # @option opts [Array(String)] :device_type Device type (model)
  # @option opts [Array(String)] :device_type__n Device type (model)
  # @option opts [Array(Int32)] :device_type_id Device type (ID)
  # @option opts [Array(Int32)] :device_type_id__n Device type (ID)
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :label
  # @option opts [Bool] :label__empty
  # @option opts [Array(String)] :label__ic
  # @option opts [Array(String)] :label__ie
  # @option opts [Array(String)] :label__iew
  # @option opts [Array(String)] :label__iregex
  # @option opts [Array(String)] :label__isw
  # @option opts [Array(String)] :label__n
  # @option opts [Array(String)] :label__nic
  # @option opts [Array(String)] :label__nie
  # @option opts [Array(String)] :label__niew
  # @option opts [Array(String)] :label__nisw
  # @option opts [Array(String)] :label__regex
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(String)] :location Location (slug)
  # @option opts [Array(String)] :location__n Location (slug)
  # @option opts [Array(Int32)] :location_id Location (ID)
  # @option opts [Array(Int32)] :location_id__n Location (ID)
  # @option opts [Bool] :mark_connected
  # @option opts [String] :modified_by_request
  # @option opts [Array(Int32)] :module_id Module (ID)
  # @option opts [Array(Int32)] :module_id__n Module (ID)
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Bool] :occupied
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [Array(String)] :rack Rack (name)
  # @option opts [Array(String)] :rack__n Rack (name)
  # @option opts [Array(Int32)] :rack_id Rack (ID)
  # @option opts [Array(Int32)] :rack_id__n Rack (ID)
  # @option opts [Array(String)] :region
  # @option opts [Array(String)] :region__n
  # @option opts [Array(String)] :region_id
  # @option opts [Array(String)] :region_id__n
  # @option opts [Array(String)] :site Site name (slug)
  # @option opts [Array(String)] :site__n Site name (slug)
  # @option opts [Array(String)] :site_group
  # @option opts [Array(String)] :site_group__n
  # @option opts [Array(String)] :site_group_id
  # @option opts [Array(String)] :site_group_id__n
  # @option opts [Array(Int32)] :site_id Site (ID)
  # @option opts [Array(Int32)] :site_id__n Site (ID)
  # @option opts [Int32] :speed Port speed in bits per second  * &#x60;1200&#x60; - 1200 bps * &#x60;2400&#x60; - 2400 bps * &#x60;4800&#x60; - 4800 bps * &#x60;9600&#x60; - 9600 bps * &#x60;19200&#x60; - 19.2 kbps * &#x60;38400&#x60; - 38.4 kbps * &#x60;57600&#x60; - 57.6 kbps * &#x60;115200&#x60; - 115.2 kbps
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [Array(String)] :tenant Tenant (slug)
  # @option opts [Array(String)] :tenant__n Tenant (slug)
  # @option opts [Array(Int32)] :tenant_id Tenant (ID)
  # @option opts [Array(Int32)] :tenant_id__n Tenant (ID)
  # @option opts [Array(String)] :_type Physical port type
  # @option opts [Bool] :type__empty
  # @option opts [Array(String)] :type__ic Physical port type
  # @option opts [Array(String)] :type__ie Physical port type
  # @option opts [Array(String)] :type__iew Physical port type
  # @option opts [Array(String)] :type__iregex Physical port type
  # @option opts [Array(String)] :type__isw Physical port type
  # @option opts [Array(String)] :type__n Physical port type
  # @option opts [Array(String)] :type__nic Physical port type
  # @option opts [Array(String)] :type__nie Physical port type
  # @option opts [Array(String)] :type__niew Physical port type
  # @option opts [Array(String)] :type__nisw Physical port type
  # @option opts [Array(String)] :type__regex Physical port type
  # @option opts [String] :updated_by_request
  # @option opts [Array(String)] :virtual_chassis Virtual Chassis
  # @option opts [Array(String)] :virtual_chassis__n Virtual Chassis
  # @option opts [Array(Int32)] :virtual_chassis_id Virtual Chassis (ID)
  # @option opts [Array(Int32)] :virtual_chassis_id__n Virtual Chassis (ID)
  # @return [PaginatedConsolePortList]
  describe "dcim_console_ports_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_ports_partial_update
  # Patch a console port object.
  # @param id A unique integer value identifying this console port.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableConsolePortRequest] :patched_writable_console_port_request
  # @return [ConsolePort]
  describe "dcim_console_ports_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_ports_retrieve
  # Get a console port object.
  # @param id A unique integer value identifying this console port.
  # @param [Hash] opts the optional parameters
  # @return [ConsolePort]
  describe "dcim_console_ports_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_ports_trace_retrieve
  # Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
  # @param id A unique integer value identifying this console port.
  # @param [Hash] opts the optional parameters
  # @return [ConsolePort]
  describe "dcim_console_ports_trace_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_ports_update
  # Put a console port object.
  # @param id A unique integer value identifying this console port.
  # @param writable_console_port_request
  # @param [Hash] opts the optional parameters
  # @return [ConsolePort]
  describe "dcim_console_ports_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_server_port_templates_bulk_destroy
  # Delete a list of console server port template objects.
  # @param console_server_port_template_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_console_server_port_templates_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_server_port_templates_bulk_partial_update
  # Patch a list of console server port template objects.
  # @param console_server_port_template_request
  # @param [Hash] opts the optional parameters
  # @return [Array(ConsoleServerPortTemplate)]
  describe "dcim_console_server_port_templates_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_server_port_templates_bulk_update
  # Put a list of console server port template objects.
  # @param console_server_port_template_request
  # @param [Hash] opts the optional parameters
  # @return [Array(ConsoleServerPortTemplate)]
  describe "dcim_console_server_port_templates_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_server_port_templates_create
  # Post a list of console server port template objects.
  # @param dcim_console_server_port_templates_create_request
  # @param [Hash] opts the optional parameters
  # @return [ConsoleServerPortTemplate]
  describe "dcim_console_server_port_templates_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_server_port_templates_destroy
  # Delete a console server port template object.
  # @param id A unique integer value identifying this console server port template.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_console_server_port_templates_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_server_port_templates_list
  # Get a list of console server port template objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :device_type_id Device type (ID)
  # @option opts [Array(Int32)] :device_type_id__n Device type (ID)
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :label
  # @option opts [Bool] :label__empty
  # @option opts [Array(String)] :label__ic
  # @option opts [Array(String)] :label__ie
  # @option opts [Array(String)] :label__iew
  # @option opts [Array(String)] :label__iregex
  # @option opts [Array(String)] :label__isw
  # @option opts [Array(String)] :label__n
  # @option opts [Array(String)] :label__nic
  # @option opts [Array(String)] :label__nie
  # @option opts [Array(String)] :label__niew
  # @option opts [Array(String)] :label__nisw
  # @option opts [Array(String)] :label__regex
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [String] :modified_by_request
  # @option opts [Array(Int32)] :module_type_id Module type (ID)
  # @option opts [Array(Int32)] :module_type_id__n Module type (ID)
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [String] :_type * &#x60;Serial&#x60; - [(&#39;de-9&#39;, &#39;DE-9&#39;), (&#39;db-25&#39;, &#39;DB-25&#39;), (&#39;rj-11&#39;, &#39;RJ-11&#39;), (&#39;rj-12&#39;, &#39;RJ-12&#39;), (&#39;rj-45&#39;, &#39;RJ-45&#39;), (&#39;mini-din-8&#39;, &#39;Mini-DIN 8&#39;)] * &#x60;USB&#x60; - [(&#39;usb-a&#39;, &#39;USB Type A&#39;), (&#39;usb-b&#39;, &#39;USB Type B&#39;), (&#39;usb-c&#39;, &#39;USB Type C&#39;), (&#39;usb-mini-a&#39;, &#39;USB Mini A&#39;), (&#39;usb-mini-b&#39;, &#39;USB Mini B&#39;), (&#39;usb-micro-a&#39;, &#39;USB Micro A&#39;), (&#39;usb-micro-b&#39;, &#39;USB Micro B&#39;), (&#39;usb-micro-ab&#39;, &#39;USB Micro AB&#39;)] * &#x60;Other&#x60; - [(&#39;other&#39;, &#39;Other&#39;)]
  # @option opts [String] :updated_by_request
  # @return [PaginatedConsoleServerPortTemplateList]
  describe "dcim_console_server_port_templates_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_server_port_templates_partial_update
  # Patch a console server port template object.
  # @param id A unique integer value identifying this console server port template.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableConsoleServerPortTemplateRequest] :patched_writable_console_server_port_template_request
  # @return [ConsoleServerPortTemplate]
  describe "dcim_console_server_port_templates_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_server_port_templates_retrieve
  # Get a console server port template object.
  # @param id A unique integer value identifying this console server port template.
  # @param [Hash] opts the optional parameters
  # @return [ConsoleServerPortTemplate]
  describe "dcim_console_server_port_templates_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_server_port_templates_update
  # Put a console server port template object.
  # @param id A unique integer value identifying this console server port template.
  # @param writable_console_server_port_template_request
  # @param [Hash] opts the optional parameters
  # @return [ConsoleServerPortTemplate]
  describe "dcim_console_server_port_templates_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_server_ports_bulk_destroy
  # Delete a list of console server port objects.
  # @param console_server_port_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_console_server_ports_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_server_ports_bulk_partial_update
  # Patch a list of console server port objects.
  # @param console_server_port_request
  # @param [Hash] opts the optional parameters
  # @return [Array(ConsoleServerPort)]
  describe "dcim_console_server_ports_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_server_ports_bulk_update
  # Put a list of console server port objects.
  # @param console_server_port_request
  # @param [Hash] opts the optional parameters
  # @return [Array(ConsoleServerPort)]
  describe "dcim_console_server_ports_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_server_ports_create
  # Post a list of console server port objects.
  # @param dcim_console_server_ports_create_request
  # @param [Hash] opts the optional parameters
  # @return [ConsoleServerPort]
  describe "dcim_console_server_ports_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_server_ports_destroy
  # Delete a console server port object.
  # @param id A unique integer value identifying this console server port.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_console_server_ports_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_server_ports_list
  # Get a list of console server port objects.
  # @param [Hash] opts the optional parameters
  # @option opts [String] :cable_end * &#x60;A&#x60; - A * &#x60;B&#x60; - B
  # @option opts [Array(Int32)] :cable_id Cable (ID)
  # @option opts [Array(Int32)] :cable_id__n Cable (ID)
  # @option opts [Bool] :cabled
  # @option opts [Bool] :connected
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(String)] :device Device (name)
  # @option opts [Array(String)] :device__n Device (name)
  # @option opts [Array(Int32)] :device_id Device (ID)
  # @option opts [Array(Int32)] :device_id__n Device (ID)
  # @option opts [Array(String)] :device_role Device role (slug)
  # @option opts [Array(String)] :device_role__n Device role (slug)
  # @option opts [Array(Int32)] :device_role_id Device role (ID)
  # @option opts [Array(Int32)] :device_role_id__n Device role (ID)
  # @option opts [Array(String)] :device_status
  # @option opts [Bool] :device_status__empty
  # @option opts [Array(String)] :device_status__ic
  # @option opts [Array(String)] :device_status__ie
  # @option opts [Array(String)] :device_status__iew
  # @option opts [Array(String)] :device_status__iregex
  # @option opts [Array(String)] :device_status__isw
  # @option opts [Array(String)] :device_status__n
  # @option opts [Array(String)] :device_status__nic
  # @option opts [Array(String)] :device_status__nie
  # @option opts [Array(String)] :device_status__niew
  # @option opts [Array(String)] :device_status__nisw
  # @option opts [Array(String)] :device_status__regex
  # @option opts [Array(String)] :device_type Device type (model)
  # @option opts [Array(String)] :device_type__n Device type (model)
  # @option opts [Array(Int32)] :device_type_id Device type (ID)
  # @option opts [Array(Int32)] :device_type_id__n Device type (ID)
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :label
  # @option opts [Bool] :label__empty
  # @option opts [Array(String)] :label__ic
  # @option opts [Array(String)] :label__ie
  # @option opts [Array(String)] :label__iew
  # @option opts [Array(String)] :label__iregex
  # @option opts [Array(String)] :label__isw
  # @option opts [Array(String)] :label__n
  # @option opts [Array(String)] :label__nic
  # @option opts [Array(String)] :label__nie
  # @option opts [Array(String)] :label__niew
  # @option opts [Array(String)] :label__nisw
  # @option opts [Array(String)] :label__regex
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(String)] :location Location (slug)
  # @option opts [Array(String)] :location__n Location (slug)
  # @option opts [Array(Int32)] :location_id Location (ID)
  # @option opts [Array(Int32)] :location_id__n Location (ID)
  # @option opts [Bool] :mark_connected
  # @option opts [String] :modified_by_request
  # @option opts [Array(Int32)] :module_id Module (ID)
  # @option opts [Array(Int32)] :module_id__n Module (ID)
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Bool] :occupied
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [Array(String)] :rack Rack (name)
  # @option opts [Array(String)] :rack__n Rack (name)
  # @option opts [Array(Int32)] :rack_id Rack (ID)
  # @option opts [Array(Int32)] :rack_id__n Rack (ID)
  # @option opts [Array(String)] :region
  # @option opts [Array(String)] :region__n
  # @option opts [Array(String)] :region_id
  # @option opts [Array(String)] :region_id__n
  # @option opts [Array(String)] :site Site name (slug)
  # @option opts [Array(String)] :site__n Site name (slug)
  # @option opts [Array(String)] :site_group
  # @option opts [Array(String)] :site_group__n
  # @option opts [Array(String)] :site_group_id
  # @option opts [Array(String)] :site_group_id__n
  # @option opts [Array(Int32)] :site_id Site (ID)
  # @option opts [Array(Int32)] :site_id__n Site (ID)
  # @option opts [Int32] :speed Port speed in bits per second  * &#x60;1200&#x60; - 1200 bps * &#x60;2400&#x60; - 2400 bps * &#x60;4800&#x60; - 4800 bps * &#x60;9600&#x60; - 9600 bps * &#x60;19200&#x60; - 19.2 kbps * &#x60;38400&#x60; - 38.4 kbps * &#x60;57600&#x60; - 57.6 kbps * &#x60;115200&#x60; - 115.2 kbps
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [Array(String)] :tenant Tenant (slug)
  # @option opts [Array(String)] :tenant__n Tenant (slug)
  # @option opts [Array(Int32)] :tenant_id Tenant (ID)
  # @option opts [Array(Int32)] :tenant_id__n Tenant (ID)
  # @option opts [Array(String)] :_type Physical port type
  # @option opts [Bool] :type__empty
  # @option opts [Array(String)] :type__ic Physical port type
  # @option opts [Array(String)] :type__ie Physical port type
  # @option opts [Array(String)] :type__iew Physical port type
  # @option opts [Array(String)] :type__iregex Physical port type
  # @option opts [Array(String)] :type__isw Physical port type
  # @option opts [Array(String)] :type__n Physical port type
  # @option opts [Array(String)] :type__nic Physical port type
  # @option opts [Array(String)] :type__nie Physical port type
  # @option opts [Array(String)] :type__niew Physical port type
  # @option opts [Array(String)] :type__nisw Physical port type
  # @option opts [Array(String)] :type__regex Physical port type
  # @option opts [String] :updated_by_request
  # @option opts [Array(String)] :virtual_chassis Virtual Chassis
  # @option opts [Array(String)] :virtual_chassis__n Virtual Chassis
  # @option opts [Array(Int32)] :virtual_chassis_id Virtual Chassis (ID)
  # @option opts [Array(Int32)] :virtual_chassis_id__n Virtual Chassis (ID)
  # @return [PaginatedConsoleServerPortList]
  describe "dcim_console_server_ports_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_server_ports_partial_update
  # Patch a console server port object.
  # @param id A unique integer value identifying this console server port.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableConsoleServerPortRequest] :patched_writable_console_server_port_request
  # @return [ConsoleServerPort]
  describe "dcim_console_server_ports_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_server_ports_retrieve
  # Get a console server port object.
  # @param id A unique integer value identifying this console server port.
  # @param [Hash] opts the optional parameters
  # @return [ConsoleServerPort]
  describe "dcim_console_server_ports_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_server_ports_trace_retrieve
  # Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
  # @param id A unique integer value identifying this console server port.
  # @param [Hash] opts the optional parameters
  # @return [ConsoleServerPort]
  describe "dcim_console_server_ports_trace_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_console_server_ports_update
  # Put a console server port object.
  # @param id A unique integer value identifying this console server port.
  # @param writable_console_server_port_request
  # @param [Hash] opts the optional parameters
  # @return [ConsoleServerPort]
  describe "dcim_console_server_ports_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_bay_templates_bulk_destroy
  # Delete a list of device bay template objects.
  # @param device_bay_template_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_device_bay_templates_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_bay_templates_bulk_partial_update
  # Patch a list of device bay template objects.
  # @param device_bay_template_request
  # @param [Hash] opts the optional parameters
  # @return [Array(DeviceBayTemplate)]
  describe "dcim_device_bay_templates_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_bay_templates_bulk_update
  # Put a list of device bay template objects.
  # @param device_bay_template_request
  # @param [Hash] opts the optional parameters
  # @return [Array(DeviceBayTemplate)]
  describe "dcim_device_bay_templates_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_bay_templates_create
  # Post a list of device bay template objects.
  # @param dcim_device_bay_templates_create_request
  # @param [Hash] opts the optional parameters
  # @return [DeviceBayTemplate]
  describe "dcim_device_bay_templates_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_bay_templates_destroy
  # Delete a device bay template object.
  # @param id A unique integer value identifying this device bay template.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_device_bay_templates_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_bay_templates_list
  # Get a list of device bay template objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :device_type_id Device type (ID)
  # @option opts [Array(Int32)] :device_type_id__n Device type (ID)
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :label
  # @option opts [Bool] :label__empty
  # @option opts [Array(String)] :label__ic
  # @option opts [Array(String)] :label__ie
  # @option opts [Array(String)] :label__iew
  # @option opts [Array(String)] :label__iregex
  # @option opts [Array(String)] :label__isw
  # @option opts [Array(String)] :label__n
  # @option opts [Array(String)] :label__nic
  # @option opts [Array(String)] :label__nie
  # @option opts [Array(String)] :label__niew
  # @option opts [Array(String)] :label__nisw
  # @option opts [Array(String)] :label__regex
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [String] :updated_by_request
  # @return [PaginatedDeviceBayTemplateList]
  describe "dcim_device_bay_templates_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_bay_templates_partial_update
  # Patch a device bay template object.
  # @param id A unique integer value identifying this device bay template.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedDeviceBayTemplateRequest] :patched_device_bay_template_request
  # @return [DeviceBayTemplate]
  describe "dcim_device_bay_templates_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_bay_templates_retrieve
  # Get a device bay template object.
  # @param id A unique integer value identifying this device bay template.
  # @param [Hash] opts the optional parameters
  # @return [DeviceBayTemplate]
  describe "dcim_device_bay_templates_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_bay_templates_update
  # Put a device bay template object.
  # @param id A unique integer value identifying this device bay template.
  # @param device_bay_template_request
  # @param [Hash] opts the optional parameters
  # @return [DeviceBayTemplate]
  describe "dcim_device_bay_templates_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_bays_bulk_destroy
  # Delete a list of device bay objects.
  # @param device_bay_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_device_bays_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_bays_bulk_partial_update
  # Patch a list of device bay objects.
  # @param device_bay_request
  # @param [Hash] opts the optional parameters
  # @return [Array(DeviceBay)]
  describe "dcim_device_bays_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_bays_bulk_update
  # Put a list of device bay objects.
  # @param device_bay_request
  # @param [Hash] opts the optional parameters
  # @return [Array(DeviceBay)]
  describe "dcim_device_bays_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_bays_create
  # Post a list of device bay objects.
  # @param dcim_device_bays_create_request
  # @param [Hash] opts the optional parameters
  # @return [DeviceBay]
  describe "dcim_device_bays_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_bays_destroy
  # Delete a device bay object.
  # @param id A unique integer value identifying this device bay.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_device_bays_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_bays_list
  # Get a list of device bay objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(String)] :device Device (name)
  # @option opts [Array(String)] :device__n Device (name)
  # @option opts [Array(Int32)] :device_id Device (ID)
  # @option opts [Array(Int32)] :device_id__n Device (ID)
  # @option opts [Array(String)] :device_role Device role (slug)
  # @option opts [Array(String)] :device_role__n Device role (slug)
  # @option opts [Array(Int32)] :device_role_id Device role (ID)
  # @option opts [Array(Int32)] :device_role_id__n Device role (ID)
  # @option opts [Array(String)] :device_status
  # @option opts [Bool] :device_status__empty
  # @option opts [Array(String)] :device_status__ic
  # @option opts [Array(String)] :device_status__ie
  # @option opts [Array(String)] :device_status__iew
  # @option opts [Array(String)] :device_status__iregex
  # @option opts [Array(String)] :device_status__isw
  # @option opts [Array(String)] :device_status__n
  # @option opts [Array(String)] :device_status__nic
  # @option opts [Array(String)] :device_status__nie
  # @option opts [Array(String)] :device_status__niew
  # @option opts [Array(String)] :device_status__nisw
  # @option opts [Array(String)] :device_status__regex
  # @option opts [Array(String)] :device_type Device type (model)
  # @option opts [Array(String)] :device_type__n Device type (model)
  # @option opts [Array(Int32)] :device_type_id Device type (ID)
  # @option opts [Array(Int32)] :device_type_id__n Device type (ID)
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :installed_device Installed device (name)
  # @option opts [Array(String)] :installed_device__n Installed device (name)
  # @option opts [Array(Int32)] :installed_device_id Installed device (ID)
  # @option opts [Array(Int32)] :installed_device_id__n Installed device (ID)
  # @option opts [Array(String)] :label
  # @option opts [Bool] :label__empty
  # @option opts [Array(String)] :label__ic
  # @option opts [Array(String)] :label__ie
  # @option opts [Array(String)] :label__iew
  # @option opts [Array(String)] :label__iregex
  # @option opts [Array(String)] :label__isw
  # @option opts [Array(String)] :label__n
  # @option opts [Array(String)] :label__nic
  # @option opts [Array(String)] :label__nie
  # @option opts [Array(String)] :label__niew
  # @option opts [Array(String)] :label__nisw
  # @option opts [Array(String)] :label__regex
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(String)] :location Location (slug)
  # @option opts [Array(String)] :location__n Location (slug)
  # @option opts [Array(Int32)] :location_id Location (ID)
  # @option opts [Array(Int32)] :location_id__n Location (ID)
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [Array(String)] :rack Rack (name)
  # @option opts [Array(String)] :rack__n Rack (name)
  # @option opts [Array(Int32)] :rack_id Rack (ID)
  # @option opts [Array(Int32)] :rack_id__n Rack (ID)
  # @option opts [Array(String)] :region
  # @option opts [Array(String)] :region__n
  # @option opts [Array(String)] :region_id
  # @option opts [Array(String)] :region_id__n
  # @option opts [Array(String)] :site Site name (slug)
  # @option opts [Array(String)] :site__n Site name (slug)
  # @option opts [Array(String)] :site_group
  # @option opts [Array(String)] :site_group__n
  # @option opts [Array(String)] :site_group_id
  # @option opts [Array(String)] :site_group_id__n
  # @option opts [Array(Int32)] :site_id Site (ID)
  # @option opts [Array(Int32)] :site_id__n Site (ID)
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [Array(String)] :tenant Tenant (slug)
  # @option opts [Array(String)] :tenant__n Tenant (slug)
  # @option opts [Array(Int32)] :tenant_id Tenant (ID)
  # @option opts [Array(Int32)] :tenant_id__n Tenant (ID)
  # @option opts [String] :updated_by_request
  # @option opts [Array(String)] :virtual_chassis Virtual Chassis
  # @option opts [Array(String)] :virtual_chassis__n Virtual Chassis
  # @option opts [Array(Int32)] :virtual_chassis_id Virtual Chassis (ID)
  # @option opts [Array(Int32)] :virtual_chassis_id__n Virtual Chassis (ID)
  # @return [PaginatedDeviceBayList]
  describe "dcim_device_bays_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_bays_partial_update
  # Patch a device bay object.
  # @param id A unique integer value identifying this device bay.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedDeviceBayRequest] :patched_device_bay_request
  # @return [DeviceBay]
  describe "dcim_device_bays_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_bays_retrieve
  # Get a device bay object.
  # @param id A unique integer value identifying this device bay.
  # @param [Hash] opts the optional parameters
  # @return [DeviceBay]
  describe "dcim_device_bays_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_bays_update
  # Put a device bay object.
  # @param id A unique integer value identifying this device bay.
  # @param device_bay_request
  # @param [Hash] opts the optional parameters
  # @return [DeviceBay]
  describe "dcim_device_bays_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_roles_bulk_destroy
  # Delete a list of device role objects.
  # @param device_role_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_device_roles_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_roles_bulk_partial_update
  # Patch a list of device role objects.
  # @param device_role_request
  # @param [Hash] opts the optional parameters
  # @return [Array(DeviceRole)]
  describe "dcim_device_roles_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_roles_bulk_update
  # Put a list of device role objects.
  # @param device_role_request
  # @param [Hash] opts the optional parameters
  # @return [Array(DeviceRole)]
  describe "dcim_device_roles_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_roles_create
  # Post a list of device role objects.
  # @param dcim_device_roles_create_request
  # @param [Hash] opts the optional parameters
  # @return [DeviceRole]
  describe "dcim_device_roles_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_roles_destroy
  # Delete a device role object.
  # @param id A unique integer value identifying this device role.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_device_roles_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_roles_list
  # Get a list of device role objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(String)] :ancestor
  # @option opts [Array(String)] :ancestor__n
  # @option opts [Array(String)] :ancestor_id
  # @option opts [Array(String)] :ancestor_id__n
  # @option opts [Array(String)] :color
  # @option opts [Bool] :color__empty
  # @option opts [Array(String)] :color__ic
  # @option opts [Array(String)] :color__ie
  # @option opts [Array(String)] :color__iew
  # @option opts [Array(String)] :color__iregex
  # @option opts [Array(String)] :color__isw
  # @option opts [Array(String)] :color__n
  # @option opts [Array(String)] :color__nic
  # @option opts [Array(String)] :color__nie
  # @option opts [Array(String)] :color__niew
  # @option opts [Array(String)] :color__nisw
  # @option opts [Array(String)] :color__regex
  # @option opts [Array(Int32)] :config_template_id Config template (ID)
  # @option opts [Array(Int32)] :config_template_id__n Config template (ID)
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Array(String)] :parent Parent device role (slug)
  # @option opts [Array(String)] :parent__n Parent device role (slug)
  # @option opts [Array(Int32)] :parent_id Parent device role (ID)
  # @option opts [Array(Int32)] :parent_id__n Parent device role (ID)
  # @option opts [String] :q Search
  # @option opts [Array(String)] :slug
  # @option opts [Bool] :slug__empty
  # @option opts [Array(String)] :slug__ic
  # @option opts [Array(String)] :slug__ie
  # @option opts [Array(String)] :slug__iew
  # @option opts [Array(String)] :slug__iregex
  # @option opts [Array(String)] :slug__isw
  # @option opts [Array(String)] :slug__n
  # @option opts [Array(String)] :slug__nic
  # @option opts [Array(String)] :slug__nie
  # @option opts [Array(String)] :slug__niew
  # @option opts [Array(String)] :slug__nisw
  # @option opts [Array(String)] :slug__regex
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [String] :updated_by_request
  # @option opts [Bool] :vm_role
  # @return [PaginatedDeviceRoleList]
  describe "dcim_device_roles_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_roles_partial_update
  # Patch a device role object.
  # @param id A unique integer value identifying this device role.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableDeviceRoleRequest] :patched_writable_device_role_request
  # @return [DeviceRole]
  describe "dcim_device_roles_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_roles_retrieve
  # Get a device role object.
  # @param id A unique integer value identifying this device role.
  # @param [Hash] opts the optional parameters
  # @return [DeviceRole]
  describe "dcim_device_roles_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_roles_update
  # Put a device role object.
  # @param id A unique integer value identifying this device role.
  # @param writable_device_role_request
  # @param [Hash] opts the optional parameters
  # @return [DeviceRole]
  describe "dcim_device_roles_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_types_bulk_destroy
  # Delete a list of device type objects.
  # @param device_type_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_device_types_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_types_bulk_partial_update
  # Patch a list of device type objects.
  # @param device_type_request
  # @param [Hash] opts the optional parameters
  # @return [Array(DeviceType)]
  describe "dcim_device_types_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_types_bulk_update
  # Put a list of device type objects.
  # @param device_type_request
  # @param [Hash] opts the optional parameters
  # @return [Array(DeviceType)]
  describe "dcim_device_types_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_types_create
  # Post a list of device type objects.
  # @param dcim_device_types_create_request
  # @param [Hash] opts the optional parameters
  # @return [DeviceType]
  describe "dcim_device_types_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_types_destroy
  # Delete a device type object.
  # @param id A unique integer value identifying this device type.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_device_types_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_types_list
  # Get a list of device type objects.
  # @param [Hash] opts the optional parameters
  # @option opts [String] :airflow * &#x60;front-to-rear&#x60; - Front to rear * &#x60;rear-to-front&#x60; - Rear to front * &#x60;left-to-right&#x60; - Left to right * &#x60;right-to-left&#x60; - Right to left * &#x60;side-to-rear&#x60; - Side to rear * &#x60;rear-to-side&#x60; - Rear to side * &#x60;bottom-to-top&#x60; - Bottom to top * &#x60;top-to-bottom&#x60; - Top to bottom * &#x60;passive&#x60; - Passive * &#x60;mixed&#x60; - Mixed
  # @option opts [Array(Int32)] :console_port_template_count
  # @option opts [Bool] :console_port_template_count__empty
  # @option opts [Array(Int32)] :console_port_template_count__gt
  # @option opts [Array(Int32)] :console_port_template_count__gte
  # @option opts [Array(Int32)] :console_port_template_count__lt
  # @option opts [Array(Int32)] :console_port_template_count__lte
  # @option opts [Array(Int32)] :console_port_template_count__n
  # @option opts [Bool] :console_ports Has console ports
  # @option opts [Array(Int32)] :console_server_port_template_count
  # @option opts [Bool] :console_server_port_template_count__empty
  # @option opts [Array(Int32)] :console_server_port_template_count__gt
  # @option opts [Array(Int32)] :console_server_port_template_count__gte
  # @option opts [Array(Int32)] :console_server_port_template_count__lt
  # @option opts [Array(Int32)] :console_server_port_template_count__lte
  # @option opts [Array(Int32)] :console_server_port_template_count__n
  # @option opts [Bool] :console_server_ports Has console server ports
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :default_platform
  # @option opts [Array(String)] :default_platform__n
  # @option opts [Array(String)] :default_platform_id
  # @option opts [Array(String)] :default_platform_id__n
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :device_bay_template_count
  # @option opts [Bool] :device_bay_template_count__empty
  # @option opts [Array(Int32)] :device_bay_template_count__gt
  # @option opts [Array(Int32)] :device_bay_template_count__gte
  # @option opts [Array(Int32)] :device_bay_template_count__lt
  # @option opts [Array(Int32)] :device_bay_template_count__lte
  # @option opts [Array(Int32)] :device_bay_template_count__n
  # @option opts [Bool] :device_bays Has device bays
  # @option opts [Bool] :exclude_from_utilization
  # @option opts [Array(Int32)] :front_port_template_count
  # @option opts [Bool] :front_port_template_count__empty
  # @option opts [Array(Int32)] :front_port_template_count__gt
  # @option opts [Array(Int32)] :front_port_template_count__gte
  # @option opts [Array(Int32)] :front_port_template_count__lt
  # @option opts [Array(Int32)] :front_port_template_count__lte
  # @option opts [Array(Int32)] :front_port_template_count__n
  # @option opts [Bool] :has_front_image Has a front image
  # @option opts [Bool] :has_rear_image Has a rear image
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(Int32)] :interface_template_count
  # @option opts [Bool] :interface_template_count__empty
  # @option opts [Array(Int32)] :interface_template_count__gt
  # @option opts [Array(Int32)] :interface_template_count__gte
  # @option opts [Array(Int32)] :interface_template_count__lt
  # @option opts [Array(Int32)] :interface_template_count__lte
  # @option opts [Array(Int32)] :interface_template_count__n
  # @option opts [Bool] :interfaces Has interfaces
  # @option opts [Array(Int32)] :inventory_item_template_count
  # @option opts [Bool] :inventory_item_template_count__empty
  # @option opts [Array(Int32)] :inventory_item_template_count__gt
  # @option opts [Array(Int32)] :inventory_item_template_count__gte
  # @option opts [Array(Int32)] :inventory_item_template_count__lt
  # @option opts [Array(Int32)] :inventory_item_template_count__lte
  # @option opts [Array(Int32)] :inventory_item_template_count__n
  # @option opts [Bool] :inventory_items Has inventory items
  # @option opts [Bool] :is_full_depth
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(String)] :manufacturer Manufacturer (slug)
  # @option opts [Array(String)] :manufacturer__n Manufacturer (slug)
  # @option opts [Array(Int32)] :manufacturer_id Manufacturer (ID)
  # @option opts [Array(Int32)] :manufacturer_id__n Manufacturer (ID)
  # @option opts [Array(String)] :model
  # @option opts [Bool] :model__empty
  # @option opts [Array(String)] :model__ic
  # @option opts [Array(String)] :model__ie
  # @option opts [Array(String)] :model__iew
  # @option opts [Array(String)] :model__iregex
  # @option opts [Array(String)] :model__isw
  # @option opts [Array(String)] :model__n
  # @option opts [Array(String)] :model__nic
  # @option opts [Array(String)] :model__nie
  # @option opts [Array(String)] :model__niew
  # @option opts [Array(String)] :model__nisw
  # @option opts [Array(String)] :model__regex
  # @option opts [String] :modified_by_request
  # @option opts [Array(Int32)] :module_bay_template_count
  # @option opts [Bool] :module_bay_template_count__empty
  # @option opts [Array(Int32)] :module_bay_template_count__gt
  # @option opts [Array(Int32)] :module_bay_template_count__gte
  # @option opts [Array(Int32)] :module_bay_template_count__lt
  # @option opts [Array(Int32)] :module_bay_template_count__lte
  # @option opts [Array(Int32)] :module_bay_template_count__n
  # @option opts [Bool] :module_bays Has module bays
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Array(String)] :part_number
  # @option opts [Bool] :part_number__empty
  # @option opts [Array(String)] :part_number__ic
  # @option opts [Array(String)] :part_number__ie
  # @option opts [Array(String)] :part_number__iew
  # @option opts [Array(String)] :part_number__iregex
  # @option opts [Array(String)] :part_number__isw
  # @option opts [Array(String)] :part_number__n
  # @option opts [Array(String)] :part_number__nic
  # @option opts [Array(String)] :part_number__nie
  # @option opts [Array(String)] :part_number__niew
  # @option opts [Array(String)] :part_number__nisw
  # @option opts [Array(String)] :part_number__regex
  # @option opts [Bool] :pass_through_ports Has pass-through ports
  # @option opts [Array(Int32)] :power_outlet_template_count
  # @option opts [Bool] :power_outlet_template_count__empty
  # @option opts [Array(Int32)] :power_outlet_template_count__gt
  # @option opts [Array(Int32)] :power_outlet_template_count__gte
  # @option opts [Array(Int32)] :power_outlet_template_count__lt
  # @option opts [Array(Int32)] :power_outlet_template_count__lte
  # @option opts [Array(Int32)] :power_outlet_template_count__n
  # @option opts [Bool] :power_outlets Has power outlets
  # @option opts [Array(Int32)] :power_port_template_count
  # @option opts [Bool] :power_port_template_count__empty
  # @option opts [Array(Int32)] :power_port_template_count__gt
  # @option opts [Array(Int32)] :power_port_template_count__gte
  # @option opts [Array(Int32)] :power_port_template_count__lt
  # @option opts [Array(Int32)] :power_port_template_count__lte
  # @option opts [Array(Int32)] :power_port_template_count__n
  # @option opts [Bool] :power_ports Has power ports
  # @option opts [String] :q Search
  # @option opts [Array(Int32)] :rear_port_template_count
  # @option opts [Bool] :rear_port_template_count__empty
  # @option opts [Array(Int32)] :rear_port_template_count__gt
  # @option opts [Array(Int32)] :rear_port_template_count__gte
  # @option opts [Array(Int32)] :rear_port_template_count__lt
  # @option opts [Array(Int32)] :rear_port_template_count__lte
  # @option opts [Array(Int32)] :rear_port_template_count__n
  # @option opts [Array(String)] :slug
  # @option opts [Bool] :slug__empty
  # @option opts [Array(String)] :slug__ic
  # @option opts [Array(String)] :slug__ie
  # @option opts [Array(String)] :slug__iew
  # @option opts [Array(String)] :slug__iregex
  # @option opts [Array(String)] :slug__isw
  # @option opts [Array(String)] :slug__n
  # @option opts [Array(String)] :slug__nic
  # @option opts [Array(String)] :slug__nie
  # @option opts [Array(String)] :slug__niew
  # @option opts [Array(String)] :slug__nisw
  # @option opts [Array(String)] :slug__regex
  # @option opts [String] :subdevice_role Parent devices house child devices in device bays. Leave blank if this device type is neither a parent nor a child.  * &#x60;parent&#x60; - Parent * &#x60;child&#x60; - Child
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [Array(Float64)] :u_height
  # @option opts [Bool] :u_height__empty
  # @option opts [Array(Float64)] :u_height__gt
  # @option opts [Array(Float64)] :u_height__gte
  # @option opts [Array(Float64)] :u_height__lt
  # @option opts [Array(Float64)] :u_height__lte
  # @option opts [Array(Float64)] :u_height__n
  # @option opts [String] :updated_by_request
  # @option opts [Array(Float64)] :weight
  # @option opts [Bool] :weight__empty
  # @option opts [Array(Float64)] :weight__gt
  # @option opts [Array(Float64)] :weight__gte
  # @option opts [Array(Float64)] :weight__lt
  # @option opts [Array(Float64)] :weight__lte
  # @option opts [Array(Float64)] :weight__n
  # @option opts [String] :weight_unit * &#x60;kg&#x60; - Kilograms * &#x60;g&#x60; - Grams * &#x60;lb&#x60; - Pounds * &#x60;oz&#x60; - Ounces
  # @return [PaginatedDeviceTypeList]
  describe "dcim_device_types_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_types_partial_update
  # Patch a device type object.
  # @param id A unique integer value identifying this device type.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableDeviceTypeRequest] :patched_writable_device_type_request
  # @return [DeviceType]
  describe "dcim_device_types_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_types_retrieve
  # Get a device type object.
  # @param id A unique integer value identifying this device type.
  # @param [Hash] opts the optional parameters
  # @return [DeviceType]
  describe "dcim_device_types_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_device_types_update
  # Put a device type object.
  # @param id A unique integer value identifying this device type.
  # @param writable_device_type_request
  # @param [Hash] opts the optional parameters
  # @return [DeviceType]
  describe "dcim_device_types_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_devices_bulk_destroy
  # Delete a list of device objects.
  # @param device_with_config_context_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_devices_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_devices_bulk_partial_update
  # Patch a list of device objects.
  # @param device_with_config_context_request
  # @param [Hash] opts the optional parameters
  # @return [Array(DeviceWithConfigContext)]
  describe "dcim_devices_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_devices_bulk_update
  # Put a list of device objects.
  # @param device_with_config_context_request
  # @param [Hash] opts the optional parameters
  # @return [Array(DeviceWithConfigContext)]
  describe "dcim_devices_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_devices_create
  # Post a list of device objects.
  # @param dcim_devices_create_request
  # @param [Hash] opts the optional parameters
  # @return [DeviceWithConfigContext]
  describe "dcim_devices_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_devices_destroy
  # Delete a device object.
  # @param id A unique integer value identifying this device.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_devices_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_devices_list
  # Get a list of device objects.
  # @param [Hash] opts the optional parameters
  # @option opts [String] :airflow * &#x60;front-to-rear&#x60; - Front to rear * &#x60;rear-to-front&#x60; - Rear to front * &#x60;left-to-right&#x60; - Left to right * &#x60;right-to-left&#x60; - Right to left * &#x60;side-to-rear&#x60; - Side to rear * &#x60;rear-to-side&#x60; - Rear to side * &#x60;bottom-to-top&#x60; - Bottom to top * &#x60;top-to-bottom&#x60; - Top to bottom * &#x60;passive&#x60; - Passive * &#x60;mixed&#x60; - Mixed
  # @option opts [Array(String)] :asset_tag
  # @option opts [Bool] :asset_tag__empty
  # @option opts [Array(String)] :asset_tag__ic
  # @option opts [Array(String)] :asset_tag__ie
  # @option opts [Array(String)] :asset_tag__iew
  # @option opts [Array(String)] :asset_tag__iregex
  # @option opts [Array(String)] :asset_tag__isw
  # @option opts [Array(String)] :asset_tag__n
  # @option opts [Array(String)] :asset_tag__nic
  # @option opts [Array(String)] :asset_tag__nie
  # @option opts [Array(String)] :asset_tag__niew
  # @option opts [Array(String)] :asset_tag__nisw
  # @option opts [Array(String)] :asset_tag__regex
  # @option opts [Array(String)] :cluster_group Cluster group (slug)
  # @option opts [Array(String)] :cluster_group__n Cluster group (slug)
  # @option opts [Array(Int32)] :cluster_group_id Cluster group (ID)
  # @option opts [Array(Int32)] :cluster_group_id__n Cluster group (ID)
  # @option opts [Array(Int32)] :cluster_id VM cluster (ID)
  # @option opts [Array(Int32)] :cluster_id__n VM cluster (ID)
  # @option opts [Array(Int32)] :config_template_id Config template (ID)
  # @option opts [Array(Int32)] :config_template_id__n Config template (ID)
  # @option opts [Array(Int32)] :console_port_count
  # @option opts [Bool] :console_port_count__empty
  # @option opts [Array(Int32)] :console_port_count__gt
  # @option opts [Array(Int32)] :console_port_count__gte
  # @option opts [Array(Int32)] :console_port_count__lt
  # @option opts [Array(Int32)] :console_port_count__lte
  # @option opts [Array(Int32)] :console_port_count__n
  # @option opts [Bool] :console_ports Has console ports
  # @option opts [Array(Int32)] :console_server_port_count
  # @option opts [Bool] :console_server_port_count__empty
  # @option opts [Array(Int32)] :console_server_port_count__gt
  # @option opts [Array(Int32)] :console_server_port_count__gte
  # @option opts [Array(Int32)] :console_server_port_count__lt
  # @option opts [Array(Int32)] :console_server_port_count__lte
  # @option opts [Array(Int32)] :console_server_port_count__n
  # @option opts [Bool] :console_server_ports Has console server ports
  # @option opts [Array(Int32)] :contact Contact
  # @option opts [Array(Int32)] :contact__n Contact
  # @option opts [Array(String)] :contact_group
  # @option opts [Array(String)] :contact_group__n
  # @option opts [Array(Int32)] :contact_role Contact Role
  # @option opts [Array(Int32)] :contact_role__n Contact Role
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :device_bay_count
  # @option opts [Bool] :device_bay_count__empty
  # @option opts [Array(Int32)] :device_bay_count__gt
  # @option opts [Array(Int32)] :device_bay_count__gte
  # @option opts [Array(Int32)] :device_bay_count__lt
  # @option opts [Array(Int32)] :device_bay_count__lte
  # @option opts [Array(Int32)] :device_bay_count__n
  # @option opts [Bool] :device_bays Has device bays
  # @option opts [Array(String)] :device_type Device type (slug)
  # @option opts [Array(String)] :device_type__n Device type (slug)
  # @option opts [Array(Int32)] :device_type_id Device type (ID)
  # @option opts [Array(Int32)] :device_type_id__n Device type (ID)
  # @option opts [String] :face * &#x60;front&#x60; - Front * &#x60;rear&#x60; - Rear
  # @option opts [Array(Int32)] :front_port_count
  # @option opts [Bool] :front_port_count__empty
  # @option opts [Array(Int32)] :front_port_count__gt
  # @option opts [Array(Int32)] :front_port_count__gte
  # @option opts [Array(Int32)] :front_port_count__lt
  # @option opts [Array(Int32)] :front_port_count__lte
  # @option opts [Array(Int32)] :front_port_count__n
  # @option opts [Bool] :has_oob_ip Has an out-of-band IP
  # @option opts [Bool] :has_primary_ip Has a primary IP
  # @option opts [Bool] :has_virtual_device_context Has virtual device context
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(Int32)] :interface_count
  # @option opts [Bool] :interface_count__empty
  # @option opts [Array(Int32)] :interface_count__gt
  # @option opts [Array(Int32)] :interface_count__gte
  # @option opts [Array(Int32)] :interface_count__lt
  # @option opts [Array(Int32)] :interface_count__lte
  # @option opts [Array(Int32)] :interface_count__n
  # @option opts [Bool] :interfaces Has interfaces
  # @option opts [Array(Int32)] :inventory_item_count
  # @option opts [Bool] :inventory_item_count__empty
  # @option opts [Array(Int32)] :inventory_item_count__gt
  # @option opts [Array(Int32)] :inventory_item_count__gte
  # @option opts [Array(Int32)] :inventory_item_count__lt
  # @option opts [Array(Int32)] :inventory_item_count__lte
  # @option opts [Array(Int32)] :inventory_item_count__n
  # @option opts [Bool] :is_full_depth Is full depth
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Array(Float64)] :latitude
  # @option opts [Bool] :latitude__empty
  # @option opts [Array(Float64)] :latitude__gt
  # @option opts [Array(Float64)] :latitude__gte
  # @option opts [Array(Float64)] :latitude__lt
  # @option opts [Array(Float64)] :latitude__lte
  # @option opts [Array(Float64)] :latitude__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Bool] :local_context_data Has local config context data
  # @option opts [Array(String)] :location
  # @option opts [Array(String)] :location__n
  # @option opts [Array(String)] :location_id
  # @option opts [Array(String)] :location_id__n
  # @option opts [Array(Float64)] :longitude
  # @option opts [Bool] :longitude__empty
  # @option opts [Array(Float64)] :longitude__gt
  # @option opts [Array(Float64)] :longitude__gte
  # @option opts [Array(Float64)] :longitude__lt
  # @option opts [Array(Float64)] :longitude__lte
  # @option opts [Array(Float64)] :longitude__n
  # @option opts [Array(String)] :mac_address
  # @option opts [Array(String)] :mac_address__ic
  # @option opts [Array(String)] :mac_address__ie
  # @option opts [Array(String)] :mac_address__iew
  # @option opts [Array(String)] :mac_address__iregex
  # @option opts [Array(String)] :mac_address__isw
  # @option opts [Array(String)] :mac_address__n
  # @option opts [Array(String)] :mac_address__nic
  # @option opts [Array(String)] :mac_address__nie
  # @option opts [Array(String)] :mac_address__niew
  # @option opts [Array(String)] :mac_address__nisw
  # @option opts [Array(String)] :mac_address__regex
  # @option opts [Array(String)] :manufacturer Manufacturer (slug)
  # @option opts [Array(String)] :manufacturer__n Manufacturer (slug)
  # @option opts [Array(Int32)] :manufacturer_id Manufacturer (ID)
  # @option opts [Array(Int32)] :manufacturer_id__n Manufacturer (ID)
  # @option opts [Array(String)] :model Device model (slug)
  # @option opts [Array(String)] :model__n Device model (slug)
  # @option opts [String] :modified_by_request
  # @option opts [Array(Int32)] :module_bay_count
  # @option opts [Bool] :module_bay_count__empty
  # @option opts [Array(Int32)] :module_bay_count__gt
  # @option opts [Array(Int32)] :module_bay_count__gte
  # @option opts [Array(Int32)] :module_bay_count__lt
  # @option opts [Array(Int32)] :module_bay_count__lte
  # @option opts [Array(Int32)] :module_bay_count__n
  # @option opts [Bool] :module_bays Has module bays
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [Array(Int32)] :oob_ip_id OOB IP (ID)
  # @option opts [Array(Int32)] :oob_ip_id__n OOB IP (ID)
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Array(Int32)] :parent_bay_id Parent bay (ID)
  # @option opts [Array(Int32)] :parent_bay_id__n Parent bay (ID)
  # @option opts [Array(Int32)] :parent_device_id Parent Device (ID)
  # @option opts [Array(Int32)] :parent_device_id__n Parent Device (ID)
  # @option opts [Bool] :pass_through_ports Has pass-through ports
  # @option opts [Array(String)] :platform
  # @option opts [Array(String)] :platform__n
  # @option opts [Array(String)] :platform_id
  # @option opts [Array(String)] :platform_id__n
  # @option opts [Array(Float64)] :position
  # @option opts [Bool] :position__empty
  # @option opts [Array(Float64)] :position__gt
  # @option opts [Array(Float64)] :position__gte
  # @option opts [Array(Float64)] :position__lt
  # @option opts [Array(Float64)] :position__lte
  # @option opts [Array(Float64)] :position__n
  # @option opts [Array(Int32)] :power_outlet_count
  # @option opts [Bool] :power_outlet_count__empty
  # @option opts [Array(Int32)] :power_outlet_count__gt
  # @option opts [Array(Int32)] :power_outlet_count__gte
  # @option opts [Array(Int32)] :power_outlet_count__lt
  # @option opts [Array(Int32)] :power_outlet_count__lte
  # @option opts [Array(Int32)] :power_outlet_count__n
  # @option opts [Bool] :power_outlets Has power outlets
  # @option opts [Array(Int32)] :power_port_count
  # @option opts [Bool] :power_port_count__empty
  # @option opts [Array(Int32)] :power_port_count__gt
  # @option opts [Array(Int32)] :power_port_count__gte
  # @option opts [Array(Int32)] :power_port_count__lt
  # @option opts [Array(Int32)] :power_port_count__lte
  # @option opts [Array(Int32)] :power_port_count__n
  # @option opts [Bool] :power_ports Has power ports
  # @option opts [Array(String)] :primary_ip4 Primary IPv4 (address)
  # @option opts [Array(String)] :primary_ip4__n Primary IPv4 (address)
  # @option opts [Array(Int32)] :primary_ip4_id Primary IPv4 (ID)
  # @option opts [Array(Int32)] :primary_ip4_id__n Primary IPv4 (ID)
  # @option opts [Array(String)] :primary_ip6 Primary IPv6 (address)
  # @option opts [Array(String)] :primary_ip6__n Primary IPv6 (address)
  # @option opts [Array(Int32)] :primary_ip6_id Primary IPv6 (ID)
  # @option opts [Array(Int32)] :primary_ip6_id__n Primary IPv6 (ID)
  # @option opts [String] :q Search
  # @option opts [Array(Int32)] :rack_id Rack (ID)
  # @option opts [Array(Int32)] :rack_id__n Rack (ID)
  # @option opts [Array(Int32)] :rear_port_count
  # @option opts [Bool] :rear_port_count__empty
  # @option opts [Array(Int32)] :rear_port_count__gt
  # @option opts [Array(Int32)] :rear_port_count__gte
  # @option opts [Array(Int32)] :rear_port_count__lt
  # @option opts [Array(Int32)] :rear_port_count__lte
  # @option opts [Array(Int32)] :rear_port_count__n
  # @option opts [Array(String)] :region
  # @option opts [Array(String)] :region__n
  # @option opts [Array(String)] :region_id
  # @option opts [Array(String)] :region_id__n
  # @option opts [Array(String)] :role
  # @option opts [Array(String)] :role__n
  # @option opts [Array(String)] :role_id
  # @option opts [Array(String)] :role_id__n
  # @option opts [Array(String)] :serial
  # @option opts [Bool] :serial__empty
  # @option opts [Array(String)] :serial__ic
  # @option opts [Array(String)] :serial__ie
  # @option opts [Array(String)] :serial__iew
  # @option opts [Array(String)] :serial__iregex
  # @option opts [Array(String)] :serial__isw
  # @option opts [Array(String)] :serial__n
  # @option opts [Array(String)] :serial__nic
  # @option opts [Array(String)] :serial__nie
  # @option opts [Array(String)] :serial__niew
  # @option opts [Array(String)] :serial__nisw
  # @option opts [Array(String)] :serial__regex
  # @option opts [Array(String)] :site Site name (slug)
  # @option opts [Array(String)] :site__n Site name (slug)
  # @option opts [Array(String)] :site_group
  # @option opts [Array(String)] :site_group__n
  # @option opts [Array(String)] :site_group_id
  # @option opts [Array(String)] :site_group_id__n
  # @option opts [Array(Int32)] :site_id Site (ID)
  # @option opts [Array(Int32)] :site_id__n Site (ID)
  # @option opts [Array(String)] :status
  # @option opts [Bool] :status__empty
  # @option opts [Array(String)] :status__ic
  # @option opts [Array(String)] :status__ie
  # @option opts [Array(String)] :status__iew
  # @option opts [Array(String)] :status__iregex
  # @option opts [Array(String)] :status__isw
  # @option opts [Array(String)] :status__n
  # @option opts [Array(String)] :status__nic
  # @option opts [Array(String)] :status__nie
  # @option opts [Array(String)] :status__niew
  # @option opts [Array(String)] :status__nisw
  # @option opts [Array(String)] :status__regex
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [Array(String)] :tenant Tenant (slug)
  # @option opts [Array(String)] :tenant__n Tenant (slug)
  # @option opts [Array(String)] :tenant_group
  # @option opts [Array(String)] :tenant_group__n
  # @option opts [Array(String)] :tenant_group_id
  # @option opts [Array(String)] :tenant_group_id__n
  # @option opts [Array(Int32)] :tenant_id Tenant (ID)
  # @option opts [Array(Int32)] :tenant_id__n Tenant (ID)
  # @option opts [String] :updated_by_request
  # @option opts [Array(Int32)] :vc_position
  # @option opts [Bool] :vc_position__empty
  # @option opts [Array(Int32)] :vc_position__gt
  # @option opts [Array(Int32)] :vc_position__gte
  # @option opts [Array(Int32)] :vc_position__lt
  # @option opts [Array(Int32)] :vc_position__lte
  # @option opts [Array(Int32)] :vc_position__n
  # @option opts [Array(Int32)] :vc_priority
  # @option opts [Bool] :vc_priority__empty
  # @option opts [Array(Int32)] :vc_priority__gt
  # @option opts [Array(Int32)] :vc_priority__gte
  # @option opts [Array(Int32)] :vc_priority__lt
  # @option opts [Array(Int32)] :vc_priority__lte
  # @option opts [Array(Int32)] :vc_priority__n
  # @option opts [Array(Int32)] :virtual_chassis_id Virtual chassis (ID)
  # @option opts [Array(Int32)] :virtual_chassis_id__n Virtual chassis (ID)
  # @option opts [Bool] :virtual_chassis_member Is a virtual chassis member
  # @return [PaginatedDeviceWithConfigContextList]
  describe "dcim_devices_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_devices_partial_update
  # Patch a device object.
  # @param id A unique integer value identifying this device.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableDeviceWithConfigContextRequest] :patched_writable_device_with_config_context_request
  # @return [DeviceWithConfigContext]
  describe "dcim_devices_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_devices_render_config_create
  # Resolve and render the preferred ConfigTemplate for this Device.
  # @param id A unique integer value identifying this device.
  # @param writable_device_with_config_context_request
  # @param [Hash] opts the optional parameters
  # @option opts [String] :format
  # @return [DeviceWithConfigContext]
  describe "dcim_devices_render_config_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_devices_retrieve
  # Get a device object.
  # @param id A unique integer value identifying this device.
  # @param [Hash] opts the optional parameters
  # @return [DeviceWithConfigContext]
  describe "dcim_devices_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_devices_update
  # Put a device object.
  # @param id A unique integer value identifying this device.
  # @param writable_device_with_config_context_request
  # @param [Hash] opts the optional parameters
  # @return [DeviceWithConfigContext]
  describe "dcim_devices_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_front_port_templates_bulk_destroy
  # Delete a list of front port template objects.
  # @param front_port_template_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_front_port_templates_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_front_port_templates_bulk_partial_update
  # Patch a list of front port template objects.
  # @param front_port_template_request
  # @param [Hash] opts the optional parameters
  # @return [Array(FrontPortTemplate)]
  describe "dcim_front_port_templates_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_front_port_templates_bulk_update
  # Put a list of front port template objects.
  # @param front_port_template_request
  # @param [Hash] opts the optional parameters
  # @return [Array(FrontPortTemplate)]
  describe "dcim_front_port_templates_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_front_port_templates_create
  # Post a list of front port template objects.
  # @param dcim_front_port_templates_create_request
  # @param [Hash] opts the optional parameters
  # @return [FrontPortTemplate]
  describe "dcim_front_port_templates_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_front_port_templates_destroy
  # Delete a front port template object.
  # @param id A unique integer value identifying this front port template.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_front_port_templates_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_front_port_templates_list
  # Get a list of front port template objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(String)] :color
  # @option opts [Bool] :color__empty
  # @option opts [Array(String)] :color__ic
  # @option opts [Array(String)] :color__ie
  # @option opts [Array(String)] :color__iew
  # @option opts [Array(String)] :color__iregex
  # @option opts [Array(String)] :color__isw
  # @option opts [Array(String)] :color__n
  # @option opts [Array(String)] :color__nic
  # @option opts [Array(String)] :color__nie
  # @option opts [Array(String)] :color__niew
  # @option opts [Array(String)] :color__nisw
  # @option opts [Array(String)] :color__regex
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :device_type_id Device type (ID)
  # @option opts [Array(Int32)] :device_type_id__n Device type (ID)
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :label
  # @option opts [Bool] :label__empty
  # @option opts [Array(String)] :label__ic
  # @option opts [Array(String)] :label__ie
  # @option opts [Array(String)] :label__iew
  # @option opts [Array(String)] :label__iregex
  # @option opts [Array(String)] :label__isw
  # @option opts [Array(String)] :label__n
  # @option opts [Array(String)] :label__nic
  # @option opts [Array(String)] :label__nie
  # @option opts [Array(String)] :label__niew
  # @option opts [Array(String)] :label__nisw
  # @option opts [Array(String)] :label__regex
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [String] :modified_by_request
  # @option opts [Array(Int32)] :module_type_id Module type (ID)
  # @option opts [Array(Int32)] :module_type_id__n Module type (ID)
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [Array(Int32)] :rear_port_id
  # @option opts [Array(Int32)] :rear_port_id__n
  # @option opts [Array(Int32)] :rear_port_position
  # @option opts [Bool] :rear_port_position__empty
  # @option opts [Array(Int32)] :rear_port_position__gt
  # @option opts [Array(Int32)] :rear_port_position__gte
  # @option opts [Array(Int32)] :rear_port_position__lt
  # @option opts [Array(Int32)] :rear_port_position__lte
  # @option opts [Array(Int32)] :rear_port_position__n
  # @option opts [Array(String)] :_type
  # @option opts [Bool] :type__empty
  # @option opts [Array(String)] :type__ic
  # @option opts [Array(String)] :type__ie
  # @option opts [Array(String)] :type__iew
  # @option opts [Array(String)] :type__iregex
  # @option opts [Array(String)] :type__isw
  # @option opts [Array(String)] :type__n
  # @option opts [Array(String)] :type__nic
  # @option opts [Array(String)] :type__nie
  # @option opts [Array(String)] :type__niew
  # @option opts [Array(String)] :type__nisw
  # @option opts [Array(String)] :type__regex
  # @option opts [String] :updated_by_request
  # @return [PaginatedFrontPortTemplateList]
  describe "dcim_front_port_templates_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_front_port_templates_partial_update
  # Patch a front port template object.
  # @param id A unique integer value identifying this front port template.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableFrontPortTemplateRequest] :patched_writable_front_port_template_request
  # @return [FrontPortTemplate]
  describe "dcim_front_port_templates_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_front_port_templates_retrieve
  # Get a front port template object.
  # @param id A unique integer value identifying this front port template.
  # @param [Hash] opts the optional parameters
  # @return [FrontPortTemplate]
  describe "dcim_front_port_templates_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_front_port_templates_update
  # Put a front port template object.
  # @param id A unique integer value identifying this front port template.
  # @param writable_front_port_template_request
  # @param [Hash] opts the optional parameters
  # @return [FrontPortTemplate]
  describe "dcim_front_port_templates_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_front_ports_bulk_destroy
  # Delete a list of front port objects.
  # @param front_port_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_front_ports_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_front_ports_bulk_partial_update
  # Patch a list of front port objects.
  # @param front_port_request
  # @param [Hash] opts the optional parameters
  # @return [Array(FrontPort)]
  describe "dcim_front_ports_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_front_ports_bulk_update
  # Put a list of front port objects.
  # @param front_port_request
  # @param [Hash] opts the optional parameters
  # @return [Array(FrontPort)]
  describe "dcim_front_ports_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_front_ports_create
  # Post a list of front port objects.
  # @param dcim_front_ports_create_request
  # @param [Hash] opts the optional parameters
  # @return [FrontPort]
  describe "dcim_front_ports_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_front_ports_destroy
  # Delete a front port object.
  # @param id A unique integer value identifying this front port.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_front_ports_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_front_ports_list
  # Get a list of front port objects.
  # @param [Hash] opts the optional parameters
  # @option opts [String] :cable_end * &#x60;A&#x60; - A * &#x60;B&#x60; - B
  # @option opts [Array(Int32)] :cable_id Cable (ID)
  # @option opts [Array(Int32)] :cable_id__n Cable (ID)
  # @option opts [Bool] :cabled
  # @option opts [Array(String)] :color
  # @option opts [Bool] :color__empty
  # @option opts [Array(String)] :color__ic
  # @option opts [Array(String)] :color__ie
  # @option opts [Array(String)] :color__iew
  # @option opts [Array(String)] :color__iregex
  # @option opts [Array(String)] :color__isw
  # @option opts [Array(String)] :color__n
  # @option opts [Array(String)] :color__nic
  # @option opts [Array(String)] :color__nie
  # @option opts [Array(String)] :color__niew
  # @option opts [Array(String)] :color__nisw
  # @option opts [Array(String)] :color__regex
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(String)] :device Device (name)
  # @option opts [Array(String)] :device__n Device (name)
  # @option opts [Array(Int32)] :device_id Device (ID)
  # @option opts [Array(Int32)] :device_id__n Device (ID)
  # @option opts [Array(String)] :device_role Device role (slug)
  # @option opts [Array(String)] :device_role__n Device role (slug)
  # @option opts [Array(Int32)] :device_role_id Device role (ID)
  # @option opts [Array(Int32)] :device_role_id__n Device role (ID)
  # @option opts [Array(String)] :device_status
  # @option opts [Bool] :device_status__empty
  # @option opts [Array(String)] :device_status__ic
  # @option opts [Array(String)] :device_status__ie
  # @option opts [Array(String)] :device_status__iew
  # @option opts [Array(String)] :device_status__iregex
  # @option opts [Array(String)] :device_status__isw
  # @option opts [Array(String)] :device_status__n
  # @option opts [Array(String)] :device_status__nic
  # @option opts [Array(String)] :device_status__nie
  # @option opts [Array(String)] :device_status__niew
  # @option opts [Array(String)] :device_status__nisw
  # @option opts [Array(String)] :device_status__regex
  # @option opts [Array(String)] :device_type Device type (model)
  # @option opts [Array(String)] :device_type__n Device type (model)
  # @option opts [Array(Int32)] :device_type_id Device type (ID)
  # @option opts [Array(Int32)] :device_type_id__n Device type (ID)
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :label
  # @option opts [Bool] :label__empty
  # @option opts [Array(String)] :label__ic
  # @option opts [Array(String)] :label__ie
  # @option opts [Array(String)] :label__iew
  # @option opts [Array(String)] :label__iregex
  # @option opts [Array(String)] :label__isw
  # @option opts [Array(String)] :label__n
  # @option opts [Array(String)] :label__nic
  # @option opts [Array(String)] :label__nie
  # @option opts [Array(String)] :label__niew
  # @option opts [Array(String)] :label__nisw
  # @option opts [Array(String)] :label__regex
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(String)] :location Location (slug)
  # @option opts [Array(String)] :location__n Location (slug)
  # @option opts [Array(Int32)] :location_id Location (ID)
  # @option opts [Array(Int32)] :location_id__n Location (ID)
  # @option opts [Bool] :mark_connected
  # @option opts [String] :modified_by_request
  # @option opts [Array(Int32)] :module_id Module (ID)
  # @option opts [Array(Int32)] :module_id__n Module (ID)
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Bool] :occupied
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [Array(String)] :rack Rack (name)
  # @option opts [Array(String)] :rack__n Rack (name)
  # @option opts [Array(Int32)] :rack_id Rack (ID)
  # @option opts [Array(Int32)] :rack_id__n Rack (ID)
  # @option opts [Array(Int32)] :rear_port_id
  # @option opts [Array(Int32)] :rear_port_id__n
  # @option opts [Array(Int32)] :rear_port_position
  # @option opts [Bool] :rear_port_position__empty
  # @option opts [Array(Int32)] :rear_port_position__gt
  # @option opts [Array(Int32)] :rear_port_position__gte
  # @option opts [Array(Int32)] :rear_port_position__lt
  # @option opts [Array(Int32)] :rear_port_position__lte
  # @option opts [Array(Int32)] :rear_port_position__n
  # @option opts [Array(String)] :region
  # @option opts [Array(String)] :region__n
  # @option opts [Array(String)] :region_id
  # @option opts [Array(String)] :region_id__n
  # @option opts [Array(String)] :site Site name (slug)
  # @option opts [Array(String)] :site__n Site name (slug)
  # @option opts [Array(String)] :site_group
  # @option opts [Array(String)] :site_group__n
  # @option opts [Array(String)] :site_group_id
  # @option opts [Array(String)] :site_group_id__n
  # @option opts [Array(Int32)] :site_id Site (ID)
  # @option opts [Array(Int32)] :site_id__n Site (ID)
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [Array(String)] :tenant Tenant (slug)
  # @option opts [Array(String)] :tenant__n Tenant (slug)
  # @option opts [Array(Int32)] :tenant_id Tenant (ID)
  # @option opts [Array(Int32)] :tenant_id__n Tenant (ID)
  # @option opts [Array(String)] :_type
  # @option opts [Bool] :type__empty
  # @option opts [Array(String)] :type__ic
  # @option opts [Array(String)] :type__ie
  # @option opts [Array(String)] :type__iew
  # @option opts [Array(String)] :type__iregex
  # @option opts [Array(String)] :type__isw
  # @option opts [Array(String)] :type__n
  # @option opts [Array(String)] :type__nic
  # @option opts [Array(String)] :type__nie
  # @option opts [Array(String)] :type__niew
  # @option opts [Array(String)] :type__nisw
  # @option opts [Array(String)] :type__regex
  # @option opts [String] :updated_by_request
  # @option opts [Array(String)] :virtual_chassis Virtual Chassis
  # @option opts [Array(String)] :virtual_chassis__n Virtual Chassis
  # @option opts [Array(Int32)] :virtual_chassis_id Virtual Chassis (ID)
  # @option opts [Array(Int32)] :virtual_chassis_id__n Virtual Chassis (ID)
  # @return [PaginatedFrontPortList]
  describe "dcim_front_ports_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_front_ports_partial_update
  # Patch a front port object.
  # @param id A unique integer value identifying this front port.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableFrontPortRequest] :patched_writable_front_port_request
  # @return [FrontPort]
  describe "dcim_front_ports_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_front_ports_paths_retrieve
  # Return all CablePaths which traverse a given pass-through port.
  # @param id A unique integer value identifying this front port.
  # @param [Hash] opts the optional parameters
  # @return [FrontPort]
  describe "dcim_front_ports_paths_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_front_ports_retrieve
  # Get a front port object.
  # @param id A unique integer value identifying this front port.
  # @param [Hash] opts the optional parameters
  # @return [FrontPort]
  describe "dcim_front_ports_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_front_ports_update
  # Put a front port object.
  # @param id A unique integer value identifying this front port.
  # @param writable_front_port_request
  # @param [Hash] opts the optional parameters
  # @return [FrontPort]
  describe "dcim_front_ports_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_interface_templates_bulk_destroy
  # Delete a list of interface template objects.
  # @param interface_template_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_interface_templates_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_interface_templates_bulk_partial_update
  # Patch a list of interface template objects.
  # @param interface_template_request
  # @param [Hash] opts the optional parameters
  # @return [Array(InterfaceTemplate)]
  describe "dcim_interface_templates_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_interface_templates_bulk_update
  # Put a list of interface template objects.
  # @param interface_template_request
  # @param [Hash] opts the optional parameters
  # @return [Array(InterfaceTemplate)]
  describe "dcim_interface_templates_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_interface_templates_create
  # Post a list of interface template objects.
  # @param dcim_interface_templates_create_request
  # @param [Hash] opts the optional parameters
  # @return [InterfaceTemplate]
  describe "dcim_interface_templates_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_interface_templates_destroy
  # Delete a interface template object.
  # @param id A unique integer value identifying this interface template.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_interface_templates_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_interface_templates_list
  # Get a list of interface template objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Int32)] :bridge_id
  # @option opts [Array(Int32)] :bridge_id__n
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :device_type_id Device type (ID)
  # @option opts [Array(Int32)] :device_type_id__n Device type (ID)
  # @option opts [Bool] :enabled
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :label
  # @option opts [Bool] :label__empty
  # @option opts [Array(String)] :label__ic
  # @option opts [Array(String)] :label__ie
  # @option opts [Array(String)] :label__iew
  # @option opts [Array(String)] :label__iregex
  # @option opts [Array(String)] :label__isw
  # @option opts [Array(String)] :label__n
  # @option opts [Array(String)] :label__nic
  # @option opts [Array(String)] :label__nie
  # @option opts [Array(String)] :label__niew
  # @option opts [Array(String)] :label__nisw
  # @option opts [Array(String)] :label__regex
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Bool] :mgmt_only
  # @option opts [String] :modified_by_request
  # @option opts [Array(Int32)] :module_type_id Module type (ID)
  # @option opts [Array(Int32)] :module_type_id__n Module type (ID)
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Array(String)] :poe_mode
  # @option opts [Bool] :poe_mode__empty
  # @option opts [Array(String)] :poe_mode__ic
  # @option opts [Array(String)] :poe_mode__ie
  # @option opts [Array(String)] :poe_mode__iew
  # @option opts [Array(String)] :poe_mode__iregex
  # @option opts [Array(String)] :poe_mode__isw
  # @option opts [Array(String)] :poe_mode__n
  # @option opts [Array(String)] :poe_mode__nic
  # @option opts [Array(String)] :poe_mode__nie
  # @option opts [Array(String)] :poe_mode__niew
  # @option opts [Array(String)] :poe_mode__nisw
  # @option opts [Array(String)] :poe_mode__regex
  # @option opts [Array(String)] :poe_type
  # @option opts [Bool] :poe_type__empty
  # @option opts [Array(String)] :poe_type__ic
  # @option opts [Array(String)] :poe_type__ie
  # @option opts [Array(String)] :poe_type__iew
  # @option opts [Array(String)] :poe_type__iregex
  # @option opts [Array(String)] :poe_type__isw
  # @option opts [Array(String)] :poe_type__n
  # @option opts [Array(String)] :poe_type__nic
  # @option opts [Array(String)] :poe_type__nie
  # @option opts [Array(String)] :poe_type__niew
  # @option opts [Array(String)] :poe_type__nisw
  # @option opts [Array(String)] :poe_type__regex
  # @option opts [String] :q Search
  # @option opts [Array(String)] :rf_role
  # @option opts [Bool] :rf_role__empty
  # @option opts [Array(String)] :rf_role__ic
  # @option opts [Array(String)] :rf_role__ie
  # @option opts [Array(String)] :rf_role__iew
  # @option opts [Array(String)] :rf_role__iregex
  # @option opts [Array(String)] :rf_role__isw
  # @option opts [Array(String)] :rf_role__n
  # @option opts [Array(String)] :rf_role__nic
  # @option opts [Array(String)] :rf_role__nie
  # @option opts [Array(String)] :rf_role__niew
  # @option opts [Array(String)] :rf_role__nisw
  # @option opts [Array(String)] :rf_role__regex
  # @option opts [Array(String)] :_type
  # @option opts [Bool] :type__empty
  # @option opts [Array(String)] :type__ic
  # @option opts [Array(String)] :type__ie
  # @option opts [Array(String)] :type__iew
  # @option opts [Array(String)] :type__iregex
  # @option opts [Array(String)] :type__isw
  # @option opts [Array(String)] :type__n
  # @option opts [Array(String)] :type__nic
  # @option opts [Array(String)] :type__nie
  # @option opts [Array(String)] :type__niew
  # @option opts [Array(String)] :type__nisw
  # @option opts [Array(String)] :type__regex
  # @option opts [String] :updated_by_request
  # @return [PaginatedInterfaceTemplateList]
  describe "dcim_interface_templates_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_interface_templates_partial_update
  # Patch a interface template object.
  # @param id A unique integer value identifying this interface template.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableInterfaceTemplateRequest] :patched_writable_interface_template_request
  # @return [InterfaceTemplate]
  describe "dcim_interface_templates_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_interface_templates_retrieve
  # Get a interface template object.
  # @param id A unique integer value identifying this interface template.
  # @param [Hash] opts the optional parameters
  # @return [InterfaceTemplate]
  describe "dcim_interface_templates_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_interface_templates_update
  # Put a interface template object.
  # @param id A unique integer value identifying this interface template.
  # @param writable_interface_template_request
  # @param [Hash] opts the optional parameters
  # @return [InterfaceTemplate]
  describe "dcim_interface_templates_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_interfaces_bulk_destroy
  # Delete a list of interface objects.
  # @param interface_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_interfaces_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_interfaces_bulk_partial_update
  # Patch a list of interface objects.
  # @param interface_request
  # @param [Hash] opts the optional parameters
  # @return [Array(Interface)]
  describe "dcim_interfaces_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_interfaces_bulk_update
  # Put a list of interface objects.
  # @param interface_request
  # @param [Hash] opts the optional parameters
  # @return [Array(Interface)]
  describe "dcim_interfaces_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_interfaces_create
  # Post a list of interface objects.
  # @param dcim_interfaces_create_request
  # @param [Hash] opts the optional parameters
  # @return [Interface]
  describe "dcim_interfaces_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_interfaces_destroy
  # Delete a interface object.
  # @param id A unique integer value identifying this interface.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_interfaces_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_interfaces_list
  # Get a list of interface objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Int32)] :bridge_id Bridged interface (ID)
  # @option opts [Array(Int32)] :bridge_id__n Bridged interface (ID)
  # @option opts [String] :cable_end * &#x60;A&#x60; - A * &#x60;B&#x60; - B
  # @option opts [Array(Int32)] :cable_id Cable (ID)
  # @option opts [Array(Int32)] :cable_id__n Cable (ID)
  # @option opts [Bool] :cabled
  # @option opts [Bool] :connected
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(String)] :device Device (name)
  # @option opts [Array(String)] :device__n Device (name)
  # @option opts [Array(Int32)] :device_id Device (ID)
  # @option opts [Array(Int32)] :device_id__n Device (ID)
  # @option opts [Array(String)] :device_role Device role (slug)
  # @option opts [Array(String)] :device_role__n Device role (slug)
  # @option opts [Array(Int32)] :device_role_id Device role (ID)
  # @option opts [Array(Int32)] :device_role_id__n Device role (ID)
  # @option opts [Array(String)] :device_status
  # @option opts [Bool] :device_status__empty
  # @option opts [Array(String)] :device_status__ic
  # @option opts [Array(String)] :device_status__ie
  # @option opts [Array(String)] :device_status__iew
  # @option opts [Array(String)] :device_status__iregex
  # @option opts [Array(String)] :device_status__isw
  # @option opts [Array(String)] :device_status__n
  # @option opts [Array(String)] :device_status__nic
  # @option opts [Array(String)] :device_status__nie
  # @option opts [Array(String)] :device_status__niew
  # @option opts [Array(String)] :device_status__nisw
  # @option opts [Array(String)] :device_status__regex
  # @option opts [Array(String)] :device_type Device type (model)
  # @option opts [Array(String)] :device_type__n Device type (model)
  # @option opts [Array(Int32)] :device_type_id Device type (ID)
  # @option opts [Array(Int32)] :device_type_id__n Device type (ID)
  # @option opts [Array(String)] :duplex
  # @option opts [Bool] :duplex__empty
  # @option opts [Array(String)] :duplex__ic
  # @option opts [Array(String)] :duplex__ie
  # @option opts [Array(String)] :duplex__iew
  # @option opts [Array(String)] :duplex__iregex
  # @option opts [Array(String)] :duplex__isw
  # @option opts [Array(String)] :duplex__n
  # @option opts [Array(String)] :duplex__nic
  # @option opts [Array(String)] :duplex__nie
  # @option opts [Array(String)] :duplex__niew
  # @option opts [Array(String)] :duplex__nisw
  # @option opts [Array(String)] :duplex__regex
  # @option opts [Bool] :enabled
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [String] :kind Kind of interface
  # @option opts [Array(String)] :l2vpn L2VPN
  # @option opts [Array(String)] :l2vpn__n L2VPN
  # @option opts [Array(Int32)] :l2vpn_id L2VPN (ID)
  # @option opts [Array(Int32)] :l2vpn_id__n L2VPN (ID)
  # @option opts [Array(String)] :label
  # @option opts [Bool] :label__empty
  # @option opts [Array(String)] :label__ic
  # @option opts [Array(String)] :label__ie
  # @option opts [Array(String)] :label__iew
  # @option opts [Array(String)] :label__iregex
  # @option opts [Array(String)] :label__isw
  # @option opts [Array(String)] :label__n
  # @option opts [Array(String)] :label__nic
  # @option opts [Array(String)] :label__nie
  # @option opts [Array(String)] :label__niew
  # @option opts [Array(String)] :label__nisw
  # @option opts [Array(String)] :label__regex
  # @option opts [Array(Int32)] :lag_id LAG interface (ID)
  # @option opts [Array(Int32)] :lag_id__n LAG interface (ID)
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(String)] :location Location (slug)
  # @option opts [Array(String)] :location__n Location (slug)
  # @option opts [Array(Int32)] :location_id Location (ID)
  # @option opts [Array(Int32)] :location_id__n Location (ID)
  # @option opts [Array(String)] :mac_address
  # @option opts [Array(String)] :mac_address__ic
  # @option opts [Array(String)] :mac_address__ie
  # @option opts [Array(String)] :mac_address__iew
  # @option opts [Array(String)] :mac_address__iregex
  # @option opts [Array(String)] :mac_address__isw
  # @option opts [Array(String)] :mac_address__n
  # @option opts [Array(String)] :mac_address__nic
  # @option opts [Array(String)] :mac_address__nie
  # @option opts [Array(String)] :mac_address__niew
  # @option opts [Array(String)] :mac_address__nisw
  # @option opts [Array(String)] :mac_address__regex
  # @option opts [Bool] :mark_connected
  # @option opts [Bool] :mgmt_only
  # @option opts [Array(String)] :mode 802.1Q Mode
  # @option opts [Bool] :mode__empty 802.1Q Mode
  # @option opts [Array(String)] :mode__ic 802.1Q Mode
  # @option opts [Array(String)] :mode__ie 802.1Q Mode
  # @option opts [Array(String)] :mode__iew 802.1Q Mode
  # @option opts [Array(String)] :mode__iregex 802.1Q Mode
  # @option opts [Array(String)] :mode__isw 802.1Q Mode
  # @option opts [Array(String)] :mode__n 802.1Q Mode
  # @option opts [Array(String)] :mode__nic 802.1Q Mode
  # @option opts [Array(String)] :mode__nie 802.1Q Mode
  # @option opts [Array(String)] :mode__niew 802.1Q Mode
  # @option opts [Array(String)] :mode__nisw 802.1Q Mode
  # @option opts [Array(String)] :mode__regex 802.1Q Mode
  # @option opts [String] :modified_by_request
  # @option opts [Array(Int32)] :module_id Module (ID)
  # @option opts [Array(Int32)] :module_id__n Module (ID)
  # @option opts [Array(Int32)] :mtu
  # @option opts [Bool] :mtu__empty
  # @option opts [Array(Int32)] :mtu__gt
  # @option opts [Array(Int32)] :mtu__gte
  # @option opts [Array(Int32)] :mtu__lt
  # @option opts [Array(Int32)] :mtu__lte
  # @option opts [Array(Int32)] :mtu__n
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Bool] :occupied
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Array(Int32)] :parent_id Parent interface (ID)
  # @option opts [Array(Int32)] :parent_id__n Parent interface (ID)
  # @option opts [Array(String)] :poe_mode
  # @option opts [Bool] :poe_mode__empty
  # @option opts [Array(String)] :poe_mode__ic
  # @option opts [Array(String)] :poe_mode__ie
  # @option opts [Array(String)] :poe_mode__iew
  # @option opts [Array(String)] :poe_mode__iregex
  # @option opts [Array(String)] :poe_mode__isw
  # @option opts [Array(String)] :poe_mode__n
  # @option opts [Array(String)] :poe_mode__nic
  # @option opts [Array(String)] :poe_mode__nie
  # @option opts [Array(String)] :poe_mode__niew
  # @option opts [Array(String)] :poe_mode__nisw
  # @option opts [Array(String)] :poe_mode__regex
  # @option opts [Array(String)] :poe_type
  # @option opts [Bool] :poe_type__empty
  # @option opts [Array(String)] :poe_type__ic
  # @option opts [Array(String)] :poe_type__ie
  # @option opts [Array(String)] :poe_type__iew
  # @option opts [Array(String)] :poe_type__iregex
  # @option opts [Array(String)] :poe_type__isw
  # @option opts [Array(String)] :poe_type__n
  # @option opts [Array(String)] :poe_type__nic
  # @option opts [Array(String)] :poe_type__nie
  # @option opts [Array(String)] :poe_type__niew
  # @option opts [Array(String)] :poe_type__nisw
  # @option opts [Array(String)] :poe_type__regex
  # @option opts [Array(String)] :primary_mac_address Primary MAC address
  # @option opts [Array(String)] :primary_mac_address__n Primary MAC address
  # @option opts [Array(Int32)] :primary_mac_address_id Primary MAC address (ID)
  # @option opts [Array(Int32)] :primary_mac_address_id__n Primary MAC address (ID)
  # @option opts [String] :q Search
  # @option opts [Array(String)] :rack Rack (name)
  # @option opts [Array(String)] :rack__n Rack (name)
  # @option opts [Array(Int32)] :rack_id Rack (ID)
  # @option opts [Array(Int32)] :rack_id__n Rack (ID)
  # @option opts [Array(String)] :region
  # @option opts [Array(String)] :region__n
  # @option opts [Array(String)] :region_id
  # @option opts [Array(String)] :region_id__n
  # @option opts [Array(String)] :rf_channel
  # @option opts [Bool] :rf_channel__empty
  # @option opts [Array(String)] :rf_channel__ic
  # @option opts [Array(String)] :rf_channel__ie
  # @option opts [Array(String)] :rf_channel__iew
  # @option opts [Array(String)] :rf_channel__iregex
  # @option opts [Array(String)] :rf_channel__isw
  # @option opts [Array(String)] :rf_channel__n
  # @option opts [Array(String)] :rf_channel__nic
  # @option opts [Array(String)] :rf_channel__nie
  # @option opts [Array(String)] :rf_channel__niew
  # @option opts [Array(String)] :rf_channel__nisw
  # @option opts [Array(String)] :rf_channel__regex
  # @option opts [Array(Float64)] :rf_channel_frequency
  # @option opts [Bool] :rf_channel_frequency__empty
  # @option opts [Array(Float64)] :rf_channel_frequency__gt
  # @option opts [Array(Float64)] :rf_channel_frequency__gte
  # @option opts [Array(Float64)] :rf_channel_frequency__lt
  # @option opts [Array(Float64)] :rf_channel_frequency__lte
  # @option opts [Array(Float64)] :rf_channel_frequency__n
  # @option opts [Array(Float64)] :rf_channel_width
  # @option opts [Bool] :rf_channel_width__empty
  # @option opts [Array(Float64)] :rf_channel_width__gt
  # @option opts [Array(Float64)] :rf_channel_width__gte
  # @option opts [Array(Float64)] :rf_channel_width__lt
  # @option opts [Array(Float64)] :rf_channel_width__lte
  # @option opts [Array(Float64)] :rf_channel_width__n
  # @option opts [Array(String)] :rf_role
  # @option opts [Bool] :rf_role__empty
  # @option opts [Array(String)] :rf_role__ic
  # @option opts [Array(String)] :rf_role__ie
  # @option opts [Array(String)] :rf_role__iew
  # @option opts [Array(String)] :rf_role__iregex
  # @option opts [Array(String)] :rf_role__isw
  # @option opts [Array(String)] :rf_role__n
  # @option opts [Array(String)] :rf_role__nic
  # @option opts [Array(String)] :rf_role__nie
  # @option opts [Array(String)] :rf_role__niew
  # @option opts [Array(String)] :rf_role__nisw
  # @option opts [Array(String)] :rf_role__regex
  # @option opts [Array(String)] :site Site name (slug)
  # @option opts [Array(String)] :site__n Site name (slug)
  # @option opts [Array(String)] :site_group
  # @option opts [Array(String)] :site_group__n
  # @option opts [Array(String)] :site_group_id
  # @option opts [Array(String)] :site_group_id__n
  # @option opts [Array(Int32)] :site_id Site (ID)
  # @option opts [Array(Int32)] :site_id__n Site (ID)
  # @option opts [Array(Int32)] :speed
  # @option opts [Array(Int32)] :speed__empty
  # @option opts [Array(Int32)] :speed__gt
  # @option opts [Array(Int32)] :speed__gte
  # @option opts [Array(Int32)] :speed__lt
  # @option opts [Array(Int32)] :speed__lte
  # @option opts [Array(Int32)] :speed__n
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [Array(String)] :tenant Tenant (slug)
  # @option opts [Array(String)] :tenant__n Tenant (slug)
  # @option opts [Array(Int32)] :tenant_id Tenant (ID)
  # @option opts [Array(Int32)] :tenant_id__n Tenant (ID)
  # @option opts [Array(Int32)] :tx_power
  # @option opts [Bool] :tx_power__empty
  # @option opts [Array(Int32)] :tx_power__gt
  # @option opts [Array(Int32)] :tx_power__gte
  # @option opts [Array(Int32)] :tx_power__lt
  # @option opts [Array(Int32)] :tx_power__lte
  # @option opts [Array(Int32)] :tx_power__n
  # @option opts [Array(String)] :_type
  # @option opts [Bool] :type__empty
  # @option opts [Array(String)] :type__ic
  # @option opts [Array(String)] :type__ie
  # @option opts [Array(String)] :type__iew
  # @option opts [Array(String)] :type__iregex
  # @option opts [Array(String)] :type__isw
  # @option opts [Array(String)] :type__n
  # @option opts [Array(String)] :type__nic
  # @option opts [Array(String)] :type__nie
  # @option opts [Array(String)] :type__niew
  # @option opts [Array(String)] :type__nisw
  # @option opts [Array(String)] :type__regex
  # @option opts [String] :updated_by_request
  # @option opts [Array(String)] :vdc Virtual Device Context
  # @option opts [Array(String)] :vdc__n Virtual Device Context
  # @option opts [Array(Int32)] :vdc_id Virtual Device Context
  # @option opts [Array(Int32)] :vdc_id__n Virtual Device Context
  # @option opts [Array(String)] :vdc_identifier Virtual Device Context (Identifier)
  # @option opts [Array(String)] :vdc_identifier__n Virtual Device Context (Identifier)
  # @option opts [Array(String)] :virtual_chassis Virtual Chassis
  # @option opts [Array(String)] :virtual_chassis__n Virtual Chassis
  # @option opts [Array(Int32)] :virtual_chassis_id Virtual Chassis (ID)
  # @option opts [Array(Int32)] :virtual_chassis_id__n Virtual Chassis (ID)
  # @option opts [Array(String)] :virtual_chassis_member
  # @option opts [Array(Int32)] :virtual_chassis_member_id
  # @option opts [Array(String)] :virtual_chassis_member_or_master
  # @option opts [Array(Int32)] :virtual_chassis_member_or_master_id
  # @option opts [Array(Int32)] :virtual_circuit_id Virtual circuit (ID)
  # @option opts [Array(Int32)] :virtual_circuit_id__n Virtual circuit (ID)
  # @option opts [Array(Int32)] :virtual_circuit_termination_id Virtual circuit termination (ID)
  # @option opts [Array(Int32)] :virtual_circuit_termination_id__n Virtual circuit termination (ID)
  # @option opts [String] :vlan Assigned VID
  # @option opts [String] :vlan_id Assigned VLAN
  # @option opts [Array(String)] :vlan_translation_policy VLAN Translation Policy
  # @option opts [Array(String)] :vlan_translation_policy__n VLAN Translation Policy
  # @option opts [Array(Int32)] :vlan_translation_policy_id VLAN Translation Policy (ID)
  # @option opts [Array(Int32)] :vlan_translation_policy_id__n VLAN Translation Policy (ID)
  # @option opts [Array(String)] :vrf VRF (RD)
  # @option opts [Array(String)] :vrf__n VRF (RD)
  # @option opts [Array(Int32)] :vrf_id VRF
  # @option opts [Array(Int32)] :vrf_id__n VRF
  # @option opts [Array(Int32)] :wireless_lan_id Wireless LAN
  # @option opts [Array(Int32)] :wireless_lan_id__n Wireless LAN
  # @option opts [Array(Int32)] :wireless_link_id Wireless link
  # @option opts [Array(Int32)] :wireless_link_id__n Wireless link
  # @option opts [Array(String)] :wwn
  # @option opts [Array(String)] :wwn__ic
  # @option opts [Array(String)] :wwn__ie
  # @option opts [Array(String)] :wwn__iew
  # @option opts [Array(String)] :wwn__iregex
  # @option opts [Array(String)] :wwn__isw
  # @option opts [Array(String)] :wwn__n
  # @option opts [Array(String)] :wwn__nic
  # @option opts [Array(String)] :wwn__nie
  # @option opts [Array(String)] :wwn__niew
  # @option opts [Array(String)] :wwn__nisw
  # @option opts [Array(String)] :wwn__regex
  # @return [PaginatedInterfaceList]
  describe "dcim_interfaces_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_interfaces_partial_update
  # Patch a interface object.
  # @param id A unique integer value identifying this interface.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableInterfaceRequest] :patched_writable_interface_request
  # @return [Interface]
  describe "dcim_interfaces_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_interfaces_retrieve
  # Get a interface object.
  # @param id A unique integer value identifying this interface.
  # @param [Hash] opts the optional parameters
  # @return [Interface]
  describe "dcim_interfaces_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_interfaces_trace_retrieve
  # Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
  # @param id A unique integer value identifying this interface.
  # @param [Hash] opts the optional parameters
  # @return [Interface]
  describe "dcim_interfaces_trace_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_interfaces_update
  # Put a interface object.
  # @param id A unique integer value identifying this interface.
  # @param writable_interface_request
  # @param [Hash] opts the optional parameters
  # @return [Interface]
  describe "dcim_interfaces_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_item_roles_bulk_destroy
  # Delete a list of inventory item role objects.
  # @param inventory_item_role_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_inventory_item_roles_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_item_roles_bulk_partial_update
  # Patch a list of inventory item role objects.
  # @param inventory_item_role_request
  # @param [Hash] opts the optional parameters
  # @return [Array(InventoryItemRole)]
  describe "dcim_inventory_item_roles_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_item_roles_bulk_update
  # Put a list of inventory item role objects.
  # @param inventory_item_role_request
  # @param [Hash] opts the optional parameters
  # @return [Array(InventoryItemRole)]
  describe "dcim_inventory_item_roles_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_item_roles_create
  # Post a list of inventory item role objects.
  # @param dcim_inventory_item_roles_create_request
  # @param [Hash] opts the optional parameters
  # @return [InventoryItemRole]
  describe "dcim_inventory_item_roles_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_item_roles_destroy
  # Delete a inventory item role object.
  # @param id A unique integer value identifying this inventory item role.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_inventory_item_roles_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_item_roles_list
  # Get a list of inventory item role objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(String)] :color
  # @option opts [Bool] :color__empty
  # @option opts [Array(String)] :color__ic
  # @option opts [Array(String)] :color__ie
  # @option opts [Array(String)] :color__iew
  # @option opts [Array(String)] :color__iregex
  # @option opts [Array(String)] :color__isw
  # @option opts [Array(String)] :color__n
  # @option opts [Array(String)] :color__nic
  # @option opts [Array(String)] :color__nie
  # @option opts [Array(String)] :color__niew
  # @option opts [Array(String)] :color__nisw
  # @option opts [Array(String)] :color__regex
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [Array(String)] :slug
  # @option opts [Bool] :slug__empty
  # @option opts [Array(String)] :slug__ic
  # @option opts [Array(String)] :slug__ie
  # @option opts [Array(String)] :slug__iew
  # @option opts [Array(String)] :slug__iregex
  # @option opts [Array(String)] :slug__isw
  # @option opts [Array(String)] :slug__n
  # @option opts [Array(String)] :slug__nic
  # @option opts [Array(String)] :slug__nie
  # @option opts [Array(String)] :slug__niew
  # @option opts [Array(String)] :slug__nisw
  # @option opts [Array(String)] :slug__regex
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [String] :updated_by_request
  # @return [PaginatedInventoryItemRoleList]
  describe "dcim_inventory_item_roles_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_item_roles_partial_update
  # Patch a inventory item role object.
  # @param id A unique integer value identifying this inventory item role.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedInventoryItemRoleRequest] :patched_inventory_item_role_request
  # @return [InventoryItemRole]
  describe "dcim_inventory_item_roles_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_item_roles_retrieve
  # Get a inventory item role object.
  # @param id A unique integer value identifying this inventory item role.
  # @param [Hash] opts the optional parameters
  # @return [InventoryItemRole]
  describe "dcim_inventory_item_roles_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_item_roles_update
  # Put a inventory item role object.
  # @param id A unique integer value identifying this inventory item role.
  # @param inventory_item_role_request
  # @param [Hash] opts the optional parameters
  # @return [InventoryItemRole]
  describe "dcim_inventory_item_roles_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_item_templates_bulk_destroy
  # Delete a list of inventory item template objects.
  # @param inventory_item_template_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_inventory_item_templates_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_item_templates_bulk_partial_update
  # Patch a list of inventory item template objects.
  # @param inventory_item_template_request
  # @param [Hash] opts the optional parameters
  # @return [Array(InventoryItemTemplate)]
  describe "dcim_inventory_item_templates_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_item_templates_bulk_update
  # Put a list of inventory item template objects.
  # @param inventory_item_template_request
  # @param [Hash] opts the optional parameters
  # @return [Array(InventoryItemTemplate)]
  describe "dcim_inventory_item_templates_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_item_templates_create
  # Post a list of inventory item template objects.
  # @param dcim_inventory_item_templates_create_request
  # @param [Hash] opts the optional parameters
  # @return [InventoryItemTemplate]
  describe "dcim_inventory_item_templates_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_item_templates_destroy
  # Delete a inventory item template object.
  # @param id A unique integer value identifying this inventory item template.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_inventory_item_templates_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_item_templates_list
  # Get a list of inventory item template objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Int32)] :component_id
  # @option opts [Array(Int32)] :component_id__empty
  # @option opts [Array(Int32)] :component_id__gt
  # @option opts [Array(Int32)] :component_id__gte
  # @option opts [Array(Int32)] :component_id__lt
  # @option opts [Array(Int32)] :component_id__lte
  # @option opts [Array(Int32)] :component_id__n
  # @option opts [String] :component_type
  # @option opts [String] :component_type__n
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :device_type_id Device type (ID)
  # @option opts [Array(Int32)] :device_type_id__n Device type (ID)
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :label
  # @option opts [Bool] :label__empty
  # @option opts [Array(String)] :label__ic
  # @option opts [Array(String)] :label__ie
  # @option opts [Array(String)] :label__iew
  # @option opts [Array(String)] :label__iregex
  # @option opts [Array(String)] :label__isw
  # @option opts [Array(String)] :label__n
  # @option opts [Array(String)] :label__nic
  # @option opts [Array(String)] :label__nie
  # @option opts [Array(String)] :label__niew
  # @option opts [Array(String)] :label__nisw
  # @option opts [Array(String)] :label__regex
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(String)] :manufacturer Manufacturer (slug)
  # @option opts [Array(String)] :manufacturer__n Manufacturer (slug)
  # @option opts [Array(Int32)] :manufacturer_id Manufacturer (ID)
  # @option opts [Array(Int32)] :manufacturer_id__n Manufacturer (ID)
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Array(Int32)] :parent_id Parent inventory item (ID)
  # @option opts [Array(Int32)] :parent_id__n Parent inventory item (ID)
  # @option opts [Array(String)] :part_id
  # @option opts [Bool] :part_id__empty
  # @option opts [Array(String)] :part_id__ic
  # @option opts [Array(String)] :part_id__ie
  # @option opts [Array(String)] :part_id__iew
  # @option opts [Array(String)] :part_id__iregex
  # @option opts [Array(String)] :part_id__isw
  # @option opts [Array(String)] :part_id__n
  # @option opts [Array(String)] :part_id__nic
  # @option opts [Array(String)] :part_id__nie
  # @option opts [Array(String)] :part_id__niew
  # @option opts [Array(String)] :part_id__nisw
  # @option opts [Array(String)] :part_id__regex
  # @option opts [String] :q Search
  # @option opts [Array(String)] :role Role (slug)
  # @option opts [Array(String)] :role__n Role (slug)
  # @option opts [Array(Int32)] :role_id Role (ID)
  # @option opts [Array(Int32)] :role_id__n Role (ID)
  # @option opts [String] :updated_by_request
  # @return [PaginatedInventoryItemTemplateList]
  describe "dcim_inventory_item_templates_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_item_templates_partial_update
  # Patch a inventory item template object.
  # @param id A unique integer value identifying this inventory item template.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedInventoryItemTemplateRequest] :patched_inventory_item_template_request
  # @return [InventoryItemTemplate]
  describe "dcim_inventory_item_templates_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_item_templates_retrieve
  # Get a inventory item template object.
  # @param id A unique integer value identifying this inventory item template.
  # @param [Hash] opts the optional parameters
  # @return [InventoryItemTemplate]
  describe "dcim_inventory_item_templates_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_item_templates_update
  # Put a inventory item template object.
  # @param id A unique integer value identifying this inventory item template.
  # @param inventory_item_template_request
  # @param [Hash] opts the optional parameters
  # @return [InventoryItemTemplate]
  describe "dcim_inventory_item_templates_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_items_bulk_destroy
  # Delete a list of inventory item objects.
  # @param inventory_item_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_inventory_items_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_items_bulk_partial_update
  # Patch a list of inventory item objects.
  # @param inventory_item_request
  # @param [Hash] opts the optional parameters
  # @return [Array(InventoryItem)]
  describe "dcim_inventory_items_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_items_bulk_update
  # Put a list of inventory item objects.
  # @param inventory_item_request
  # @param [Hash] opts the optional parameters
  # @return [Array(InventoryItem)]
  describe "dcim_inventory_items_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_items_create
  # Post a list of inventory item objects.
  # @param dcim_inventory_items_create_request
  # @param [Hash] opts the optional parameters
  # @return [InventoryItem]
  describe "dcim_inventory_items_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_items_destroy
  # Delete a inventory item object.
  # @param id A unique integer value identifying this inventory item.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_inventory_items_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_items_list
  # Get a list of inventory item objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(String)] :asset_tag
  # @option opts [Bool] :asset_tag__empty
  # @option opts [Array(String)] :asset_tag__ic
  # @option opts [Array(String)] :asset_tag__ie
  # @option opts [Array(String)] :asset_tag__iew
  # @option opts [Array(String)] :asset_tag__iregex
  # @option opts [Array(String)] :asset_tag__isw
  # @option opts [Array(String)] :asset_tag__n
  # @option opts [Array(String)] :asset_tag__nic
  # @option opts [Array(String)] :asset_tag__nie
  # @option opts [Array(String)] :asset_tag__niew
  # @option opts [Array(String)] :asset_tag__nisw
  # @option opts [Array(String)] :asset_tag__regex
  # @option opts [Array(Int32)] :component_id
  # @option opts [Array(Int32)] :component_id__empty
  # @option opts [Array(Int32)] :component_id__gt
  # @option opts [Array(Int32)] :component_id__gte
  # @option opts [Array(Int32)] :component_id__lt
  # @option opts [Array(Int32)] :component_id__lte
  # @option opts [Array(Int32)] :component_id__n
  # @option opts [String] :component_type
  # @option opts [String] :component_type__n
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(String)] :device Device (name)
  # @option opts [Array(String)] :device__n Device (name)
  # @option opts [Array(Int32)] :device_id Device (ID)
  # @option opts [Array(Int32)] :device_id__n Device (ID)
  # @option opts [Array(String)] :device_role Device role (slug)
  # @option opts [Array(String)] :device_role__n Device role (slug)
  # @option opts [Array(Int32)] :device_role_id Device role (ID)
  # @option opts [Array(Int32)] :device_role_id__n Device role (ID)
  # @option opts [Array(String)] :device_status
  # @option opts [Bool] :device_status__empty
  # @option opts [Array(String)] :device_status__ic
  # @option opts [Array(String)] :device_status__ie
  # @option opts [Array(String)] :device_status__iew
  # @option opts [Array(String)] :device_status__iregex
  # @option opts [Array(String)] :device_status__isw
  # @option opts [Array(String)] :device_status__n
  # @option opts [Array(String)] :device_status__nic
  # @option opts [Array(String)] :device_status__nie
  # @option opts [Array(String)] :device_status__niew
  # @option opts [Array(String)] :device_status__nisw
  # @option opts [Array(String)] :device_status__regex
  # @option opts [Array(String)] :device_type Device type (model)
  # @option opts [Array(String)] :device_type__n Device type (model)
  # @option opts [Array(Int32)] :device_type_id Device type (ID)
  # @option opts [Array(Int32)] :device_type_id__n Device type (ID)
  # @option opts [Bool] :discovered
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :label
  # @option opts [Bool] :label__empty
  # @option opts [Array(String)] :label__ic
  # @option opts [Array(String)] :label__ie
  # @option opts [Array(String)] :label__iew
  # @option opts [Array(String)] :label__iregex
  # @option opts [Array(String)] :label__isw
  # @option opts [Array(String)] :label__n
  # @option opts [Array(String)] :label__nic
  # @option opts [Array(String)] :label__nie
  # @option opts [Array(String)] :label__niew
  # @option opts [Array(String)] :label__nisw
  # @option opts [Array(String)] :label__regex
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(String)] :location Location (slug)
  # @option opts [Array(String)] :location__n Location (slug)
  # @option opts [Array(Int32)] :location_id Location (ID)
  # @option opts [Array(Int32)] :location_id__n Location (ID)
  # @option opts [Array(String)] :manufacturer Manufacturer (slug)
  # @option opts [Array(String)] :manufacturer__n Manufacturer (slug)
  # @option opts [Array(Int32)] :manufacturer_id Manufacturer (ID)
  # @option opts [Array(Int32)] :manufacturer_id__n Manufacturer (ID)
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Array(Int32)] :parent_id Parent inventory item (ID)
  # @option opts [Array(Int32)] :parent_id__n Parent inventory item (ID)
  # @option opts [Array(String)] :part_id
  # @option opts [Bool] :part_id__empty
  # @option opts [Array(String)] :part_id__ic
  # @option opts [Array(String)] :part_id__ie
  # @option opts [Array(String)] :part_id__iew
  # @option opts [Array(String)] :part_id__iregex
  # @option opts [Array(String)] :part_id__isw
  # @option opts [Array(String)] :part_id__n
  # @option opts [Array(String)] :part_id__nic
  # @option opts [Array(String)] :part_id__nie
  # @option opts [Array(String)] :part_id__niew
  # @option opts [Array(String)] :part_id__nisw
  # @option opts [Array(String)] :part_id__regex
  # @option opts [String] :q Search
  # @option opts [Array(String)] :rack Rack (name)
  # @option opts [Array(String)] :rack__n Rack (name)
  # @option opts [Array(Int32)] :rack_id Rack (ID)
  # @option opts [Array(Int32)] :rack_id__n Rack (ID)
  # @option opts [Array(String)] :region
  # @option opts [Array(String)] :region__n
  # @option opts [Array(String)] :region_id
  # @option opts [Array(String)] :region_id__n
  # @option opts [Array(String)] :role Role (slug)
  # @option opts [Array(String)] :role__n Role (slug)
  # @option opts [Array(Int32)] :role_id Role (ID)
  # @option opts [Array(Int32)] :role_id__n Role (ID)
  # @option opts [Array(String)] :serial
  # @option opts [Bool] :serial__empty
  # @option opts [Array(String)] :serial__ic
  # @option opts [Array(String)] :serial__ie
  # @option opts [Array(String)] :serial__iew
  # @option opts [Array(String)] :serial__iregex
  # @option opts [Array(String)] :serial__isw
  # @option opts [Array(String)] :serial__n
  # @option opts [Array(String)] :serial__nic
  # @option opts [Array(String)] :serial__nie
  # @option opts [Array(String)] :serial__niew
  # @option opts [Array(String)] :serial__nisw
  # @option opts [Array(String)] :serial__regex
  # @option opts [Array(String)] :site Site name (slug)
  # @option opts [Array(String)] :site__n Site name (slug)
  # @option opts [Array(String)] :site_group
  # @option opts [Array(String)] :site_group__n
  # @option opts [Array(String)] :site_group_id
  # @option opts [Array(String)] :site_group_id__n
  # @option opts [Array(Int32)] :site_id Site (ID)
  # @option opts [Array(Int32)] :site_id__n Site (ID)
  # @option opts [Array(String)] :status
  # @option opts [Bool] :status__empty
  # @option opts [Array(String)] :status__ic
  # @option opts [Array(String)] :status__ie
  # @option opts [Array(String)] :status__iew
  # @option opts [Array(String)] :status__iregex
  # @option opts [Array(String)] :status__isw
  # @option opts [Array(String)] :status__n
  # @option opts [Array(String)] :status__nic
  # @option opts [Array(String)] :status__nie
  # @option opts [Array(String)] :status__niew
  # @option opts [Array(String)] :status__nisw
  # @option opts [Array(String)] :status__regex
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [Array(String)] :tenant Tenant (slug)
  # @option opts [Array(String)] :tenant__n Tenant (slug)
  # @option opts [Array(Int32)] :tenant_id Tenant (ID)
  # @option opts [Array(Int32)] :tenant_id__n Tenant (ID)
  # @option opts [String] :updated_by_request
  # @option opts [Array(String)] :virtual_chassis Virtual Chassis
  # @option opts [Array(String)] :virtual_chassis__n Virtual Chassis
  # @option opts [Array(Int32)] :virtual_chassis_id Virtual Chassis (ID)
  # @option opts [Array(Int32)] :virtual_chassis_id__n Virtual Chassis (ID)
  # @return [PaginatedInventoryItemList]
  describe "dcim_inventory_items_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_items_partial_update
  # Patch a inventory item object.
  # @param id A unique integer value identifying this inventory item.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableInventoryItemRequest] :patched_writable_inventory_item_request
  # @return [InventoryItem]
  describe "dcim_inventory_items_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_items_retrieve
  # Get a inventory item object.
  # @param id A unique integer value identifying this inventory item.
  # @param [Hash] opts the optional parameters
  # @return [InventoryItem]
  describe "dcim_inventory_items_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_inventory_items_update
  # Put a inventory item object.
  # @param id A unique integer value identifying this inventory item.
  # @param writable_inventory_item_request
  # @param [Hash] opts the optional parameters
  # @return [InventoryItem]
  describe "dcim_inventory_items_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_locations_bulk_destroy
  # Delete a list of location objects.
  # @param location_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_locations_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_locations_bulk_partial_update
  # Patch a list of location objects.
  # @param location_request
  # @param [Hash] opts the optional parameters
  # @return [Array(Location)]
  describe "dcim_locations_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_locations_bulk_update
  # Put a list of location objects.
  # @param location_request
  # @param [Hash] opts the optional parameters
  # @return [Array(Location)]
  describe "dcim_locations_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_locations_create
  # Post a list of location objects.
  # @param dcim_locations_create_request
  # @param [Hash] opts the optional parameters
  # @return [Location]
  describe "dcim_locations_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_locations_destroy
  # Delete a location object.
  # @param id A unique integer value identifying this location.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_locations_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_locations_list
  # Get a list of location objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(String)] :ancestor
  # @option opts [Array(String)] :ancestor__n
  # @option opts [Array(String)] :ancestor_id
  # @option opts [Array(String)] :ancestor_id__n
  # @option opts [Array(Int32)] :contact Contact
  # @option opts [Array(Int32)] :contact__n Contact
  # @option opts [Array(String)] :contact_group
  # @option opts [Array(String)] :contact_group__n
  # @option opts [Array(Int32)] :contact_role Contact Role
  # @option opts [Array(Int32)] :contact_role__n Contact Role
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(String)] :facility
  # @option opts [Bool] :facility__empty
  # @option opts [Array(String)] :facility__ic
  # @option opts [Array(String)] :facility__ie
  # @option opts [Array(String)] :facility__iew
  # @option opts [Array(String)] :facility__iregex
  # @option opts [Array(String)] :facility__isw
  # @option opts [Array(String)] :facility__n
  # @option opts [Array(String)] :facility__nic
  # @option opts [Array(String)] :facility__nie
  # @option opts [Array(String)] :facility__niew
  # @option opts [Array(String)] :facility__nisw
  # @option opts [Array(String)] :facility__regex
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Array(String)] :parent Parent location (slug)
  # @option opts [Array(String)] :parent__n Parent location (slug)
  # @option opts [Array(Int32)] :parent_id Parent location (ID)
  # @option opts [Array(Int32)] :parent_id__n Parent location (ID)
  # @option opts [String] :q Search
  # @option opts [Array(String)] :region
  # @option opts [Array(String)] :region__n
  # @option opts [Array(String)] :region_id
  # @option opts [Array(String)] :region_id__n
  # @option opts [Array(String)] :site Site (slug)
  # @option opts [Array(String)] :site__n Site (slug)
  # @option opts [Array(String)] :site_group
  # @option opts [Array(String)] :site_group__n
  # @option opts [Array(String)] :site_group_id
  # @option opts [Array(String)] :site_group_id__n
  # @option opts [Array(Int32)] :site_id Site (ID)
  # @option opts [Array(Int32)] :site_id__n Site (ID)
  # @option opts [Array(String)] :slug
  # @option opts [Bool] :slug__empty
  # @option opts [Array(String)] :slug__ic
  # @option opts [Array(String)] :slug__ie
  # @option opts [Array(String)] :slug__iew
  # @option opts [Array(String)] :slug__iregex
  # @option opts [Array(String)] :slug__isw
  # @option opts [Array(String)] :slug__n
  # @option opts [Array(String)] :slug__nic
  # @option opts [Array(String)] :slug__nie
  # @option opts [Array(String)] :slug__niew
  # @option opts [Array(String)] :slug__nisw
  # @option opts [Array(String)] :slug__regex
  # @option opts [Array(String)] :status
  # @option opts [Bool] :status__empty
  # @option opts [Array(String)] :status__ic
  # @option opts [Array(String)] :status__ie
  # @option opts [Array(String)] :status__iew
  # @option opts [Array(String)] :status__iregex
  # @option opts [Array(String)] :status__isw
  # @option opts [Array(String)] :status__n
  # @option opts [Array(String)] :status__nic
  # @option opts [Array(String)] :status__nie
  # @option opts [Array(String)] :status__niew
  # @option opts [Array(String)] :status__nisw
  # @option opts [Array(String)] :status__regex
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [Array(String)] :tenant Tenant (slug)
  # @option opts [Array(String)] :tenant__n Tenant (slug)
  # @option opts [Array(String)] :tenant_group
  # @option opts [Array(String)] :tenant_group__n
  # @option opts [Array(String)] :tenant_group_id
  # @option opts [Array(String)] :tenant_group_id__n
  # @option opts [Array(Int32)] :tenant_id Tenant (ID)
  # @option opts [Array(Int32)] :tenant_id__n Tenant (ID)
  # @option opts [String] :updated_by_request
  # @return [PaginatedLocationList]
  describe "dcim_locations_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_locations_partial_update
  # Patch a location object.
  # @param id A unique integer value identifying this location.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableLocationRequest] :patched_writable_location_request
  # @return [Location]
  describe "dcim_locations_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_locations_retrieve
  # Get a location object.
  # @param id A unique integer value identifying this location.
  # @param [Hash] opts the optional parameters
  # @return [Location]
  describe "dcim_locations_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_locations_update
  # Put a location object.
  # @param id A unique integer value identifying this location.
  # @param writable_location_request
  # @param [Hash] opts the optional parameters
  # @return [Location]
  describe "dcim_locations_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_mac_addresses_bulk_destroy
  # Delete a list of MAC address objects.
  # @param mac_address_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_mac_addresses_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_mac_addresses_bulk_partial_update
  # Patch a list of MAC address objects.
  # @param mac_address_request
  # @param [Hash] opts the optional parameters
  # @return [Array(MACAddress)]
  describe "dcim_mac_addresses_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_mac_addresses_bulk_update
  # Put a list of MAC address objects.
  # @param mac_address_request
  # @param [Hash] opts the optional parameters
  # @return [Array(MACAddress)]
  describe "dcim_mac_addresses_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_mac_addresses_create
  # Post a list of MAC address objects.
  # @param dcim_mac_addresses_create_request
  # @param [Hash] opts the optional parameters
  # @return [MACAddress]
  describe "dcim_mac_addresses_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_mac_addresses_destroy
  # Delete a MAC address object.
  # @param id A unique integer value identifying this MAC address.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_mac_addresses_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_mac_addresses_list
  # Get a list of MAC address objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Bool] :assigned Is assigned
  # @option opts [Array(Int32)] :assigned_object_id
  # @option opts [Bool] :assigned_object_id__empty
  # @option opts [Array(Int32)] :assigned_object_id__gt
  # @option opts [Array(Int32)] :assigned_object_id__gte
  # @option opts [Array(Int32)] :assigned_object_id__lt
  # @option opts [Array(Int32)] :assigned_object_id__lte
  # @option opts [Array(Int32)] :assigned_object_id__n
  # @option opts [String] :assigned_object_type
  # @option opts [String] :assigned_object_type__n
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(String)] :device
  # @option opts [Array(Int32)] :device_id
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :interface Interface (name)
  # @option opts [Array(String)] :interface__n Interface (name)
  # @option opts [Array(Int32)] :interface_id Interface (ID)
  # @option opts [Array(Int32)] :interface_id__n Interface (ID)
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(String)] :mac_address
  # @option opts [Array(String)] :mac_address__ic
  # @option opts [Array(String)] :mac_address__ie
  # @option opts [Array(String)] :mac_address__iew
  # @option opts [Array(String)] :mac_address__iregex
  # @option opts [Array(String)] :mac_address__isw
  # @option opts [Array(String)] :mac_address__n
  # @option opts [Array(String)] :mac_address__nic
  # @option opts [Array(String)] :mac_address__nie
  # @option opts [Array(String)] :mac_address__niew
  # @option opts [Array(String)] :mac_address__nisw
  # @option opts [Array(String)] :mac_address__regex
  # @option opts [String] :modified_by_request
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Bool] :primary Is primary
  # @option opts [String] :q Search
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [String] :updated_by_request
  # @option opts [Array(String)] :virtual_machine
  # @option opts [Array(Int32)] :virtual_machine_id
  # @option opts [Array(String)] :vminterface VM interface (name)
  # @option opts [Array(String)] :vminterface__n VM interface (name)
  # @option opts [Array(Int32)] :vminterface_id VM interface (ID)
  # @option opts [Array(Int32)] :vminterface_id__n VM interface (ID)
  # @return [PaginatedMACAddressList]
  describe "dcim_mac_addresses_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_mac_addresses_partial_update
  # Patch a MAC address object.
  # @param id A unique integer value identifying this MAC address.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedMACAddressRequest] :patched_mac_address_request
  # @return [MACAddress]
  describe "dcim_mac_addresses_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_mac_addresses_retrieve
  # Get a MAC address object.
  # @param id A unique integer value identifying this MAC address.
  # @param [Hash] opts the optional parameters
  # @return [MACAddress]
  describe "dcim_mac_addresses_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_mac_addresses_update
  # Put a MAC address object.
  # @param id A unique integer value identifying this MAC address.
  # @param mac_address_request
  # @param [Hash] opts the optional parameters
  # @return [MACAddress]
  describe "dcim_mac_addresses_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_manufacturers_bulk_destroy
  # Delete a list of manufacturer objects.
  # @param manufacturer_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_manufacturers_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_manufacturers_bulk_partial_update
  # Patch a list of manufacturer objects.
  # @param manufacturer_request
  # @param [Hash] opts the optional parameters
  # @return [Array(Manufacturer)]
  describe "dcim_manufacturers_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_manufacturers_bulk_update
  # Put a list of manufacturer objects.
  # @param manufacturer_request
  # @param [Hash] opts the optional parameters
  # @return [Array(Manufacturer)]
  describe "dcim_manufacturers_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_manufacturers_create
  # Post a list of manufacturer objects.
  # @param dcim_manufacturers_create_request
  # @param [Hash] opts the optional parameters
  # @return [Manufacturer]
  describe "dcim_manufacturers_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_manufacturers_destroy
  # Delete a manufacturer object.
  # @param id A unique integer value identifying this manufacturer.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_manufacturers_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_manufacturers_list
  # Get a list of manufacturer objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Int32)] :contact Contact
  # @option opts [Array(Int32)] :contact__n Contact
  # @option opts [Array(String)] :contact_group
  # @option opts [Array(String)] :contact_group__n
  # @option opts [Array(Int32)] :contact_role Contact Role
  # @option opts [Array(Int32)] :contact_role__n Contact Role
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [Array(String)] :slug
  # @option opts [Bool] :slug__empty
  # @option opts [Array(String)] :slug__ic
  # @option opts [Array(String)] :slug__ie
  # @option opts [Array(String)] :slug__iew
  # @option opts [Array(String)] :slug__iregex
  # @option opts [Array(String)] :slug__isw
  # @option opts [Array(String)] :slug__n
  # @option opts [Array(String)] :slug__nic
  # @option opts [Array(String)] :slug__nie
  # @option opts [Array(String)] :slug__niew
  # @option opts [Array(String)] :slug__nisw
  # @option opts [Array(String)] :slug__regex
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [String] :updated_by_request
  # @return [PaginatedManufacturerList]
  describe "dcim_manufacturers_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_manufacturers_partial_update
  # Patch a manufacturer object.
  # @param id A unique integer value identifying this manufacturer.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedManufacturerRequest] :patched_manufacturer_request
  # @return [Manufacturer]
  describe "dcim_manufacturers_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_manufacturers_retrieve
  # Get a manufacturer object.
  # @param id A unique integer value identifying this manufacturer.
  # @param [Hash] opts the optional parameters
  # @return [Manufacturer]
  describe "dcim_manufacturers_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_manufacturers_update
  # Put a manufacturer object.
  # @param id A unique integer value identifying this manufacturer.
  # @param manufacturer_request
  # @param [Hash] opts the optional parameters
  # @return [Manufacturer]
  describe "dcim_manufacturers_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_bay_templates_bulk_destroy
  # Delete a list of module bay template objects.
  # @param module_bay_template_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_module_bay_templates_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_bay_templates_bulk_partial_update
  # Patch a list of module bay template objects.
  # @param module_bay_template_request
  # @param [Hash] opts the optional parameters
  # @return [Array(ModuleBayTemplate)]
  describe "dcim_module_bay_templates_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_bay_templates_bulk_update
  # Put a list of module bay template objects.
  # @param module_bay_template_request
  # @param [Hash] opts the optional parameters
  # @return [Array(ModuleBayTemplate)]
  describe "dcim_module_bay_templates_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_bay_templates_create
  # Post a list of module bay template objects.
  # @param dcim_module_bay_templates_create_request
  # @param [Hash] opts the optional parameters
  # @return [ModuleBayTemplate]
  describe "dcim_module_bay_templates_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_bay_templates_destroy
  # Delete a module bay template object.
  # @param id A unique integer value identifying this module bay template.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_module_bay_templates_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_bay_templates_list
  # Get a list of module bay template objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :device_type_id Device type (ID)
  # @option opts [Array(Int32)] :device_type_id__n Device type (ID)
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :label
  # @option opts [Bool] :label__empty
  # @option opts [Array(String)] :label__ic
  # @option opts [Array(String)] :label__ie
  # @option opts [Array(String)] :label__iew
  # @option opts [Array(String)] :label__iregex
  # @option opts [Array(String)] :label__isw
  # @option opts [Array(String)] :label__n
  # @option opts [Array(String)] :label__nic
  # @option opts [Array(String)] :label__nie
  # @option opts [Array(String)] :label__niew
  # @option opts [Array(String)] :label__nisw
  # @option opts [Array(String)] :label__regex
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [String] :modified_by_request
  # @option opts [Array(Int32)] :module_type_id Module type (ID)
  # @option opts [Array(Int32)] :module_type_id__n Module type (ID)
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Array(String)] :position
  # @option opts [Bool] :position__empty
  # @option opts [Array(String)] :position__ic
  # @option opts [Array(String)] :position__ie
  # @option opts [Array(String)] :position__iew
  # @option opts [Array(String)] :position__iregex
  # @option opts [Array(String)] :position__isw
  # @option opts [Array(String)] :position__n
  # @option opts [Array(String)] :position__nic
  # @option opts [Array(String)] :position__nie
  # @option opts [Array(String)] :position__niew
  # @option opts [Array(String)] :position__nisw
  # @option opts [Array(String)] :position__regex
  # @option opts [String] :q Search
  # @option opts [String] :updated_by_request
  # @return [PaginatedModuleBayTemplateList]
  describe "dcim_module_bay_templates_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_bay_templates_partial_update
  # Patch a module bay template object.
  # @param id A unique integer value identifying this module bay template.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedModuleBayTemplateRequest] :patched_module_bay_template_request
  # @return [ModuleBayTemplate]
  describe "dcim_module_bay_templates_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_bay_templates_retrieve
  # Get a module bay template object.
  # @param id A unique integer value identifying this module bay template.
  # @param [Hash] opts the optional parameters
  # @return [ModuleBayTemplate]
  describe "dcim_module_bay_templates_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_bay_templates_update
  # Put a module bay template object.
  # @param id A unique integer value identifying this module bay template.
  # @param module_bay_template_request
  # @param [Hash] opts the optional parameters
  # @return [ModuleBayTemplate]
  describe "dcim_module_bay_templates_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_bays_bulk_destroy
  # Delete a list of module bay objects.
  # @param module_bay_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_module_bays_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_bays_bulk_partial_update
  # Patch a list of module bay objects.
  # @param module_bay_request
  # @param [Hash] opts the optional parameters
  # @return [Array(ModuleBay)]
  describe "dcim_module_bays_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_bays_bulk_update
  # Put a list of module bay objects.
  # @param module_bay_request
  # @param [Hash] opts the optional parameters
  # @return [Array(ModuleBay)]
  describe "dcim_module_bays_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_bays_create
  # Post a list of module bay objects.
  # @param dcim_module_bays_create_request
  # @param [Hash] opts the optional parameters
  # @return [ModuleBay]
  describe "dcim_module_bays_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_bays_destroy
  # Delete a module bay object.
  # @param id A unique integer value identifying this module bay.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_module_bays_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_bays_list
  # Get a list of module bay objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(String)] :device Device (name)
  # @option opts [Array(String)] :device__n Device (name)
  # @option opts [Array(Int32)] :device_id Device (ID)
  # @option opts [Array(Int32)] :device_id__n Device (ID)
  # @option opts [Array(String)] :device_role Device role (slug)
  # @option opts [Array(String)] :device_role__n Device role (slug)
  # @option opts [Array(Int32)] :device_role_id Device role (ID)
  # @option opts [Array(Int32)] :device_role_id__n Device role (ID)
  # @option opts [Array(String)] :device_status
  # @option opts [Bool] :device_status__empty
  # @option opts [Array(String)] :device_status__ic
  # @option opts [Array(String)] :device_status__ie
  # @option opts [Array(String)] :device_status__iew
  # @option opts [Array(String)] :device_status__iregex
  # @option opts [Array(String)] :device_status__isw
  # @option opts [Array(String)] :device_status__n
  # @option opts [Array(String)] :device_status__nic
  # @option opts [Array(String)] :device_status__nie
  # @option opts [Array(String)] :device_status__niew
  # @option opts [Array(String)] :device_status__nisw
  # @option opts [Array(String)] :device_status__regex
  # @option opts [Array(String)] :device_type Device type (model)
  # @option opts [Array(String)] :device_type__n Device type (model)
  # @option opts [Array(Int32)] :device_type_id Device type (ID)
  # @option opts [Array(Int32)] :device_type_id__n Device type (ID)
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(Int32)] :installed_module_id Installed module (ID)
  # @option opts [Array(Int32)] :installed_module_id__n Installed module (ID)
  # @option opts [Array(String)] :label
  # @option opts [Bool] :label__empty
  # @option opts [Array(String)] :label__ic
  # @option opts [Array(String)] :label__ie
  # @option opts [Array(String)] :label__iew
  # @option opts [Array(String)] :label__iregex
  # @option opts [Array(String)] :label__isw
  # @option opts [Array(String)] :label__n
  # @option opts [Array(String)] :label__nic
  # @option opts [Array(String)] :label__nie
  # @option opts [Array(String)] :label__niew
  # @option opts [Array(String)] :label__nisw
  # @option opts [Array(String)] :label__regex
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(String)] :location Location (slug)
  # @option opts [Array(String)] :location__n Location (slug)
  # @option opts [Array(Int32)] :location_id Location (ID)
  # @option opts [Array(Int32)] :location_id__n Location (ID)
  # @option opts [String] :modified_by_request
  # @option opts [Array(Int32)] :module_id Module (ID)
  # @option opts [Array(Int32)] :module_id__n Module (ID)
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Array(Int32)] :parent_id Parent module bay (ID)
  # @option opts [Array(Int32)] :parent_id__n Parent module bay (ID)
  # @option opts [Array(String)] :position
  # @option opts [Bool] :position__empty
  # @option opts [Array(String)] :position__ic
  # @option opts [Array(String)] :position__ie
  # @option opts [Array(String)] :position__iew
  # @option opts [Array(String)] :position__iregex
  # @option opts [Array(String)] :position__isw
  # @option opts [Array(String)] :position__n
  # @option opts [Array(String)] :position__nic
  # @option opts [Array(String)] :position__nie
  # @option opts [Array(String)] :position__niew
  # @option opts [Array(String)] :position__nisw
  # @option opts [Array(String)] :position__regex
  # @option opts [String] :q Search
  # @option opts [Array(String)] :rack Rack (name)
  # @option opts [Array(String)] :rack__n Rack (name)
  # @option opts [Array(Int32)] :rack_id Rack (ID)
  # @option opts [Array(Int32)] :rack_id__n Rack (ID)
  # @option opts [Array(String)] :region
  # @option opts [Array(String)] :region__n
  # @option opts [Array(String)] :region_id
  # @option opts [Array(String)] :region_id__n
  # @option opts [Array(String)] :site Site name (slug)
  # @option opts [Array(String)] :site__n Site name (slug)
  # @option opts [Array(String)] :site_group
  # @option opts [Array(String)] :site_group__n
  # @option opts [Array(String)] :site_group_id
  # @option opts [Array(String)] :site_group_id__n
  # @option opts [Array(Int32)] :site_id Site (ID)
  # @option opts [Array(Int32)] :site_id__n Site (ID)
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [Array(String)] :tenant Tenant (slug)
  # @option opts [Array(String)] :tenant__n Tenant (slug)
  # @option opts [Array(Int32)] :tenant_id Tenant (ID)
  # @option opts [Array(Int32)] :tenant_id__n Tenant (ID)
  # @option opts [String] :updated_by_request
  # @option opts [Array(String)] :virtual_chassis Virtual Chassis
  # @option opts [Array(String)] :virtual_chassis__n Virtual Chassis
  # @option opts [Array(Int32)] :virtual_chassis_id Virtual Chassis (ID)
  # @option opts [Array(Int32)] :virtual_chassis_id__n Virtual Chassis (ID)
  # @return [PaginatedModuleBayList]
  describe "dcim_module_bays_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_bays_partial_update
  # Patch a module bay object.
  # @param id A unique integer value identifying this module bay.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedModuleBayRequest] :patched_module_bay_request
  # @return [ModuleBay]
  describe "dcim_module_bays_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_bays_retrieve
  # Get a module bay object.
  # @param id A unique integer value identifying this module bay.
  # @param [Hash] opts the optional parameters
  # @return [ModuleBay]
  describe "dcim_module_bays_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_bays_update
  # Put a module bay object.
  # @param id A unique integer value identifying this module bay.
  # @param module_bay_request
  # @param [Hash] opts the optional parameters
  # @return [ModuleBay]
  describe "dcim_module_bays_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_type_profiles_bulk_destroy
  # Delete a list of module type profile objects.
  # @param module_type_profile_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_module_type_profiles_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_type_profiles_bulk_partial_update
  # Patch a list of module type profile objects.
  # @param module_type_profile_request
  # @param [Hash] opts the optional parameters
  # @return [Array(ModuleTypeProfile)]
  describe "dcim_module_type_profiles_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_type_profiles_bulk_update
  # Put a list of module type profile objects.
  # @param module_type_profile_request
  # @param [Hash] opts the optional parameters
  # @return [Array(ModuleTypeProfile)]
  describe "dcim_module_type_profiles_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_type_profiles_create
  # Post a list of module type profile objects.
  # @param dcim_module_type_profiles_create_request
  # @param [Hash] opts the optional parameters
  # @return [ModuleTypeProfile]
  describe "dcim_module_type_profiles_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_type_profiles_destroy
  # Delete a module type profile object.
  # @param id A unique integer value identifying this module type profile.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_module_type_profiles_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_type_profiles_list
  # Get a list of module type profile objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [String] :updated_by_request
  # @return [PaginatedModuleTypeProfileList]
  describe "dcim_module_type_profiles_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_type_profiles_partial_update
  # Patch a module type profile object.
  # @param id A unique integer value identifying this module type profile.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedModuleTypeProfileRequest] :patched_module_type_profile_request
  # @return [ModuleTypeProfile]
  describe "dcim_module_type_profiles_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_type_profiles_retrieve
  # Get a module type profile object.
  # @param id A unique integer value identifying this module type profile.
  # @param [Hash] opts the optional parameters
  # @return [ModuleTypeProfile]
  describe "dcim_module_type_profiles_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_type_profiles_update
  # Put a module type profile object.
  # @param id A unique integer value identifying this module type profile.
  # @param module_type_profile_request
  # @param [Hash] opts the optional parameters
  # @return [ModuleTypeProfile]
  describe "dcim_module_type_profiles_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_types_bulk_destroy
  # Delete a list of module type objects.
  # @param module_type_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_module_types_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_types_bulk_partial_update
  # Patch a list of module type objects.
  # @param module_type_request
  # @param [Hash] opts the optional parameters
  # @return [Array(ModuleType)]
  describe "dcim_module_types_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_types_bulk_update
  # Put a list of module type objects.
  # @param module_type_request
  # @param [Hash] opts the optional parameters
  # @return [Array(ModuleType)]
  describe "dcim_module_types_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_types_create
  # Post a list of module type objects.
  # @param dcim_module_types_create_request
  # @param [Hash] opts the optional parameters
  # @return [ModuleType]
  describe "dcim_module_types_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_types_destroy
  # Delete a module type object.
  # @param id A unique integer value identifying this module type.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_module_types_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_types_list
  # Get a list of module type objects.
  # @param [Hash] opts the optional parameters
  # @option opts [String] :airflow * &#x60;front-to-rear&#x60; - Front to rear * &#x60;rear-to-front&#x60; - Rear to front * &#x60;left-to-right&#x60; - Left to right * &#x60;right-to-left&#x60; - Right to left * &#x60;side-to-rear&#x60; - Side to rear * &#x60;passive&#x60; - Passive
  # @option opts [Bool] :console_ports Has console ports
  # @option opts [Bool] :console_server_ports Has console server ports
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Bool] :interfaces Has interfaces
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(String)] :manufacturer Manufacturer (slug)
  # @option opts [Array(String)] :manufacturer__n Manufacturer (slug)
  # @option opts [Array(Int32)] :manufacturer_id Manufacturer (ID)
  # @option opts [Array(Int32)] :manufacturer_id__n Manufacturer (ID)
  # @option opts [Array(String)] :model
  # @option opts [Bool] :model__empty
  # @option opts [Array(String)] :model__ic
  # @option opts [Array(String)] :model__ie
  # @option opts [Array(String)] :model__iew
  # @option opts [Array(String)] :model__iregex
  # @option opts [Array(String)] :model__isw
  # @option opts [Array(String)] :model__n
  # @option opts [Array(String)] :model__nic
  # @option opts [Array(String)] :model__nie
  # @option opts [Array(String)] :model__niew
  # @option opts [Array(String)] :model__nisw
  # @option opts [Array(String)] :model__regex
  # @option opts [String] :modified_by_request
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Array(String)] :part_number
  # @option opts [Bool] :part_number__empty
  # @option opts [Array(String)] :part_number__ic
  # @option opts [Array(String)] :part_number__ie
  # @option opts [Array(String)] :part_number__iew
  # @option opts [Array(String)] :part_number__iregex
  # @option opts [Array(String)] :part_number__isw
  # @option opts [Array(String)] :part_number__n
  # @option opts [Array(String)] :part_number__nic
  # @option opts [Array(String)] :part_number__nie
  # @option opts [Array(String)] :part_number__niew
  # @option opts [Array(String)] :part_number__nisw
  # @option opts [Array(String)] :part_number__regex
  # @option opts [Bool] :pass_through_ports Has pass-through ports
  # @option opts [Bool] :power_outlets Has power outlets
  # @option opts [Bool] :power_ports Has power ports
  # @option opts [Array(String)] :profile Profile (name)
  # @option opts [Array(String)] :profile__n Profile (name)
  # @option opts [Array(Int32)] :profile_id Profile (ID)
  # @option opts [Array(Int32)] :profile_id__n Profile (ID)
  # @option opts [String] :q Search
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [String] :updated_by_request
  # @option opts [Array(Float64)] :weight
  # @option opts [Bool] :weight__empty
  # @option opts [Array(Float64)] :weight__gt
  # @option opts [Array(Float64)] :weight__gte
  # @option opts [Array(Float64)] :weight__lt
  # @option opts [Array(Float64)] :weight__lte
  # @option opts [Array(Float64)] :weight__n
  # @option opts [String] :weight_unit * &#x60;kg&#x60; - Kilograms * &#x60;g&#x60; - Grams * &#x60;lb&#x60; - Pounds * &#x60;oz&#x60; - Ounces
  # @return [PaginatedModuleTypeList]
  describe "dcim_module_types_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_types_partial_update
  # Patch a module type object.
  # @param id A unique integer value identifying this module type.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableModuleTypeRequest] :patched_writable_module_type_request
  # @return [ModuleType]
  describe "dcim_module_types_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_types_retrieve
  # Get a module type object.
  # @param id A unique integer value identifying this module type.
  # @param [Hash] opts the optional parameters
  # @return [ModuleType]
  describe "dcim_module_types_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_module_types_update
  # Put a module type object.
  # @param id A unique integer value identifying this module type.
  # @param writable_module_type_request
  # @param [Hash] opts the optional parameters
  # @return [ModuleType]
  describe "dcim_module_types_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_modules_bulk_destroy
  # Delete a list of module objects.
  # @param module_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_modules_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_modules_bulk_partial_update
  # Patch a list of module objects.
  # @param module_request
  # @param [Hash] opts the optional parameters
  # @return [Array(ModelModule)]
  describe "dcim_modules_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_modules_bulk_update
  # Put a list of module objects.
  # @param module_request
  # @param [Hash] opts the optional parameters
  # @return [Array(ModelModule)]
  describe "dcim_modules_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_modules_create
  # Post a list of module objects.
  # @param dcim_modules_create_request
  # @param [Hash] opts the optional parameters
  # @return [ModelModule]
  describe "dcim_modules_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_modules_destroy
  # Delete a module object.
  # @param id A unique integer value identifying this module.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_modules_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_modules_list
  # Get a list of module objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(String)] :asset_tag
  # @option opts [Bool] :asset_tag__empty
  # @option opts [Array(String)] :asset_tag__ic
  # @option opts [Array(String)] :asset_tag__ie
  # @option opts [Array(String)] :asset_tag__iew
  # @option opts [Array(String)] :asset_tag__iregex
  # @option opts [Array(String)] :asset_tag__isw
  # @option opts [Array(String)] :asset_tag__n
  # @option opts [Array(String)] :asset_tag__nic
  # @option opts [Array(String)] :asset_tag__nie
  # @option opts [Array(String)] :asset_tag__niew
  # @option opts [Array(String)] :asset_tag__nisw
  # @option opts [Array(String)] :asset_tag__regex
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(String)] :device Device (name)
  # @option opts [Array(String)] :device__n Device (name)
  # @option opts [Array(Int32)] :device_id Device (ID)
  # @option opts [Array(Int32)] :device_id__n Device (ID)
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(String)] :location Location (slug)
  # @option opts [Array(String)] :location__n Location (slug)
  # @option opts [Array(Int32)] :location_id Location (ID)
  # @option opts [Array(Int32)] :location_id__n Location (ID)
  # @option opts [Array(String)] :manufacturer Manufacturer (slug)
  # @option opts [Array(String)] :manufacturer__n Manufacturer (slug)
  # @option opts [Array(Int32)] :manufacturer_id Manufacturer (ID)
  # @option opts [Array(Int32)] :manufacturer_id__n Manufacturer (ID)
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :module_bay_id
  # @option opts [Array(String)] :module_bay_id__n
  # @option opts [Array(String)] :module_type Module type (model)
  # @option opts [Array(String)] :module_type__n Module type (model)
  # @option opts [Array(Int32)] :module_type_id Module type (ID)
  # @option opts [Array(Int32)] :module_type_id__n Module type (ID)
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [Array(String)] :rack Rack (name)
  # @option opts [Array(String)] :rack__n Rack (name)
  # @option opts [Array(Int32)] :rack_id Rack (ID)
  # @option opts [Array(Int32)] :rack_id__n Rack (ID)
  # @option opts [Array(String)] :region
  # @option opts [Array(String)] :region__n
  # @option opts [Array(String)] :region_id
  # @option opts [Array(String)] :region_id__n
  # @option opts [Array(String)] :serial
  # @option opts [Bool] :serial__empty
  # @option opts [Array(String)] :serial__ic
  # @option opts [Array(String)] :serial__ie
  # @option opts [Array(String)] :serial__iew
  # @option opts [Array(String)] :serial__iregex
  # @option opts [Array(String)] :serial__isw
  # @option opts [Array(String)] :serial__n
  # @option opts [Array(String)] :serial__nic
  # @option opts [Array(String)] :serial__nie
  # @option opts [Array(String)] :serial__niew
  # @option opts [Array(String)] :serial__nisw
  # @option opts [Array(String)] :serial__regex
  # @option opts [Array(String)] :site Site name (slug)
  # @option opts [Array(String)] :site__n Site name (slug)
  # @option opts [Array(String)] :site_group
  # @option opts [Array(String)] :site_group__n
  # @option opts [Array(String)] :site_group_id
  # @option opts [Array(String)] :site_group_id__n
  # @option opts [Array(Int32)] :site_id Site (ID)
  # @option opts [Array(Int32)] :site_id__n Site (ID)
  # @option opts [Array(String)] :status
  # @option opts [Bool] :status__empty
  # @option opts [Array(String)] :status__ic
  # @option opts [Array(String)] :status__ie
  # @option opts [Array(String)] :status__iew
  # @option opts [Array(String)] :status__iregex
  # @option opts [Array(String)] :status__isw
  # @option opts [Array(String)] :status__n
  # @option opts [Array(String)] :status__nic
  # @option opts [Array(String)] :status__nie
  # @option opts [Array(String)] :status__niew
  # @option opts [Array(String)] :status__nisw
  # @option opts [Array(String)] :status__regex
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [String] :updated_by_request
  # @return [PaginatedModuleList]
  describe "dcim_modules_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_modules_partial_update
  # Patch a module object.
  # @param id A unique integer value identifying this module.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableModuleRequest] :patched_writable_module_request
  # @return [ModelModule]
  describe "dcim_modules_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_modules_retrieve
  # Get a module object.
  # @param id A unique integer value identifying this module.
  # @param [Hash] opts the optional parameters
  # @return [ModelModule]
  describe "dcim_modules_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_modules_update
  # Put a module object.
  # @param id A unique integer value identifying this module.
  # @param writable_module_request
  # @param [Hash] opts the optional parameters
  # @return [ModelModule]
  describe "dcim_modules_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_platforms_bulk_destroy
  # Delete a list of platform objects.
  # @param platform_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_platforms_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_platforms_bulk_partial_update
  # Patch a list of platform objects.
  # @param platform_request
  # @param [Hash] opts the optional parameters
  # @return [Array(Platform)]
  describe "dcim_platforms_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_platforms_bulk_update
  # Put a list of platform objects.
  # @param platform_request
  # @param [Hash] opts the optional parameters
  # @return [Array(Platform)]
  describe "dcim_platforms_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_platforms_create
  # Post a list of platform objects.
  # @param dcim_platforms_create_request
  # @param [Hash] opts the optional parameters
  # @return [Platform]
  describe "dcim_platforms_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_platforms_destroy
  # Delete a platform object.
  # @param id A unique integer value identifying this platform.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_platforms_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_platforms_list
  # Get a list of platform objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(String)] :ancestor
  # @option opts [Array(String)] :ancestor__n
  # @option opts [Array(String)] :ancestor_id
  # @option opts [Array(String)] :ancestor_id__n
  # @option opts [String] :available_for_device_type
  # @option opts [Array(Int32)] :config_template_id Config template (ID)
  # @option opts [Array(Int32)] :config_template_id__n Config template (ID)
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(String)] :manufacturer Manufacturer (slug)
  # @option opts [Array(String)] :manufacturer__n Manufacturer (slug)
  # @option opts [Array(Int32)] :manufacturer_id Manufacturer (ID)
  # @option opts [Array(Int32)] :manufacturer_id__n Manufacturer (ID)
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Array(String)] :parent Immediate parent platform (slug)
  # @option opts [Array(String)] :parent__n Immediate parent platform (slug)
  # @option opts [Array(Int32)] :parent_id Immediate parent platform (ID)
  # @option opts [Array(Int32)] :parent_id__n Immediate parent platform (ID)
  # @option opts [String] :q Search
  # @option opts [Array(String)] :slug
  # @option opts [Bool] :slug__empty
  # @option opts [Array(String)] :slug__ic
  # @option opts [Array(String)] :slug__ie
  # @option opts [Array(String)] :slug__iew
  # @option opts [Array(String)] :slug__iregex
  # @option opts [Array(String)] :slug__isw
  # @option opts [Array(String)] :slug__n
  # @option opts [Array(String)] :slug__nic
  # @option opts [Array(String)] :slug__nie
  # @option opts [Array(String)] :slug__niew
  # @option opts [Array(String)] :slug__nisw
  # @option opts [Array(String)] :slug__regex
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [String] :updated_by_request
  # @return [PaginatedPlatformList]
  describe "dcim_platforms_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_platforms_partial_update
  # Patch a platform object.
  # @param id A unique integer value identifying this platform.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritablePlatformRequest] :patched_writable_platform_request
  # @return [Platform]
  describe "dcim_platforms_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_platforms_retrieve
  # Get a platform object.
  # @param id A unique integer value identifying this platform.
  # @param [Hash] opts the optional parameters
  # @return [Platform]
  describe "dcim_platforms_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_platforms_update
  # Put a platform object.
  # @param id A unique integer value identifying this platform.
  # @param writable_platform_request
  # @param [Hash] opts the optional parameters
  # @return [Platform]
  describe "dcim_platforms_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_feeds_bulk_destroy
  # Delete a list of power feed objects.
  # @param power_feed_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_power_feeds_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_feeds_bulk_partial_update
  # Patch a list of power feed objects.
  # @param power_feed_request
  # @param [Hash] opts the optional parameters
  # @return [Array(PowerFeed)]
  describe "dcim_power_feeds_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_feeds_bulk_update
  # Put a list of power feed objects.
  # @param power_feed_request
  # @param [Hash] opts the optional parameters
  # @return [Array(PowerFeed)]
  describe "dcim_power_feeds_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_feeds_create
  # Post a list of power feed objects.
  # @param dcim_power_feeds_create_request
  # @param [Hash] opts the optional parameters
  # @return [PowerFeed]
  describe "dcim_power_feeds_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_feeds_destroy
  # Delete a power feed object.
  # @param id A unique integer value identifying this power feed.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_power_feeds_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_feeds_list
  # Get a list of power feed objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Int32)] :amperage
  # @option opts [Bool] :amperage__empty
  # @option opts [Array(Int32)] :amperage__gt
  # @option opts [Array(Int32)] :amperage__gte
  # @option opts [Array(Int32)] :amperage__lt
  # @option opts [Array(Int32)] :amperage__lte
  # @option opts [Array(Int32)] :amperage__n
  # @option opts [Array(Int32)] :available_power
  # @option opts [Bool] :available_power__empty
  # @option opts [Array(Int32)] :available_power__gt
  # @option opts [Array(Int32)] :available_power__gte
  # @option opts [Array(Int32)] :available_power__lt
  # @option opts [Array(Int32)] :available_power__lte
  # @option opts [Array(Int32)] :available_power__n
  # @option opts [String] :cable_end * &#x60;A&#x60; - A * &#x60;B&#x60; - B
  # @option opts [Array(Int32)] :cable_id Cable (ID)
  # @option opts [Array(Int32)] :cable_id__n Cable (ID)
  # @option opts [Bool] :cabled
  # @option opts [Bool] :connected
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Bool] :mark_connected
  # @option opts [Array(Int32)] :max_utilization
  # @option opts [Bool] :max_utilization__empty
  # @option opts [Array(Int32)] :max_utilization__gt
  # @option opts [Array(Int32)] :max_utilization__gte
  # @option opts [Array(Int32)] :max_utilization__lt
  # @option opts [Array(Int32)] :max_utilization__lte
  # @option opts [Array(Int32)] :max_utilization__n
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Bool] :occupied
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :phase * &#x60;single-phase&#x60; - Single phase * &#x60;three-phase&#x60; - Three-phase
  # @option opts [Array(Int32)] :power_panel_id Power panel (ID)
  # @option opts [Array(Int32)] :power_panel_id__n Power panel (ID)
  # @option opts [String] :q Search
  # @option opts [Array(Int32)] :rack_id Rack (ID)
  # @option opts [Array(Int32)] :rack_id__n Rack (ID)
  # @option opts [Array(String)] :region
  # @option opts [Array(String)] :region__n
  # @option opts [Array(String)] :region_id
  # @option opts [Array(String)] :region_id__n
  # @option opts [Array(String)] :site Site name (slug)
  # @option opts [Array(String)] :site__n Site name (slug)
  # @option opts [Array(String)] :site_group
  # @option opts [Array(String)] :site_group__n
  # @option opts [Array(String)] :site_group_id
  # @option opts [Array(String)] :site_group_id__n
  # @option opts [Array(Int32)] :site_id Site (ID)
  # @option opts [Array(Int32)] :site_id__n Site (ID)
  # @option opts [Array(String)] :status
  # @option opts [Bool] :status__empty
  # @option opts [Array(String)] :status__ic
  # @option opts [Array(String)] :status__ie
  # @option opts [Array(String)] :status__iew
  # @option opts [Array(String)] :status__iregex
  # @option opts [Array(String)] :status__isw
  # @option opts [Array(String)] :status__n
  # @option opts [Array(String)] :status__nic
  # @option opts [Array(String)] :status__nie
  # @option opts [Array(String)] :status__niew
  # @option opts [Array(String)] :status__nisw
  # @option opts [Array(String)] :status__regex
  # @option opts [String] :supply * &#x60;ac&#x60; - AC * &#x60;dc&#x60; - DC
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [Array(String)] :tenant Tenant (slug)
  # @option opts [Array(String)] :tenant__n Tenant (slug)
  # @option opts [Array(String)] :tenant_group
  # @option opts [Array(String)] :tenant_group__n
  # @option opts [Array(String)] :tenant_group_id
  # @option opts [Array(String)] :tenant_group_id__n
  # @option opts [Array(Int32)] :tenant_id Tenant (ID)
  # @option opts [Array(Int32)] :tenant_id__n Tenant (ID)
  # @option opts [String] :_type * &#x60;primary&#x60; - Primary * &#x60;redundant&#x60; - Redundant
  # @option opts [String] :updated_by_request
  # @option opts [Array(Int32)] :voltage
  # @option opts [Bool] :voltage__empty
  # @option opts [Array(Int32)] :voltage__gt
  # @option opts [Array(Int32)] :voltage__gte
  # @option opts [Array(Int32)] :voltage__lt
  # @option opts [Array(Int32)] :voltage__lte
  # @option opts [Array(Int32)] :voltage__n
  # @return [PaginatedPowerFeedList]
  describe "dcim_power_feeds_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_feeds_partial_update
  # Patch a power feed object.
  # @param id A unique integer value identifying this power feed.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritablePowerFeedRequest] :patched_writable_power_feed_request
  # @return [PowerFeed]
  describe "dcim_power_feeds_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_feeds_retrieve
  # Get a power feed object.
  # @param id A unique integer value identifying this power feed.
  # @param [Hash] opts the optional parameters
  # @return [PowerFeed]
  describe "dcim_power_feeds_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_feeds_trace_retrieve
  # Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
  # @param id A unique integer value identifying this power feed.
  # @param [Hash] opts the optional parameters
  # @return [PowerFeed]
  describe "dcim_power_feeds_trace_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_feeds_update
  # Put a power feed object.
  # @param id A unique integer value identifying this power feed.
  # @param writable_power_feed_request
  # @param [Hash] opts the optional parameters
  # @return [PowerFeed]
  describe "dcim_power_feeds_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_outlet_templates_bulk_destroy
  # Delete a list of power outlet template objects.
  # @param power_outlet_template_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_power_outlet_templates_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_outlet_templates_bulk_partial_update
  # Patch a list of power outlet template objects.
  # @param power_outlet_template_request
  # @param [Hash] opts the optional parameters
  # @return [Array(PowerOutletTemplate)]
  describe "dcim_power_outlet_templates_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_outlet_templates_bulk_update
  # Put a list of power outlet template objects.
  # @param power_outlet_template_request
  # @param [Hash] opts the optional parameters
  # @return [Array(PowerOutletTemplate)]
  describe "dcim_power_outlet_templates_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_outlet_templates_create
  # Post a list of power outlet template objects.
  # @param dcim_power_outlet_templates_create_request
  # @param [Hash] opts the optional parameters
  # @return [PowerOutletTemplate]
  describe "dcim_power_outlet_templates_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_outlet_templates_destroy
  # Delete a power outlet template object.
  # @param id A unique integer value identifying this power outlet template.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_power_outlet_templates_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_outlet_templates_list
  # Get a list of power outlet template objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :device_type_id Device type (ID)
  # @option opts [Array(Int32)] :device_type_id__n Device type (ID)
  # @option opts [Array(String)] :feed_leg Phase (for three-phase feeds)
  # @option opts [Bool] :feed_leg__empty
  # @option opts [Array(String)] :feed_leg__ic Phase (for three-phase feeds)
  # @option opts [Array(String)] :feed_leg__ie Phase (for three-phase feeds)
  # @option opts [Array(String)] :feed_leg__iew Phase (for three-phase feeds)
  # @option opts [Array(String)] :feed_leg__iregex Phase (for three-phase feeds)
  # @option opts [Array(String)] :feed_leg__isw Phase (for three-phase feeds)
  # @option opts [Array(String)] :feed_leg__n Phase (for three-phase feeds)
  # @option opts [Array(String)] :feed_leg__nic Phase (for three-phase feeds)
  # @option opts [Array(String)] :feed_leg__nie Phase (for three-phase feeds)
  # @option opts [Array(String)] :feed_leg__niew Phase (for three-phase feeds)
  # @option opts [Array(String)] :feed_leg__nisw Phase (for three-phase feeds)
  # @option opts [Array(String)] :feed_leg__regex Phase (for three-phase feeds)
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :label
  # @option opts [Bool] :label__empty
  # @option opts [Array(String)] :label__ic
  # @option opts [Array(String)] :label__ie
  # @option opts [Array(String)] :label__iew
  # @option opts [Array(String)] :label__iregex
  # @option opts [Array(String)] :label__isw
  # @option opts [Array(String)] :label__n
  # @option opts [Array(String)] :label__nic
  # @option opts [Array(String)] :label__nie
  # @option opts [Array(String)] :label__niew
  # @option opts [Array(String)] :label__nisw
  # @option opts [Array(String)] :label__regex
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [String] :modified_by_request
  # @option opts [Array(Int32)] :module_type_id Module type (ID)
  # @option opts [Array(Int32)] :module_type_id__n Module type (ID)
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Array(Int32)] :power_port_id Power port (ID)
  # @option opts [Array(Int32)] :power_port_id__n Power port (ID)
  # @option opts [String] :q Search
  # @option opts [String] :_type * &#x60;IEC 60320&#x60; - [(&#39;iec-60320-c5&#39;, &#39;C5&#39;), (&#39;iec-60320-c7&#39;, &#39;C7&#39;), (&#39;iec-60320-c13&#39;, &#39;C13&#39;), (&#39;iec-60320-c15&#39;, &#39;C15&#39;), (&#39;iec-60320-c17&#39;, &#39;C17&#39;), (&#39;iec-60320-c19&#39;, &#39;C19&#39;), (&#39;iec-60320-c21&#39;, &#39;C21&#39;)] * &#x60;IEC 60309&#x60; - [(&#39;iec-60309-p-n-e-4h&#39;, &#39;P+N+E 4H&#39;), (&#39;iec-60309-p-n-e-6h&#39;, &#39;P+N+E 6H&#39;), (&#39;iec-60309-p-n-e-9h&#39;, &#39;P+N+E 9H&#39;), (&#39;iec-60309-2p-e-4h&#39;, &#39;2P+E 4H&#39;), (&#39;iec-60309-2p-e-6h&#39;, &#39;2P+E 6H&#39;), (&#39;iec-60309-2p-e-9h&#39;, &#39;2P+E 9H&#39;), (&#39;iec-60309-3p-e-4h&#39;, &#39;3P+E 4H&#39;), (&#39;iec-60309-3p-e-6h&#39;, &#39;3P+E 6H&#39;), (&#39;iec-60309-3p-e-9h&#39;, &#39;3P+E 9H&#39;), (&#39;iec-60309-3p-n-e-4h&#39;, &#39;3P+N+E 4H&#39;), (&#39;iec-60309-3p-n-e-6h&#39;, &#39;3P+N+E 6H&#39;), (&#39;iec-60309-3p-n-e-9h&#39;, &#39;3P+N+E 9H&#39;)] * &#x60;IEC 60906-1&#x60; - [(&#39;iec-60906-1&#39;, &#39;IEC 60906-1&#39;), (&#39;nbr-14136-10a&#39;, &#39;2P+T 10A (NBR 14136)&#39;), (&#39;nbr-14136-20a&#39;, &#39;2P+T 20A (NBR 14136)&#39;)] * &#x60;NEMA (Non-locking)&#x60; - [(&#39;nema-1-15r&#39;, &#39;NEMA 1-15R&#39;), (&#39;nema-5-15r&#39;, &#39;NEMA 5-15R&#39;), (&#39;nema-5-20r&#39;, &#39;NEMA 5-20R&#39;), (&#39;nema-5-30r&#39;, &#39;NEMA 5-30R&#39;), (&#39;nema-5-50r&#39;, &#39;NEMA 5-50R&#39;), (&#39;nema-6-15r&#39;, &#39;NEMA 6-15R&#39;), (&#39;nema-6-20r&#39;, &#39;NEMA 6-20R&#39;), (&#39;nema-6-30r&#39;, &#39;NEMA 6-30R&#39;), (&#39;nema-6-50r&#39;, &#39;NEMA 6-50R&#39;), (&#39;nema-10-30r&#39;, &#39;NEMA 10-30R&#39;), (&#39;nema-10-50r&#39;, &#39;NEMA 10-50R&#39;), (&#39;nema-14-20r&#39;, &#39;NEMA 14-20R&#39;), (&#39;nema-14-30r&#39;, &#39;NEMA 14-30R&#39;), (&#39;nema-14-50r&#39;, &#39;NEMA 14-50R&#39;), (&#39;nema-14-60r&#39;, &#39;NEMA 14-60R&#39;), (&#39;nema-15-15r&#39;, &#39;NEMA 15-15R&#39;), (&#39;nema-15-20r&#39;, &#39;NEMA 15-20R&#39;), (&#39;nema-15-30r&#39;, &#39;NEMA 15-30R&#39;), (&#39;nema-15-50r&#39;, &#39;NEMA 15-50R&#39;), (&#39;nema-15-60r&#39;, &#39;NEMA 15-60R&#39;)] * &#x60;NEMA (Locking)&#x60; - [(&#39;nema-l1-15r&#39;, &#39;NEMA L1-15R&#39;), (&#39;nema-l5-15r&#39;, &#39;NEMA L5-15R&#39;), (&#39;nema-l5-20r&#39;, &#39;NEMA L5-20R&#39;), (&#39;nema-l5-30r&#39;, &#39;NEMA L5-30R&#39;), (&#39;nema-l5-50r&#39;, &#39;NEMA L5-50R&#39;), (&#39;nema-l6-15r&#39;, &#39;NEMA L6-15R&#39;), (&#39;nema-l6-20r&#39;, &#39;NEMA L6-20R&#39;), (&#39;nema-l6-30r&#39;, &#39;NEMA L6-30R&#39;), (&#39;nema-l6-50r&#39;, &#39;NEMA L6-50R&#39;), (&#39;nema-l10-30r&#39;, &#39;NEMA L10-30R&#39;), (&#39;nema-l14-20r&#39;, &#39;NEMA L14-20R&#39;), (&#39;nema-l14-30r&#39;, &#39;NEMA L14-30R&#39;), (&#39;nema-l14-50r&#39;, &#39;NEMA L14-50R&#39;), (&#39;nema-l14-60r&#39;, &#39;NEMA L14-60R&#39;), (&#39;nema-l15-20r&#39;, &#39;NEMA L15-20R&#39;), (&#39;nema-l15-30r&#39;, &#39;NEMA L15-30R&#39;), (&#39;nema-l15-50r&#39;, &#39;NEMA L15-50R&#39;), (&#39;nema-l15-60r&#39;, &#39;NEMA L15-60R&#39;), (&#39;nema-l21-20r&#39;, &#39;NEMA L21-20R&#39;), (&#39;nema-l21-30r&#39;, &#39;NEMA L21-30R&#39;), (&#39;nema-l22-20r&#39;, &#39;NEMA L22-20R&#39;), (&#39;nema-l22-30r&#39;, &#39;NEMA L22-30R&#39;)] * &#x60;California Style&#x60; - [(&#39;CS6360C&#39;, &#39;CS6360C&#39;), (&#39;CS6364C&#39;, &#39;CS6364C&#39;), (&#39;CS8164C&#39;, &#39;CS8164C&#39;), (&#39;CS8264C&#39;, &#39;CS8264C&#39;), (&#39;CS8364C&#39;, &#39;CS8364C&#39;), (&#39;CS8464C&#39;, &#39;CS8464C&#39;)] * &#x60;ITA/International&#x60; - [(&#39;ita-e&#39;, &#39;ITA Type E (CEE 7/5)&#39;), (&#39;ita-f&#39;, &#39;ITA Type F (CEE 7/3)&#39;), (&#39;ita-g&#39;, &#39;ITA Type G (BS 1363)&#39;), (&#39;ita-h&#39;, &#39;ITA Type H&#39;), (&#39;ita-i&#39;, &#39;ITA Type I&#39;), (&#39;ita-j&#39;, &#39;ITA Type J&#39;), (&#39;ita-k&#39;, &#39;ITA Type K&#39;), (&#39;ita-l&#39;, &#39;ITA Type L (CEI 23-50)&#39;), (&#39;ita-m&#39;, &#39;ITA Type M (BS 546)&#39;), (&#39;ita-n&#39;, &#39;ITA Type N&#39;), (&#39;ita-o&#39;, &#39;ITA Type O&#39;), (&#39;ita-multistandard&#39;, &#39;ITA Multistandard&#39;)] * &#x60;USB&#x60; - [(&#39;usb-a&#39;, &#39;USB Type A&#39;), (&#39;usb-micro-b&#39;, &#39;USB Micro B&#39;), (&#39;usb-c&#39;, &#39;USB Type C&#39;)] * &#x60;Molex&#x60; - [(&#39;molex-micro-fit-1x2&#39;, &#39;Molex Micro-Fit 1x2&#39;), (&#39;molex-micro-fit-2x2&#39;, &#39;Molex Micro-Fit 2x2&#39;), (&#39;molex-micro-fit-2x3&#39;, &#39;Molex Micro-Fit 2x3&#39;), (&#39;molex-micro-fit-2x4&#39;, &#39;Molex Micro-Fit 2x4&#39;)] * &#x60;DC&#x60; - [(&#39;dc-terminal&#39;, &#39;DC Terminal&#39;)] * &#x60;Proprietary&#x60; - [(&#39;eaton-c39&#39;, &#39;Eaton C39&#39;), (&#39;hdot-cx&#39;, &#39;HDOT Cx&#39;), (&#39;saf-d-grid&#39;, &#39;Saf-D-Grid&#39;), (&#39;neutrik-powercon-20a&#39;, &#39;Neutrik powerCON (20A)&#39;), (&#39;neutrik-powercon-32a&#39;, &#39;Neutrik powerCON (32A)&#39;), (&#39;neutrik-powercon-true1&#39;, &#39;Neutrik powerCON TRUE1&#39;), (&#39;neutrik-powercon-true1-top&#39;, &#39;Neutrik powerCON TRUE1 TOP&#39;), (&#39;ubiquiti-smartpower&#39;, &#39;Ubiquiti SmartPower&#39;)] * &#x60;Other&#x60; - [(&#39;hardwired&#39;, &#39;Hardwired&#39;), (&#39;other&#39;, &#39;Other&#39;)]
  # @option opts [String] :updated_by_request
  # @return [PaginatedPowerOutletTemplateList]
  describe "dcim_power_outlet_templates_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_outlet_templates_partial_update
  # Patch a power outlet template object.
  # @param id A unique integer value identifying this power outlet template.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritablePowerOutletTemplateRequest] :patched_writable_power_outlet_template_request
  # @return [PowerOutletTemplate]
  describe "dcim_power_outlet_templates_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_outlet_templates_retrieve
  # Get a power outlet template object.
  # @param id A unique integer value identifying this power outlet template.
  # @param [Hash] opts the optional parameters
  # @return [PowerOutletTemplate]
  describe "dcim_power_outlet_templates_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_outlet_templates_update
  # Put a power outlet template object.
  # @param id A unique integer value identifying this power outlet template.
  # @param writable_power_outlet_template_request
  # @param [Hash] opts the optional parameters
  # @return [PowerOutletTemplate]
  describe "dcim_power_outlet_templates_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_outlets_bulk_destroy
  # Delete a list of power outlet objects.
  # @param power_outlet_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_power_outlets_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_outlets_bulk_partial_update
  # Patch a list of power outlet objects.
  # @param power_outlet_request
  # @param [Hash] opts the optional parameters
  # @return [Array(PowerOutlet)]
  describe "dcim_power_outlets_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_outlets_bulk_update
  # Put a list of power outlet objects.
  # @param power_outlet_request
  # @param [Hash] opts the optional parameters
  # @return [Array(PowerOutlet)]
  describe "dcim_power_outlets_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_outlets_create
  # Post a list of power outlet objects.
  # @param dcim_power_outlets_create_request
  # @param [Hash] opts the optional parameters
  # @return [PowerOutlet]
  describe "dcim_power_outlets_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_outlets_destroy
  # Delete a power outlet object.
  # @param id A unique integer value identifying this power outlet.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_power_outlets_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_outlets_list
  # Get a list of power outlet objects.
  # @param [Hash] opts the optional parameters
  # @option opts [String] :cable_end * &#x60;A&#x60; - A * &#x60;B&#x60; - B
  # @option opts [Array(Int32)] :cable_id Cable (ID)
  # @option opts [Array(Int32)] :cable_id__n Cable (ID)
  # @option opts [Bool] :cabled
  # @option opts [Array(String)] :color
  # @option opts [Bool] :color__empty
  # @option opts [Array(String)] :color__ic
  # @option opts [Array(String)] :color__ie
  # @option opts [Array(String)] :color__iew
  # @option opts [Array(String)] :color__iregex
  # @option opts [Array(String)] :color__isw
  # @option opts [Array(String)] :color__n
  # @option opts [Array(String)] :color__nic
  # @option opts [Array(String)] :color__nie
  # @option opts [Array(String)] :color__niew
  # @option opts [Array(String)] :color__nisw
  # @option opts [Array(String)] :color__regex
  # @option opts [Bool] :connected
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(String)] :device Device (name)
  # @option opts [Array(String)] :device__n Device (name)
  # @option opts [Array(Int32)] :device_id Device (ID)
  # @option opts [Array(Int32)] :device_id__n Device (ID)
  # @option opts [Array(String)] :device_role Device role (slug)
  # @option opts [Array(String)] :device_role__n Device role (slug)
  # @option opts [Array(Int32)] :device_role_id Device role (ID)
  # @option opts [Array(Int32)] :device_role_id__n Device role (ID)
  # @option opts [Array(String)] :device_status
  # @option opts [Bool] :device_status__empty
  # @option opts [Array(String)] :device_status__ic
  # @option opts [Array(String)] :device_status__ie
  # @option opts [Array(String)] :device_status__iew
  # @option opts [Array(String)] :device_status__iregex
  # @option opts [Array(String)] :device_status__isw
  # @option opts [Array(String)] :device_status__n
  # @option opts [Array(String)] :device_status__nic
  # @option opts [Array(String)] :device_status__nie
  # @option opts [Array(String)] :device_status__niew
  # @option opts [Array(String)] :device_status__nisw
  # @option opts [Array(String)] :device_status__regex
  # @option opts [Array(String)] :device_type Device type (model)
  # @option opts [Array(String)] :device_type__n Device type (model)
  # @option opts [Array(Int32)] :device_type_id Device type (ID)
  # @option opts [Array(Int32)] :device_type_id__n Device type (ID)
  # @option opts [Array(String)] :feed_leg Phase (for three-phase feeds)
  # @option opts [Bool] :feed_leg__empty
  # @option opts [Array(String)] :feed_leg__ic Phase (for three-phase feeds)
  # @option opts [Array(String)] :feed_leg__ie Phase (for three-phase feeds)
  # @option opts [Array(String)] :feed_leg__iew Phase (for three-phase feeds)
  # @option opts [Array(String)] :feed_leg__iregex Phase (for three-phase feeds)
  # @option opts [Array(String)] :feed_leg__isw Phase (for three-phase feeds)
  # @option opts [Array(String)] :feed_leg__n Phase (for three-phase feeds)
  # @option opts [Array(String)] :feed_leg__nic Phase (for three-phase feeds)
  # @option opts [Array(String)] :feed_leg__nie Phase (for three-phase feeds)
  # @option opts [Array(String)] :feed_leg__niew Phase (for three-phase feeds)
  # @option opts [Array(String)] :feed_leg__nisw Phase (for three-phase feeds)
  # @option opts [Array(String)] :feed_leg__regex Phase (for three-phase feeds)
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :label
  # @option opts [Bool] :label__empty
  # @option opts [Array(String)] :label__ic
  # @option opts [Array(String)] :label__ie
  # @option opts [Array(String)] :label__iew
  # @option opts [Array(String)] :label__iregex
  # @option opts [Array(String)] :label__isw
  # @option opts [Array(String)] :label__n
  # @option opts [Array(String)] :label__nic
  # @option opts [Array(String)] :label__nie
  # @option opts [Array(String)] :label__niew
  # @option opts [Array(String)] :label__nisw
  # @option opts [Array(String)] :label__regex
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(String)] :location Location (slug)
  # @option opts [Array(String)] :location__n Location (slug)
  # @option opts [Array(Int32)] :location_id Location (ID)
  # @option opts [Array(Int32)] :location_id__n Location (ID)
  # @option opts [Bool] :mark_connected
  # @option opts [String] :modified_by_request
  # @option opts [Array(Int32)] :module_id Module (ID)
  # @option opts [Array(Int32)] :module_id__n Module (ID)
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Bool] :occupied
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Array(Int32)] :power_port_id Power port (ID)
  # @option opts [Array(Int32)] :power_port_id__n Power port (ID)
  # @option opts [String] :q Search
  # @option opts [Array(String)] :rack Rack (name)
  # @option opts [Array(String)] :rack__n Rack (name)
  # @option opts [Array(Int32)] :rack_id Rack (ID)
  # @option opts [Array(Int32)] :rack_id__n Rack (ID)
  # @option opts [Array(String)] :region
  # @option opts [Array(String)] :region__n
  # @option opts [Array(String)] :region_id
  # @option opts [Array(String)] :region_id__n
  # @option opts [Array(String)] :site Site name (slug)
  # @option opts [Array(String)] :site__n Site name (slug)
  # @option opts [Array(String)] :site_group
  # @option opts [Array(String)] :site_group__n
  # @option opts [Array(String)] :site_group_id
  # @option opts [Array(String)] :site_group_id__n
  # @option opts [Array(Int32)] :site_id Site (ID)
  # @option opts [Array(Int32)] :site_id__n Site (ID)
  # @option opts [Array(String)] :status
  # @option opts [Bool] :status__empty
  # @option opts [Array(String)] :status__ic
  # @option opts [Array(String)] :status__ie
  # @option opts [Array(String)] :status__iew
  # @option opts [Array(String)] :status__iregex
  # @option opts [Array(String)] :status__isw
  # @option opts [Array(String)] :status__n
  # @option opts [Array(String)] :status__nic
  # @option opts [Array(String)] :status__nie
  # @option opts [Array(String)] :status__niew
  # @option opts [Array(String)] :status__nisw
  # @option opts [Array(String)] :status__regex
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [Array(String)] :tenant Tenant (slug)
  # @option opts [Array(String)] :tenant__n Tenant (slug)
  # @option opts [Array(Int32)] :tenant_id Tenant (ID)
  # @option opts [Array(Int32)] :tenant_id__n Tenant (ID)
  # @option opts [Array(String)] :_type Physical port type
  # @option opts [Bool] :type__empty
  # @option opts [Array(String)] :type__ic Physical port type
  # @option opts [Array(String)] :type__ie Physical port type
  # @option opts [Array(String)] :type__iew Physical port type
  # @option opts [Array(String)] :type__iregex Physical port type
  # @option opts [Array(String)] :type__isw Physical port type
  # @option opts [Array(String)] :type__n Physical port type
  # @option opts [Array(String)] :type__nic Physical port type
  # @option opts [Array(String)] :type__nie Physical port type
  # @option opts [Array(String)] :type__niew Physical port type
  # @option opts [Array(String)] :type__nisw Physical port type
  # @option opts [Array(String)] :type__regex Physical port type
  # @option opts [String] :updated_by_request
  # @option opts [Array(String)] :virtual_chassis Virtual Chassis
  # @option opts [Array(String)] :virtual_chassis__n Virtual Chassis
  # @option opts [Array(Int32)] :virtual_chassis_id Virtual Chassis (ID)
  # @option opts [Array(Int32)] :virtual_chassis_id__n Virtual Chassis (ID)
  # @return [PaginatedPowerOutletList]
  describe "dcim_power_outlets_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_outlets_partial_update
  # Patch a power outlet object.
  # @param id A unique integer value identifying this power outlet.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritablePowerOutletRequest] :patched_writable_power_outlet_request
  # @return [PowerOutlet]
  describe "dcim_power_outlets_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_outlets_retrieve
  # Get a power outlet object.
  # @param id A unique integer value identifying this power outlet.
  # @param [Hash] opts the optional parameters
  # @return [PowerOutlet]
  describe "dcim_power_outlets_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_outlets_trace_retrieve
  # Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
  # @param id A unique integer value identifying this power outlet.
  # @param [Hash] opts the optional parameters
  # @return [PowerOutlet]
  describe "dcim_power_outlets_trace_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_outlets_update
  # Put a power outlet object.
  # @param id A unique integer value identifying this power outlet.
  # @param writable_power_outlet_request
  # @param [Hash] opts the optional parameters
  # @return [PowerOutlet]
  describe "dcim_power_outlets_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_panels_bulk_destroy
  # Delete a list of power panel objects.
  # @param power_panel_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_power_panels_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_panels_bulk_partial_update
  # Patch a list of power panel objects.
  # @param power_panel_request
  # @param [Hash] opts the optional parameters
  # @return [Array(PowerPanel)]
  describe "dcim_power_panels_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_panels_bulk_update
  # Put a list of power panel objects.
  # @param power_panel_request
  # @param [Hash] opts the optional parameters
  # @return [Array(PowerPanel)]
  describe "dcim_power_panels_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_panels_create
  # Post a list of power panel objects.
  # @param dcim_power_panels_create_request
  # @param [Hash] opts the optional parameters
  # @return [PowerPanel]
  describe "dcim_power_panels_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_panels_destroy
  # Delete a power panel object.
  # @param id A unique integer value identifying this power panel.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_power_panels_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_panels_list
  # Get a list of power panel objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Int32)] :contact Contact
  # @option opts [Array(Int32)] :contact__n Contact
  # @option opts [Array(String)] :contact_group
  # @option opts [Array(String)] :contact_group__n
  # @option opts [Array(Int32)] :contact_role Contact Role
  # @option opts [Array(Int32)] :contact_role__n Contact Role
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(String)] :location_id
  # @option opts [Array(String)] :location_id__n
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [Array(String)] :region
  # @option opts [Array(String)] :region__n
  # @option opts [Array(String)] :region_id
  # @option opts [Array(String)] :region_id__n
  # @option opts [Array(String)] :site Site name (slug)
  # @option opts [Array(String)] :site__n Site name (slug)
  # @option opts [Array(String)] :site_group
  # @option opts [Array(String)] :site_group__n
  # @option opts [Array(String)] :site_group_id
  # @option opts [Array(String)] :site_group_id__n
  # @option opts [Array(Int32)] :site_id Site (ID)
  # @option opts [Array(Int32)] :site_id__n Site (ID)
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [String] :updated_by_request
  # @return [PaginatedPowerPanelList]
  describe "dcim_power_panels_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_panels_partial_update
  # Patch a power panel object.
  # @param id A unique integer value identifying this power panel.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedPowerPanelRequest] :patched_power_panel_request
  # @return [PowerPanel]
  describe "dcim_power_panels_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_panels_retrieve
  # Get a power panel object.
  # @param id A unique integer value identifying this power panel.
  # @param [Hash] opts the optional parameters
  # @return [PowerPanel]
  describe "dcim_power_panels_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_panels_update
  # Put a power panel object.
  # @param id A unique integer value identifying this power panel.
  # @param power_panel_request
  # @param [Hash] opts the optional parameters
  # @return [PowerPanel]
  describe "dcim_power_panels_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_port_templates_bulk_destroy
  # Delete a list of power port template objects.
  # @param power_port_template_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_power_port_templates_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_port_templates_bulk_partial_update
  # Patch a list of power port template objects.
  # @param power_port_template_request
  # @param [Hash] opts the optional parameters
  # @return [Array(PowerPortTemplate)]
  describe "dcim_power_port_templates_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_port_templates_bulk_update
  # Put a list of power port template objects.
  # @param power_port_template_request
  # @param [Hash] opts the optional parameters
  # @return [Array(PowerPortTemplate)]
  describe "dcim_power_port_templates_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_port_templates_create
  # Post a list of power port template objects.
  # @param dcim_power_port_templates_create_request
  # @param [Hash] opts the optional parameters
  # @return [PowerPortTemplate]
  describe "dcim_power_port_templates_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_port_templates_destroy
  # Delete a power port template object.
  # @param id A unique integer value identifying this power port template.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_power_port_templates_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_port_templates_list
  # Get a list of power port template objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Int32)] :allocated_draw
  # @option opts [Bool] :allocated_draw__empty
  # @option opts [Array(Int32)] :allocated_draw__gt
  # @option opts [Array(Int32)] :allocated_draw__gte
  # @option opts [Array(Int32)] :allocated_draw__lt
  # @option opts [Array(Int32)] :allocated_draw__lte
  # @option opts [Array(Int32)] :allocated_draw__n
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :device_type_id Device type (ID)
  # @option opts [Array(Int32)] :device_type_id__n Device type (ID)
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :label
  # @option opts [Bool] :label__empty
  # @option opts [Array(String)] :label__ic
  # @option opts [Array(String)] :label__ie
  # @option opts [Array(String)] :label__iew
  # @option opts [Array(String)] :label__iregex
  # @option opts [Array(String)] :label__isw
  # @option opts [Array(String)] :label__n
  # @option opts [Array(String)] :label__nic
  # @option opts [Array(String)] :label__nie
  # @option opts [Array(String)] :label__niew
  # @option opts [Array(String)] :label__nisw
  # @option opts [Array(String)] :label__regex
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(Int32)] :maximum_draw
  # @option opts [Bool] :maximum_draw__empty
  # @option opts [Array(Int32)] :maximum_draw__gt
  # @option opts [Array(Int32)] :maximum_draw__gte
  # @option opts [Array(Int32)] :maximum_draw__lt
  # @option opts [Array(Int32)] :maximum_draw__lte
  # @option opts [Array(Int32)] :maximum_draw__n
  # @option opts [String] :modified_by_request
  # @option opts [Array(Int32)] :module_type_id Module type (ID)
  # @option opts [Array(Int32)] :module_type_id__n Module type (ID)
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [String] :_type * &#x60;IEC 60320&#x60; - [(&#39;iec-60320-c6&#39;, &#39;C6&#39;), (&#39;iec-60320-c8&#39;, &#39;C8&#39;), (&#39;iec-60320-c14&#39;, &#39;C14&#39;), (&#39;iec-60320-c16&#39;, &#39;C16&#39;), (&#39;iec-60320-c18&#39;, &#39;C18&#39;), (&#39;iec-60320-c20&#39;, &#39;C20&#39;), (&#39;iec-60320-c22&#39;, &#39;C22&#39;)] * &#x60;IEC 60309&#x60; - [(&#39;iec-60309-p-n-e-4h&#39;, &#39;P+N+E 4H&#39;), (&#39;iec-60309-p-n-e-6h&#39;, &#39;P+N+E 6H&#39;), (&#39;iec-60309-p-n-e-9h&#39;, &#39;P+N+E 9H&#39;), (&#39;iec-60309-2p-e-4h&#39;, &#39;2P+E 4H&#39;), (&#39;iec-60309-2p-e-6h&#39;, &#39;2P+E 6H&#39;), (&#39;iec-60309-2p-e-9h&#39;, &#39;2P+E 9H&#39;), (&#39;iec-60309-3p-e-4h&#39;, &#39;3P+E 4H&#39;), (&#39;iec-60309-3p-e-6h&#39;, &#39;3P+E 6H&#39;), (&#39;iec-60309-3p-e-9h&#39;, &#39;3P+E 9H&#39;), (&#39;iec-60309-3p-n-e-4h&#39;, &#39;3P+N+E 4H&#39;), (&#39;iec-60309-3p-n-e-6h&#39;, &#39;3P+N+E 6H&#39;), (&#39;iec-60309-3p-n-e-9h&#39;, &#39;3P+N+E 9H&#39;)] * &#x60;IEC 60906-1&#x60; - [(&#39;iec-60906-1&#39;, &#39;IEC 60906-1&#39;), (&#39;nbr-14136-10a&#39;, &#39;2P+T 10A (NBR 14136)&#39;), (&#39;nbr-14136-20a&#39;, &#39;2P+T 20A (NBR 14136)&#39;)] * &#x60;NEMA (Non-locking)&#x60; - [(&#39;nema-1-15p&#39;, &#39;NEMA 1-15P&#39;), (&#39;nema-5-15p&#39;, &#39;NEMA 5-15P&#39;), (&#39;nema-5-20p&#39;, &#39;NEMA 5-20P&#39;), (&#39;nema-5-30p&#39;, &#39;NEMA 5-30P&#39;), (&#39;nema-5-50p&#39;, &#39;NEMA 5-50P&#39;), (&#39;nema-6-15p&#39;, &#39;NEMA 6-15P&#39;), (&#39;nema-6-20p&#39;, &#39;NEMA 6-20P&#39;), (&#39;nema-6-30p&#39;, &#39;NEMA 6-30P&#39;), (&#39;nema-6-50p&#39;, &#39;NEMA 6-50P&#39;), (&#39;nema-10-30p&#39;, &#39;NEMA 10-30P&#39;), (&#39;nema-10-50p&#39;, &#39;NEMA 10-50P&#39;), (&#39;nema-14-20p&#39;, &#39;NEMA 14-20P&#39;), (&#39;nema-14-30p&#39;, &#39;NEMA 14-30P&#39;), (&#39;nema-14-50p&#39;, &#39;NEMA 14-50P&#39;), (&#39;nema-14-60p&#39;, &#39;NEMA 14-60P&#39;), (&#39;nema-15-15p&#39;, &#39;NEMA 15-15P&#39;), (&#39;nema-15-20p&#39;, &#39;NEMA 15-20P&#39;), (&#39;nema-15-30p&#39;, &#39;NEMA 15-30P&#39;), (&#39;nema-15-50p&#39;, &#39;NEMA 15-50P&#39;), (&#39;nema-15-60p&#39;, &#39;NEMA 15-60P&#39;)] * &#x60;NEMA (Locking)&#x60; - [(&#39;nema-l1-15p&#39;, &#39;NEMA L1-15P&#39;), (&#39;nema-l5-15p&#39;, &#39;NEMA L5-15P&#39;), (&#39;nema-l5-20p&#39;, &#39;NEMA L5-20P&#39;), (&#39;nema-l5-30p&#39;, &#39;NEMA L5-30P&#39;), (&#39;nema-l5-50p&#39;, &#39;NEMA L5-50P&#39;), (&#39;nema-l6-15p&#39;, &#39;NEMA L6-15P&#39;), (&#39;nema-l6-20p&#39;, &#39;NEMA L6-20P&#39;), (&#39;nema-l6-30p&#39;, &#39;NEMA L6-30P&#39;), (&#39;nema-l6-50p&#39;, &#39;NEMA L6-50P&#39;), (&#39;nema-l10-30p&#39;, &#39;NEMA L10-30P&#39;), (&#39;nema-l14-20p&#39;, &#39;NEMA L14-20P&#39;), (&#39;nema-l14-30p&#39;, &#39;NEMA L14-30P&#39;), (&#39;nema-l14-50p&#39;, &#39;NEMA L14-50P&#39;), (&#39;nema-l14-60p&#39;, &#39;NEMA L14-60P&#39;), (&#39;nema-l15-20p&#39;, &#39;NEMA L15-20P&#39;), (&#39;nema-l15-30p&#39;, &#39;NEMA L15-30P&#39;), (&#39;nema-l15-50p&#39;, &#39;NEMA L15-50P&#39;), (&#39;nema-l15-60p&#39;, &#39;NEMA L15-60P&#39;), (&#39;nema-l21-20p&#39;, &#39;NEMA L21-20P&#39;), (&#39;nema-l21-30p&#39;, &#39;NEMA L21-30P&#39;), (&#39;nema-l22-20p&#39;, &#39;NEMA L22-20P&#39;), (&#39;nema-l22-30p&#39;, &#39;NEMA L22-30P&#39;)] * &#x60;California Style&#x60; - [(&#39;cs6361c&#39;, &#39;CS6361C&#39;), (&#39;cs6365c&#39;, &#39;CS6365C&#39;), (&#39;cs8165c&#39;, &#39;CS8165C&#39;), (&#39;cs8265c&#39;, &#39;CS8265C&#39;), (&#39;cs8365c&#39;, &#39;CS8365C&#39;), (&#39;cs8465c&#39;, &#39;CS8465C&#39;)] * &#x60;International/ITA&#x60; - [(&#39;ita-c&#39;, &#39;ITA Type C (CEE 7/16)&#39;), (&#39;ita-e&#39;, &#39;ITA Type E (CEE 7/6)&#39;), (&#39;ita-f&#39;, &#39;ITA Type F (CEE 7/4)&#39;), (&#39;ita-ef&#39;, &#39;ITA Type E/F (CEE 7/7)&#39;), (&#39;ita-g&#39;, &#39;ITA Type G (BS 1363)&#39;), (&#39;ita-h&#39;, &#39;ITA Type H&#39;), (&#39;ita-i&#39;, &#39;ITA Type I&#39;), (&#39;ita-j&#39;, &#39;ITA Type J&#39;), (&#39;ita-k&#39;, &#39;ITA Type K&#39;), (&#39;ita-l&#39;, &#39;ITA Type L (CEI 23-50)&#39;), (&#39;ita-m&#39;, &#39;ITA Type M (BS 546)&#39;), (&#39;ita-n&#39;, &#39;ITA Type N&#39;), (&#39;ita-o&#39;, &#39;ITA Type O&#39;)] * &#x60;USB&#x60; - [(&#39;usb-a&#39;, &#39;USB Type A&#39;), (&#39;usb-b&#39;, &#39;USB Type B&#39;), (&#39;usb-c&#39;, &#39;USB Type C&#39;), (&#39;usb-mini-a&#39;, &#39;USB Mini A&#39;), (&#39;usb-mini-b&#39;, &#39;USB Mini B&#39;), (&#39;usb-micro-a&#39;, &#39;USB Micro A&#39;), (&#39;usb-micro-b&#39;, &#39;USB Micro B&#39;), (&#39;usb-micro-ab&#39;, &#39;USB Micro AB&#39;), (&#39;usb-3-b&#39;, &#39;USB 3.0 Type B&#39;), (&#39;usb-3-micro-b&#39;, &#39;USB 3.0 Micro B&#39;)] * &#x60;Molex&#x60; - [(&#39;molex-micro-fit-1x2&#39;, &#39;Molex Micro-Fit 1x2&#39;), (&#39;molex-micro-fit-2x2&#39;, &#39;Molex Micro-Fit 2x2&#39;), (&#39;molex-micro-fit-2x3&#39;, &#39;Molex Micro-Fit 2x3&#39;), (&#39;molex-micro-fit-2x4&#39;, &#39;Molex Micro-Fit 2x4&#39;)] * &#x60;DC&#x60; - [(&#39;dc-terminal&#39;, &#39;DC Terminal&#39;)] * &#x60;Proprietary&#x60; - [(&#39;saf-d-grid&#39;, &#39;Saf-D-Grid&#39;), (&#39;neutrik-powercon-20&#39;, &#39;Neutrik powerCON (20A)&#39;), (&#39;neutrik-powercon-32&#39;, &#39;Neutrik powerCON (32A)&#39;), (&#39;neutrik-powercon-true1&#39;, &#39;Neutrik powerCON TRUE1&#39;), (&#39;neutrik-powercon-true1-top&#39;, &#39;Neutrik powerCON TRUE1 TOP&#39;), (&#39;ubiquiti-smartpower&#39;, &#39;Ubiquiti SmartPower&#39;)] * &#x60;Other&#x60; - [(&#39;hardwired&#39;, &#39;Hardwired&#39;), (&#39;other&#39;, &#39;Other&#39;)]
  # @option opts [String] :updated_by_request
  # @return [PaginatedPowerPortTemplateList]
  describe "dcim_power_port_templates_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_port_templates_partial_update
  # Patch a power port template object.
  # @param id A unique integer value identifying this power port template.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritablePowerPortTemplateRequest] :patched_writable_power_port_template_request
  # @return [PowerPortTemplate]
  describe "dcim_power_port_templates_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_port_templates_retrieve
  # Get a power port template object.
  # @param id A unique integer value identifying this power port template.
  # @param [Hash] opts the optional parameters
  # @return [PowerPortTemplate]
  describe "dcim_power_port_templates_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_port_templates_update
  # Put a power port template object.
  # @param id A unique integer value identifying this power port template.
  # @param writable_power_port_template_request
  # @param [Hash] opts the optional parameters
  # @return [PowerPortTemplate]
  describe "dcim_power_port_templates_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_ports_bulk_destroy
  # Delete a list of power port objects.
  # @param power_port_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_power_ports_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_ports_bulk_partial_update
  # Patch a list of power port objects.
  # @param power_port_request
  # @param [Hash] opts the optional parameters
  # @return [Array(PowerPort)]
  describe "dcim_power_ports_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_ports_bulk_update
  # Put a list of power port objects.
  # @param power_port_request
  # @param [Hash] opts the optional parameters
  # @return [Array(PowerPort)]
  describe "dcim_power_ports_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_ports_create
  # Post a list of power port objects.
  # @param dcim_power_ports_create_request
  # @param [Hash] opts the optional parameters
  # @return [PowerPort]
  describe "dcim_power_ports_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_ports_destroy
  # Delete a power port object.
  # @param id A unique integer value identifying this power port.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_power_ports_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_ports_list
  # Get a list of power port objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Int32)] :allocated_draw
  # @option opts [Bool] :allocated_draw__empty
  # @option opts [Array(Int32)] :allocated_draw__gt
  # @option opts [Array(Int32)] :allocated_draw__gte
  # @option opts [Array(Int32)] :allocated_draw__lt
  # @option opts [Array(Int32)] :allocated_draw__lte
  # @option opts [Array(Int32)] :allocated_draw__n
  # @option opts [String] :cable_end * &#x60;A&#x60; - A * &#x60;B&#x60; - B
  # @option opts [Array(Int32)] :cable_id Cable (ID)
  # @option opts [Array(Int32)] :cable_id__n Cable (ID)
  # @option opts [Bool] :cabled
  # @option opts [Bool] :connected
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(String)] :device Device (name)
  # @option opts [Array(String)] :device__n Device (name)
  # @option opts [Array(Int32)] :device_id Device (ID)
  # @option opts [Array(Int32)] :device_id__n Device (ID)
  # @option opts [Array(String)] :device_role Device role (slug)
  # @option opts [Array(String)] :device_role__n Device role (slug)
  # @option opts [Array(Int32)] :device_role_id Device role (ID)
  # @option opts [Array(Int32)] :device_role_id__n Device role (ID)
  # @option opts [Array(String)] :device_status
  # @option opts [Bool] :device_status__empty
  # @option opts [Array(String)] :device_status__ic
  # @option opts [Array(String)] :device_status__ie
  # @option opts [Array(String)] :device_status__iew
  # @option opts [Array(String)] :device_status__iregex
  # @option opts [Array(String)] :device_status__isw
  # @option opts [Array(String)] :device_status__n
  # @option opts [Array(String)] :device_status__nic
  # @option opts [Array(String)] :device_status__nie
  # @option opts [Array(String)] :device_status__niew
  # @option opts [Array(String)] :device_status__nisw
  # @option opts [Array(String)] :device_status__regex
  # @option opts [Array(String)] :device_type Device type (model)
  # @option opts [Array(String)] :device_type__n Device type (model)
  # @option opts [Array(Int32)] :device_type_id Device type (ID)
  # @option opts [Array(Int32)] :device_type_id__n Device type (ID)
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :label
  # @option opts [Bool] :label__empty
  # @option opts [Array(String)] :label__ic
  # @option opts [Array(String)] :label__ie
  # @option opts [Array(String)] :label__iew
  # @option opts [Array(String)] :label__iregex
  # @option opts [Array(String)] :label__isw
  # @option opts [Array(String)] :label__n
  # @option opts [Array(String)] :label__nic
  # @option opts [Array(String)] :label__nie
  # @option opts [Array(String)] :label__niew
  # @option opts [Array(String)] :label__nisw
  # @option opts [Array(String)] :label__regex
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(String)] :location Location (slug)
  # @option opts [Array(String)] :location__n Location (slug)
  # @option opts [Array(Int32)] :location_id Location (ID)
  # @option opts [Array(Int32)] :location_id__n Location (ID)
  # @option opts [Bool] :mark_connected
  # @option opts [Array(Int32)] :maximum_draw
  # @option opts [Bool] :maximum_draw__empty
  # @option opts [Array(Int32)] :maximum_draw__gt
  # @option opts [Array(Int32)] :maximum_draw__gte
  # @option opts [Array(Int32)] :maximum_draw__lt
  # @option opts [Array(Int32)] :maximum_draw__lte
  # @option opts [Array(Int32)] :maximum_draw__n
  # @option opts [String] :modified_by_request
  # @option opts [Array(Int32)] :module_id Module (ID)
  # @option opts [Array(Int32)] :module_id__n Module (ID)
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Bool] :occupied
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [Array(String)] :rack Rack (name)
  # @option opts [Array(String)] :rack__n Rack (name)
  # @option opts [Array(Int32)] :rack_id Rack (ID)
  # @option opts [Array(Int32)] :rack_id__n Rack (ID)
  # @option opts [Array(String)] :region
  # @option opts [Array(String)] :region__n
  # @option opts [Array(String)] :region_id
  # @option opts [Array(String)] :region_id__n
  # @option opts [Array(String)] :site Site name (slug)
  # @option opts [Array(String)] :site__n Site name (slug)
  # @option opts [Array(String)] :site_group
  # @option opts [Array(String)] :site_group__n
  # @option opts [Array(String)] :site_group_id
  # @option opts [Array(String)] :site_group_id__n
  # @option opts [Array(Int32)] :site_id Site (ID)
  # @option opts [Array(Int32)] :site_id__n Site (ID)
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [Array(String)] :tenant Tenant (slug)
  # @option opts [Array(String)] :tenant__n Tenant (slug)
  # @option opts [Array(Int32)] :tenant_id Tenant (ID)
  # @option opts [Array(Int32)] :tenant_id__n Tenant (ID)
  # @option opts [Array(String)] :_type Physical port type
  # @option opts [Bool] :type__empty
  # @option opts [Array(String)] :type__ic Physical port type
  # @option opts [Array(String)] :type__ie Physical port type
  # @option opts [Array(String)] :type__iew Physical port type
  # @option opts [Array(String)] :type__iregex Physical port type
  # @option opts [Array(String)] :type__isw Physical port type
  # @option opts [Array(String)] :type__n Physical port type
  # @option opts [Array(String)] :type__nic Physical port type
  # @option opts [Array(String)] :type__nie Physical port type
  # @option opts [Array(String)] :type__niew Physical port type
  # @option opts [Array(String)] :type__nisw Physical port type
  # @option opts [Array(String)] :type__regex Physical port type
  # @option opts [String] :updated_by_request
  # @option opts [Array(String)] :virtual_chassis Virtual Chassis
  # @option opts [Array(String)] :virtual_chassis__n Virtual Chassis
  # @option opts [Array(Int32)] :virtual_chassis_id Virtual Chassis (ID)
  # @option opts [Array(Int32)] :virtual_chassis_id__n Virtual Chassis (ID)
  # @return [PaginatedPowerPortList]
  describe "dcim_power_ports_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_ports_partial_update
  # Patch a power port object.
  # @param id A unique integer value identifying this power port.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritablePowerPortRequest] :patched_writable_power_port_request
  # @return [PowerPort]
  describe "dcim_power_ports_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_ports_retrieve
  # Get a power port object.
  # @param id A unique integer value identifying this power port.
  # @param [Hash] opts the optional parameters
  # @return [PowerPort]
  describe "dcim_power_ports_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_ports_trace_retrieve
  # Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
  # @param id A unique integer value identifying this power port.
  # @param [Hash] opts the optional parameters
  # @return [PowerPort]
  describe "dcim_power_ports_trace_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_power_ports_update
  # Put a power port object.
  # @param id A unique integer value identifying this power port.
  # @param writable_power_port_request
  # @param [Hash] opts the optional parameters
  # @return [PowerPort]
  describe "dcim_power_ports_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_reservations_bulk_destroy
  # Delete a list of rack reservation objects.
  # @param rack_reservation_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_rack_reservations_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_reservations_bulk_partial_update
  # Patch a list of rack reservation objects.
  # @param rack_reservation_request
  # @param [Hash] opts the optional parameters
  # @return [Array(RackReservation)]
  describe "dcim_rack_reservations_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_reservations_bulk_update
  # Put a list of rack reservation objects.
  # @param rack_reservation_request
  # @param [Hash] opts the optional parameters
  # @return [Array(RackReservation)]
  describe "dcim_rack_reservations_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_reservations_create
  # Post a list of rack reservation objects.
  # @param dcim_rack_reservations_create_request
  # @param [Hash] opts the optional parameters
  # @return [RackReservation]
  describe "dcim_rack_reservations_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_reservations_destroy
  # Delete a rack reservation object.
  # @param id A unique integer value identifying this rack reservation.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_rack_reservations_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_reservations_list
  # Get a list of rack reservation objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(String)] :location
  # @option opts [Array(String)] :location__n
  # @option opts [Array(String)] :location_id
  # @option opts [Array(String)] :location_id__n
  # @option opts [String] :modified_by_request
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [Array(Int32)] :rack_id Rack (ID)
  # @option opts [Array(Int32)] :rack_id__n Rack (ID)
  # @option opts [Array(String)] :region
  # @option opts [Array(String)] :region__n
  # @option opts [Array(String)] :region_id
  # @option opts [Array(String)] :region_id__n
  # @option opts [Array(String)] :site Site (slug)
  # @option opts [Array(String)] :site__n Site (slug)
  # @option opts [Array(String)] :site_group
  # @option opts [Array(String)] :site_group__n
  # @option opts [Array(String)] :site_group_id
  # @option opts [Array(String)] :site_group_id__n
  # @option opts [Array(Int32)] :site_id Site (ID)
  # @option opts [Array(Int32)] :site_id__n Site (ID)
  # @option opts [Array(String)] :status
  # @option opts [Bool] :status__empty
  # @option opts [Array(String)] :status__ic
  # @option opts [Array(String)] :status__ie
  # @option opts [Array(String)] :status__iew
  # @option opts [Array(String)] :status__iregex
  # @option opts [Array(String)] :status__isw
  # @option opts [Array(String)] :status__n
  # @option opts [Array(String)] :status__nic
  # @option opts [Array(String)] :status__nie
  # @option opts [Array(String)] :status__niew
  # @option opts [Array(String)] :status__nisw
  # @option opts [Array(String)] :status__regex
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [Array(String)] :tenant Tenant (slug)
  # @option opts [Array(String)] :tenant__n Tenant (slug)
  # @option opts [Array(String)] :tenant_group
  # @option opts [Array(String)] :tenant_group__n
  # @option opts [Array(String)] :tenant_group_id
  # @option opts [Array(String)] :tenant_group_id__n
  # @option opts [Array(Int32)] :tenant_id Tenant (ID)
  # @option opts [Array(Int32)] :tenant_id__n Tenant (ID)
  # @option opts [Float64] :unit
  # @option opts [Float64] :unit__empty
  # @option opts [Float64] :unit__gt
  # @option opts [Float64] :unit__gte
  # @option opts [Float64] :unit__lt
  # @option opts [Float64] :unit__lte
  # @option opts [Float64] :unit__n
  # @option opts [String] :updated_by_request
  # @option opts [Array(String)] :user User (name)
  # @option opts [Array(String)] :user__n User (name)
  # @option opts [Array(Int32)] :user_id User (ID)
  # @option opts [Array(Int32)] :user_id__n User (ID)
  # @return [PaginatedRackReservationList]
  describe "dcim_rack_reservations_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_reservations_partial_update
  # Patch a rack reservation object.
  # @param id A unique integer value identifying this rack reservation.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableRackReservationRequest] :patched_writable_rack_reservation_request
  # @return [RackReservation]
  describe "dcim_rack_reservations_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_reservations_retrieve
  # Get a rack reservation object.
  # @param id A unique integer value identifying this rack reservation.
  # @param [Hash] opts the optional parameters
  # @return [RackReservation]
  describe "dcim_rack_reservations_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_reservations_update
  # Put a rack reservation object.
  # @param id A unique integer value identifying this rack reservation.
  # @param writable_rack_reservation_request
  # @param [Hash] opts the optional parameters
  # @return [RackReservation]
  describe "dcim_rack_reservations_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_roles_bulk_destroy
  # Delete a list of rack role objects.
  # @param rack_role_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_rack_roles_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_roles_bulk_partial_update
  # Patch a list of rack role objects.
  # @param rack_role_request
  # @param [Hash] opts the optional parameters
  # @return [Array(RackRole)]
  describe "dcim_rack_roles_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_roles_bulk_update
  # Put a list of rack role objects.
  # @param rack_role_request
  # @param [Hash] opts the optional parameters
  # @return [Array(RackRole)]
  describe "dcim_rack_roles_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_roles_create
  # Post a list of rack role objects.
  # @param dcim_rack_roles_create_request
  # @param [Hash] opts the optional parameters
  # @return [RackRole]
  describe "dcim_rack_roles_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_roles_destroy
  # Delete a rack role object.
  # @param id A unique integer value identifying this rack role.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_rack_roles_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_roles_list
  # Get a list of rack role objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(String)] :color
  # @option opts [Bool] :color__empty
  # @option opts [Array(String)] :color__ic
  # @option opts [Array(String)] :color__ie
  # @option opts [Array(String)] :color__iew
  # @option opts [Array(String)] :color__iregex
  # @option opts [Array(String)] :color__isw
  # @option opts [Array(String)] :color__n
  # @option opts [Array(String)] :color__nic
  # @option opts [Array(String)] :color__nie
  # @option opts [Array(String)] :color__niew
  # @option opts [Array(String)] :color__nisw
  # @option opts [Array(String)] :color__regex
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [Array(String)] :slug
  # @option opts [Bool] :slug__empty
  # @option opts [Array(String)] :slug__ic
  # @option opts [Array(String)] :slug__ie
  # @option opts [Array(String)] :slug__iew
  # @option opts [Array(String)] :slug__iregex
  # @option opts [Array(String)] :slug__isw
  # @option opts [Array(String)] :slug__n
  # @option opts [Array(String)] :slug__nic
  # @option opts [Array(String)] :slug__nie
  # @option opts [Array(String)] :slug__niew
  # @option opts [Array(String)] :slug__nisw
  # @option opts [Array(String)] :slug__regex
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [String] :updated_by_request
  # @return [PaginatedRackRoleList]
  describe "dcim_rack_roles_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_roles_partial_update
  # Patch a rack role object.
  # @param id A unique integer value identifying this rack role.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedRackRoleRequest] :patched_rack_role_request
  # @return [RackRole]
  describe "dcim_rack_roles_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_roles_retrieve
  # Get a rack role object.
  # @param id A unique integer value identifying this rack role.
  # @param [Hash] opts the optional parameters
  # @return [RackRole]
  describe "dcim_rack_roles_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_roles_update
  # Put a rack role object.
  # @param id A unique integer value identifying this rack role.
  # @param rack_role_request
  # @param [Hash] opts the optional parameters
  # @return [RackRole]
  describe "dcim_rack_roles_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_types_bulk_destroy
  # Delete a list of rack type objects.
  # @param rack_type_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_rack_types_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_types_bulk_partial_update
  # Patch a list of rack type objects.
  # @param rack_type_request
  # @param [Hash] opts the optional parameters
  # @return [Array(RackType)]
  describe "dcim_rack_types_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_types_bulk_update
  # Put a list of rack type objects.
  # @param rack_type_request
  # @param [Hash] opts the optional parameters
  # @return [Array(RackType)]
  describe "dcim_rack_types_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_types_create
  # Post a list of rack type objects.
  # @param dcim_rack_types_create_request
  # @param [Hash] opts the optional parameters
  # @return [RackType]
  describe "dcim_rack_types_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_types_destroy
  # Delete a rack type object.
  # @param id A unique integer value identifying this rack type.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_rack_types_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_types_list
  # Get a list of rack type objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Bool] :desc_units
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(String)] :form_factor
  # @option opts [Bool] :form_factor__empty
  # @option opts [Array(String)] :form_factor__ic
  # @option opts [Array(String)] :form_factor__ie
  # @option opts [Array(String)] :form_factor__iew
  # @option opts [Array(String)] :form_factor__iregex
  # @option opts [Array(String)] :form_factor__isw
  # @option opts [Array(String)] :form_factor__n
  # @option opts [Array(String)] :form_factor__nic
  # @option opts [Array(String)] :form_factor__nie
  # @option opts [Array(String)] :form_factor__niew
  # @option opts [Array(String)] :form_factor__nisw
  # @option opts [Array(String)] :form_factor__regex
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(String)] :manufacturer Manufacturer (slug)
  # @option opts [Array(String)] :manufacturer__n Manufacturer (slug)
  # @option opts [Array(Int32)] :manufacturer_id Manufacturer (ID)
  # @option opts [Array(Int32)] :manufacturer_id__n Manufacturer (ID)
  # @option opts [Array(Int32)] :max_weight
  # @option opts [Bool] :max_weight__empty
  # @option opts [Array(Int32)] :max_weight__gt
  # @option opts [Array(Int32)] :max_weight__gte
  # @option opts [Array(Int32)] :max_weight__lt
  # @option opts [Array(Int32)] :max_weight__lte
  # @option opts [Array(Int32)] :max_weight__n
  # @option opts [Array(String)] :model
  # @option opts [Bool] :model__empty
  # @option opts [Array(String)] :model__ic
  # @option opts [Array(String)] :model__ie
  # @option opts [Array(String)] :model__iew
  # @option opts [Array(String)] :model__iregex
  # @option opts [Array(String)] :model__isw
  # @option opts [Array(String)] :model__n
  # @option opts [Array(String)] :model__nic
  # @option opts [Array(String)] :model__nie
  # @option opts [Array(String)] :model__niew
  # @option opts [Array(String)] :model__nisw
  # @option opts [Array(String)] :model__regex
  # @option opts [String] :modified_by_request
  # @option opts [Array(Int32)] :mounting_depth
  # @option opts [Bool] :mounting_depth__empty
  # @option opts [Array(Int32)] :mounting_depth__gt
  # @option opts [Array(Int32)] :mounting_depth__gte
  # @option opts [Array(Int32)] :mounting_depth__lt
  # @option opts [Array(Int32)] :mounting_depth__lte
  # @option opts [Array(Int32)] :mounting_depth__n
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Array(Int32)] :outer_depth
  # @option opts [Bool] :outer_depth__empty
  # @option opts [Array(Int32)] :outer_depth__gt
  # @option opts [Array(Int32)] :outer_depth__gte
  # @option opts [Array(Int32)] :outer_depth__lt
  # @option opts [Array(Int32)] :outer_depth__lte
  # @option opts [Array(Int32)] :outer_depth__n
  # @option opts [Array(Int32)] :outer_height
  # @option opts [Bool] :outer_height__empty
  # @option opts [Array(Int32)] :outer_height__gt
  # @option opts [Array(Int32)] :outer_height__gte
  # @option opts [Array(Int32)] :outer_height__lt
  # @option opts [Array(Int32)] :outer_height__lte
  # @option opts [Array(Int32)] :outer_height__n
  # @option opts [String] :outer_unit * &#x60;mm&#x60; - Millimeters * &#x60;in&#x60; - Inches
  # @option opts [Array(Int32)] :outer_width
  # @option opts [Bool] :outer_width__empty
  # @option opts [Array(Int32)] :outer_width__gt
  # @option opts [Array(Int32)] :outer_width__gte
  # @option opts [Array(Int32)] :outer_width__lt
  # @option opts [Array(Int32)] :outer_width__lte
  # @option opts [Array(Int32)] :outer_width__n
  # @option opts [String] :q Search
  # @option opts [Array(String)] :slug
  # @option opts [Bool] :slug__empty
  # @option opts [Array(String)] :slug__ic
  # @option opts [Array(String)] :slug__ie
  # @option opts [Array(String)] :slug__iew
  # @option opts [Array(String)] :slug__iregex
  # @option opts [Array(String)] :slug__isw
  # @option opts [Array(String)] :slug__n
  # @option opts [Array(String)] :slug__nic
  # @option opts [Array(String)] :slug__nie
  # @option opts [Array(String)] :slug__niew
  # @option opts [Array(String)] :slug__nisw
  # @option opts [Array(String)] :slug__regex
  # @option opts [Array(Int32)] :starting_unit
  # @option opts [Bool] :starting_unit__empty
  # @option opts [Array(Int32)] :starting_unit__gt
  # @option opts [Array(Int32)] :starting_unit__gte
  # @option opts [Array(Int32)] :starting_unit__lt
  # @option opts [Array(Int32)] :starting_unit__lte
  # @option opts [Array(Int32)] :starting_unit__n
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [Array(Int32)] :u_height
  # @option opts [Bool] :u_height__empty
  # @option opts [Array(Int32)] :u_height__gt
  # @option opts [Array(Int32)] :u_height__gte
  # @option opts [Array(Int32)] :u_height__lt
  # @option opts [Array(Int32)] :u_height__lte
  # @option opts [Array(Int32)] :u_height__n
  # @option opts [String] :updated_by_request
  # @option opts [Array(Float64)] :weight
  # @option opts [Bool] :weight__empty
  # @option opts [Array(Float64)] :weight__gt
  # @option opts [Array(Float64)] :weight__gte
  # @option opts [Array(Float64)] :weight__lt
  # @option opts [Array(Float64)] :weight__lte
  # @option opts [Array(Float64)] :weight__n
  # @option opts [String] :weight_unit * &#x60;kg&#x60; - Kilograms * &#x60;g&#x60; - Grams * &#x60;lb&#x60; - Pounds * &#x60;oz&#x60; - Ounces
  # @option opts [Array(Int32)] :width Rail-to-rail width
  # @option opts [Array(Int32)] :width__ic Rail-to-rail width
  # @option opts [Array(Int32)] :width__ie Rail-to-rail width
  # @option opts [Array(Int32)] :width__iew Rail-to-rail width
  # @option opts [Array(Int32)] :width__iregex Rail-to-rail width
  # @option opts [Array(Int32)] :width__isw Rail-to-rail width
  # @option opts [Array(Int32)] :width__n Rail-to-rail width
  # @option opts [Array(Int32)] :width__nic Rail-to-rail width
  # @option opts [Array(Int32)] :width__nie Rail-to-rail width
  # @option opts [Array(Int32)] :width__niew Rail-to-rail width
  # @option opts [Array(Int32)] :width__nisw Rail-to-rail width
  # @option opts [Array(Int32)] :width__regex Rail-to-rail width
  # @return [PaginatedRackTypeList]
  describe "dcim_rack_types_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_types_partial_update
  # Patch a rack type object.
  # @param id A unique integer value identifying this rack type.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableRackTypeRequest] :patched_writable_rack_type_request
  # @return [RackType]
  describe "dcim_rack_types_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_types_retrieve
  # Get a rack type object.
  # @param id A unique integer value identifying this rack type.
  # @param [Hash] opts the optional parameters
  # @return [RackType]
  describe "dcim_rack_types_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rack_types_update
  # Put a rack type object.
  # @param id A unique integer value identifying this rack type.
  # @param writable_rack_type_request
  # @param [Hash] opts the optional parameters
  # @return [RackType]
  describe "dcim_rack_types_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_racks_bulk_destroy
  # Delete a list of rack objects.
  # @param rack_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_racks_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_racks_bulk_partial_update
  # Patch a list of rack objects.
  # @param rack_request
  # @param [Hash] opts the optional parameters
  # @return [Array(Rack)]
  describe "dcim_racks_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_racks_bulk_update
  # Put a list of rack objects.
  # @param rack_request
  # @param [Hash] opts the optional parameters
  # @return [Array(Rack)]
  describe "dcim_racks_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_racks_create
  # Post a list of rack objects.
  # @param dcim_racks_create_request
  # @param [Hash] opts the optional parameters
  # @return [Rack]
  describe "dcim_racks_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_racks_destroy
  # Delete a rack object.
  # @param id A unique integer value identifying this rack.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_racks_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_racks_elevation_retrieve
  # Rack elevation representing the list of rack units. Also supports rendering the elevation as an SVG.
  # @param id A unique integer value identifying this rack.
  # @param [Hash] opts the optional parameters
  # @option opts [Int32] :exclude
  # @option opts [Bool] :expand_devices
  # @option opts [String] :face * &#x60;front&#x60; - Front * &#x60;rear&#x60; - Rear
  # @option opts [Bool] :include_images
  # @option opts [Int32] :legend_width
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Int32] :margin_width
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :q
  # @option opts [String] :render * &#x60;json&#x60; - json * &#x60;svg&#x60; - svg
  # @option opts [Int32] :unit_height
  # @option opts [Int32] :unit_width
  # @return [PaginatedRackUnitList]
  describe "dcim_racks_elevation_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_racks_list
  # Get a list of rack objects.
  # @param [Hash] opts the optional parameters
  # @option opts [String] :airflow * &#x60;front-to-rear&#x60; - Front to rear * &#x60;rear-to-front&#x60; - Rear to front
  # @option opts [Array(String)] :asset_tag
  # @option opts [Bool] :asset_tag__empty
  # @option opts [Array(String)] :asset_tag__ic
  # @option opts [Array(String)] :asset_tag__ie
  # @option opts [Array(String)] :asset_tag__iew
  # @option opts [Array(String)] :asset_tag__iregex
  # @option opts [Array(String)] :asset_tag__isw
  # @option opts [Array(String)] :asset_tag__n
  # @option opts [Array(String)] :asset_tag__nic
  # @option opts [Array(String)] :asset_tag__nie
  # @option opts [Array(String)] :asset_tag__niew
  # @option opts [Array(String)] :asset_tag__nisw
  # @option opts [Array(String)] :asset_tag__regex
  # @option opts [Array(Int32)] :contact Contact
  # @option opts [Array(Int32)] :contact__n Contact
  # @option opts [Array(String)] :contact_group
  # @option opts [Array(String)] :contact_group__n
  # @option opts [Array(Int32)] :contact_role Contact Role
  # @option opts [Array(Int32)] :contact_role__n Contact Role
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Bool] :desc_units
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(String)] :facility_id
  # @option opts [Bool] :facility_id__empty
  # @option opts [Array(String)] :facility_id__ic
  # @option opts [Array(String)] :facility_id__ie
  # @option opts [Array(String)] :facility_id__iew
  # @option opts [Array(String)] :facility_id__iregex
  # @option opts [Array(String)] :facility_id__isw
  # @option opts [Array(String)] :facility_id__n
  # @option opts [Array(String)] :facility_id__nic
  # @option opts [Array(String)] :facility_id__nie
  # @option opts [Array(String)] :facility_id__niew
  # @option opts [Array(String)] :facility_id__nisw
  # @option opts [Array(String)] :facility_id__regex
  # @option opts [Array(String)] :form_factor
  # @option opts [Bool] :form_factor__empty
  # @option opts [Array(String)] :form_factor__ic
  # @option opts [Array(String)] :form_factor__ie
  # @option opts [Array(String)] :form_factor__iew
  # @option opts [Array(String)] :form_factor__iregex
  # @option opts [Array(String)] :form_factor__isw
  # @option opts [Array(String)] :form_factor__n
  # @option opts [Array(String)] :form_factor__nic
  # @option opts [Array(String)] :form_factor__nie
  # @option opts [Array(String)] :form_factor__niew
  # @option opts [Array(String)] :form_factor__nisw
  # @option opts [Array(String)] :form_factor__regex
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(String)] :location
  # @option opts [Array(String)] :location__n
  # @option opts [Array(String)] :location_id
  # @option opts [Array(String)] :location_id__n
  # @option opts [Array(String)] :manufacturer Manufacturer (slug)
  # @option opts [Array(String)] :manufacturer__n Manufacturer (slug)
  # @option opts [Array(Int32)] :manufacturer_id Manufacturer (ID)
  # @option opts [Array(Int32)] :manufacturer_id__n Manufacturer (ID)
  # @option opts [Array(Int32)] :max_weight
  # @option opts [Bool] :max_weight__empty
  # @option opts [Array(Int32)] :max_weight__gt
  # @option opts [Array(Int32)] :max_weight__gte
  # @option opts [Array(Int32)] :max_weight__lt
  # @option opts [Array(Int32)] :max_weight__lte
  # @option opts [Array(Int32)] :max_weight__n
  # @option opts [String] :modified_by_request
  # @option opts [Array(Int32)] :mounting_depth
  # @option opts [Bool] :mounting_depth__empty
  # @option opts [Array(Int32)] :mounting_depth__gt
  # @option opts [Array(Int32)] :mounting_depth__gte
  # @option opts [Array(Int32)] :mounting_depth__lt
  # @option opts [Array(Int32)] :mounting_depth__lte
  # @option opts [Array(Int32)] :mounting_depth__n
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Array(Int32)] :outer_depth
  # @option opts [Bool] :outer_depth__empty
  # @option opts [Array(Int32)] :outer_depth__gt
  # @option opts [Array(Int32)] :outer_depth__gte
  # @option opts [Array(Int32)] :outer_depth__lt
  # @option opts [Array(Int32)] :outer_depth__lte
  # @option opts [Array(Int32)] :outer_depth__n
  # @option opts [Array(Int32)] :outer_height
  # @option opts [Bool] :outer_height__empty
  # @option opts [Array(Int32)] :outer_height__gt
  # @option opts [Array(Int32)] :outer_height__gte
  # @option opts [Array(Int32)] :outer_height__lt
  # @option opts [Array(Int32)] :outer_height__lte
  # @option opts [Array(Int32)] :outer_height__n
  # @option opts [String] :outer_unit * &#x60;mm&#x60; - Millimeters * &#x60;in&#x60; - Inches
  # @option opts [Array(Int32)] :outer_width
  # @option opts [Bool] :outer_width__empty
  # @option opts [Array(Int32)] :outer_width__gt
  # @option opts [Array(Int32)] :outer_width__gte
  # @option opts [Array(Int32)] :outer_width__lt
  # @option opts [Array(Int32)] :outer_width__lte
  # @option opts [Array(Int32)] :outer_width__n
  # @option opts [String] :q Search
  # @option opts [Array(String)] :rack_type Rack type (slug)
  # @option opts [Array(String)] :rack_type__n Rack type (slug)
  # @option opts [Array(Int32)] :rack_type_id Rack type (ID)
  # @option opts [Array(Int32)] :rack_type_id__n Rack type (ID)
  # @option opts [Array(String)] :region
  # @option opts [Array(String)] :region__n
  # @option opts [Array(String)] :region_id
  # @option opts [Array(String)] :region_id__n
  # @option opts [Array(String)] :role Role (slug)
  # @option opts [Array(String)] :role__n Role (slug)
  # @option opts [Array(Int32)] :role_id Role (ID)
  # @option opts [Array(Int32)] :role_id__n Role (ID)
  # @option opts [Array(String)] :serial
  # @option opts [Bool] :serial__empty
  # @option opts [Array(String)] :serial__ic
  # @option opts [Array(String)] :serial__ie
  # @option opts [Array(String)] :serial__iew
  # @option opts [Array(String)] :serial__iregex
  # @option opts [Array(String)] :serial__isw
  # @option opts [Array(String)] :serial__n
  # @option opts [Array(String)] :serial__nic
  # @option opts [Array(String)] :serial__nie
  # @option opts [Array(String)] :serial__niew
  # @option opts [Array(String)] :serial__nisw
  # @option opts [Array(String)] :serial__regex
  # @option opts [Array(String)] :site Site (slug)
  # @option opts [Array(String)] :site__n Site (slug)
  # @option opts [Array(String)] :site_group
  # @option opts [Array(String)] :site_group__n
  # @option opts [Array(String)] :site_group_id
  # @option opts [Array(String)] :site_group_id__n
  # @option opts [Array(Int32)] :site_id Site (ID)
  # @option opts [Array(Int32)] :site_id__n Site (ID)
  # @option opts [Array(Int32)] :starting_unit
  # @option opts [Bool] :starting_unit__empty
  # @option opts [Array(Int32)] :starting_unit__gt
  # @option opts [Array(Int32)] :starting_unit__gte
  # @option opts [Array(Int32)] :starting_unit__lt
  # @option opts [Array(Int32)] :starting_unit__lte
  # @option opts [Array(Int32)] :starting_unit__n
  # @option opts [Array(String)] :status
  # @option opts [Bool] :status__empty
  # @option opts [Array(String)] :status__ic
  # @option opts [Array(String)] :status__ie
  # @option opts [Array(String)] :status__iew
  # @option opts [Array(String)] :status__iregex
  # @option opts [Array(String)] :status__isw
  # @option opts [Array(String)] :status__n
  # @option opts [Array(String)] :status__nic
  # @option opts [Array(String)] :status__nie
  # @option opts [Array(String)] :status__niew
  # @option opts [Array(String)] :status__nisw
  # @option opts [Array(String)] :status__regex
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [Array(String)] :tenant Tenant (slug)
  # @option opts [Array(String)] :tenant__n Tenant (slug)
  # @option opts [Array(String)] :tenant_group
  # @option opts [Array(String)] :tenant_group__n
  # @option opts [Array(String)] :tenant_group_id
  # @option opts [Array(String)] :tenant_group_id__n
  # @option opts [Array(Int32)] :tenant_id Tenant (ID)
  # @option opts [Array(Int32)] :tenant_id__n Tenant (ID)
  # @option opts [Array(Int32)] :u_height
  # @option opts [Bool] :u_height__empty
  # @option opts [Array(Int32)] :u_height__gt
  # @option opts [Array(Int32)] :u_height__gte
  # @option opts [Array(Int32)] :u_height__lt
  # @option opts [Array(Int32)] :u_height__lte
  # @option opts [Array(Int32)] :u_height__n
  # @option opts [String] :updated_by_request
  # @option opts [Array(Float64)] :weight
  # @option opts [Bool] :weight__empty
  # @option opts [Array(Float64)] :weight__gt
  # @option opts [Array(Float64)] :weight__gte
  # @option opts [Array(Float64)] :weight__lt
  # @option opts [Array(Float64)] :weight__lte
  # @option opts [Array(Float64)] :weight__n
  # @option opts [String] :weight_unit * &#x60;kg&#x60; - Kilograms * &#x60;g&#x60; - Grams * &#x60;lb&#x60; - Pounds * &#x60;oz&#x60; - Ounces
  # @option opts [Array(Int32)] :width Rail-to-rail width
  # @option opts [Array(Int32)] :width__ic Rail-to-rail width
  # @option opts [Array(Int32)] :width__ie Rail-to-rail width
  # @option opts [Array(Int32)] :width__iew Rail-to-rail width
  # @option opts [Array(Int32)] :width__iregex Rail-to-rail width
  # @option opts [Array(Int32)] :width__isw Rail-to-rail width
  # @option opts [Array(Int32)] :width__n Rail-to-rail width
  # @option opts [Array(Int32)] :width__nic Rail-to-rail width
  # @option opts [Array(Int32)] :width__nie Rail-to-rail width
  # @option opts [Array(Int32)] :width__niew Rail-to-rail width
  # @option opts [Array(Int32)] :width__nisw Rail-to-rail width
  # @option opts [Array(Int32)] :width__regex Rail-to-rail width
  # @return [PaginatedRackList]
  describe "dcim_racks_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_racks_partial_update
  # Patch a rack object.
  # @param id A unique integer value identifying this rack.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableRackRequest] :patched_writable_rack_request
  # @return [Rack]
  describe "dcim_racks_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_racks_retrieve
  # Get a rack object.
  # @param id A unique integer value identifying this rack.
  # @param [Hash] opts the optional parameters
  # @return [Rack]
  describe "dcim_racks_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_racks_update
  # Put a rack object.
  # @param id A unique integer value identifying this rack.
  # @param writable_rack_request
  # @param [Hash] opts the optional parameters
  # @return [Rack]
  describe "dcim_racks_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rear_port_templates_bulk_destroy
  # Delete a list of rear port template objects.
  # @param rear_port_template_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_rear_port_templates_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rear_port_templates_bulk_partial_update
  # Patch a list of rear port template objects.
  # @param rear_port_template_request
  # @param [Hash] opts the optional parameters
  # @return [Array(RearPortTemplate)]
  describe "dcim_rear_port_templates_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rear_port_templates_bulk_update
  # Put a list of rear port template objects.
  # @param rear_port_template_request
  # @param [Hash] opts the optional parameters
  # @return [Array(RearPortTemplate)]
  describe "dcim_rear_port_templates_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rear_port_templates_create
  # Post a list of rear port template objects.
  # @param dcim_rear_port_templates_create_request
  # @param [Hash] opts the optional parameters
  # @return [RearPortTemplate]
  describe "dcim_rear_port_templates_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rear_port_templates_destroy
  # Delete a rear port template object.
  # @param id A unique integer value identifying this rear port template.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_rear_port_templates_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rear_port_templates_list
  # Get a list of rear port template objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(String)] :color
  # @option opts [Bool] :color__empty
  # @option opts [Array(String)] :color__ic
  # @option opts [Array(String)] :color__ie
  # @option opts [Array(String)] :color__iew
  # @option opts [Array(String)] :color__iregex
  # @option opts [Array(String)] :color__isw
  # @option opts [Array(String)] :color__n
  # @option opts [Array(String)] :color__nic
  # @option opts [Array(String)] :color__nie
  # @option opts [Array(String)] :color__niew
  # @option opts [Array(String)] :color__nisw
  # @option opts [Array(String)] :color__regex
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :device_type_id Device type (ID)
  # @option opts [Array(Int32)] :device_type_id__n Device type (ID)
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :label
  # @option opts [Bool] :label__empty
  # @option opts [Array(String)] :label__ic
  # @option opts [Array(String)] :label__ie
  # @option opts [Array(String)] :label__iew
  # @option opts [Array(String)] :label__iregex
  # @option opts [Array(String)] :label__isw
  # @option opts [Array(String)] :label__n
  # @option opts [Array(String)] :label__nic
  # @option opts [Array(String)] :label__nie
  # @option opts [Array(String)] :label__niew
  # @option opts [Array(String)] :label__nisw
  # @option opts [Array(String)] :label__regex
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [String] :modified_by_request
  # @option opts [Array(Int32)] :module_type_id Module type (ID)
  # @option opts [Array(Int32)] :module_type_id__n Module type (ID)
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Array(Int32)] :positions
  # @option opts [Bool] :positions__empty
  # @option opts [Array(Int32)] :positions__gt
  # @option opts [Array(Int32)] :positions__gte
  # @option opts [Array(Int32)] :positions__lt
  # @option opts [Array(Int32)] :positions__lte
  # @option opts [Array(Int32)] :positions__n
  # @option opts [String] :q Search
  # @option opts [Array(String)] :_type
  # @option opts [Bool] :type__empty
  # @option opts [Array(String)] :type__ic
  # @option opts [Array(String)] :type__ie
  # @option opts [Array(String)] :type__iew
  # @option opts [Array(String)] :type__iregex
  # @option opts [Array(String)] :type__isw
  # @option opts [Array(String)] :type__n
  # @option opts [Array(String)] :type__nic
  # @option opts [Array(String)] :type__nie
  # @option opts [Array(String)] :type__niew
  # @option opts [Array(String)] :type__nisw
  # @option opts [Array(String)] :type__regex
  # @option opts [String] :updated_by_request
  # @return [PaginatedRearPortTemplateList]
  describe "dcim_rear_port_templates_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rear_port_templates_partial_update
  # Patch a rear port template object.
  # @param id A unique integer value identifying this rear port template.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableRearPortTemplateRequest] :patched_writable_rear_port_template_request
  # @return [RearPortTemplate]
  describe "dcim_rear_port_templates_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rear_port_templates_retrieve
  # Get a rear port template object.
  # @param id A unique integer value identifying this rear port template.
  # @param [Hash] opts the optional parameters
  # @return [RearPortTemplate]
  describe "dcim_rear_port_templates_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rear_port_templates_update
  # Put a rear port template object.
  # @param id A unique integer value identifying this rear port template.
  # @param writable_rear_port_template_request
  # @param [Hash] opts the optional parameters
  # @return [RearPortTemplate]
  describe "dcim_rear_port_templates_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rear_ports_bulk_destroy
  # Delete a list of rear port objects.
  # @param rear_port_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_rear_ports_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rear_ports_bulk_partial_update
  # Patch a list of rear port objects.
  # @param rear_port_request
  # @param [Hash] opts the optional parameters
  # @return [Array(RearPort)]
  describe "dcim_rear_ports_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rear_ports_bulk_update
  # Put a list of rear port objects.
  # @param rear_port_request
  # @param [Hash] opts the optional parameters
  # @return [Array(RearPort)]
  describe "dcim_rear_ports_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rear_ports_create
  # Post a list of rear port objects.
  # @param dcim_rear_ports_create_request
  # @param [Hash] opts the optional parameters
  # @return [RearPort]
  describe "dcim_rear_ports_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rear_ports_destroy
  # Delete a rear port object.
  # @param id A unique integer value identifying this rear port.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_rear_ports_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rear_ports_list
  # Get a list of rear port objects.
  # @param [Hash] opts the optional parameters
  # @option opts [String] :cable_end * &#x60;A&#x60; - A * &#x60;B&#x60; - B
  # @option opts [Array(Int32)] :cable_id Cable (ID)
  # @option opts [Array(Int32)] :cable_id__n Cable (ID)
  # @option opts [Bool] :cabled
  # @option opts [Array(String)] :color
  # @option opts [Bool] :color__empty
  # @option opts [Array(String)] :color__ic
  # @option opts [Array(String)] :color__ie
  # @option opts [Array(String)] :color__iew
  # @option opts [Array(String)] :color__iregex
  # @option opts [Array(String)] :color__isw
  # @option opts [Array(String)] :color__n
  # @option opts [Array(String)] :color__nic
  # @option opts [Array(String)] :color__nie
  # @option opts [Array(String)] :color__niew
  # @option opts [Array(String)] :color__nisw
  # @option opts [Array(String)] :color__regex
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(String)] :device Device (name)
  # @option opts [Array(String)] :device__n Device (name)
  # @option opts [Array(Int32)] :device_id Device (ID)
  # @option opts [Array(Int32)] :device_id__n Device (ID)
  # @option opts [Array(String)] :device_role Device role (slug)
  # @option opts [Array(String)] :device_role__n Device role (slug)
  # @option opts [Array(Int32)] :device_role_id Device role (ID)
  # @option opts [Array(Int32)] :device_role_id__n Device role (ID)
  # @option opts [Array(String)] :device_status
  # @option opts [Bool] :device_status__empty
  # @option opts [Array(String)] :device_status__ic
  # @option opts [Array(String)] :device_status__ie
  # @option opts [Array(String)] :device_status__iew
  # @option opts [Array(String)] :device_status__iregex
  # @option opts [Array(String)] :device_status__isw
  # @option opts [Array(String)] :device_status__n
  # @option opts [Array(String)] :device_status__nic
  # @option opts [Array(String)] :device_status__nie
  # @option opts [Array(String)] :device_status__niew
  # @option opts [Array(String)] :device_status__nisw
  # @option opts [Array(String)] :device_status__regex
  # @option opts [Array(String)] :device_type Device type (model)
  # @option opts [Array(String)] :device_type__n Device type (model)
  # @option opts [Array(Int32)] :device_type_id Device type (ID)
  # @option opts [Array(Int32)] :device_type_id__n Device type (ID)
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :label
  # @option opts [Bool] :label__empty
  # @option opts [Array(String)] :label__ic
  # @option opts [Array(String)] :label__ie
  # @option opts [Array(String)] :label__iew
  # @option opts [Array(String)] :label__iregex
  # @option opts [Array(String)] :label__isw
  # @option opts [Array(String)] :label__n
  # @option opts [Array(String)] :label__nic
  # @option opts [Array(String)] :label__nie
  # @option opts [Array(String)] :label__niew
  # @option opts [Array(String)] :label__nisw
  # @option opts [Array(String)] :label__regex
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(String)] :location Location (slug)
  # @option opts [Array(String)] :location__n Location (slug)
  # @option opts [Array(Int32)] :location_id Location (ID)
  # @option opts [Array(Int32)] :location_id__n Location (ID)
  # @option opts [Bool] :mark_connected
  # @option opts [String] :modified_by_request
  # @option opts [Array(Int32)] :module_id Module (ID)
  # @option opts [Array(Int32)] :module_id__n Module (ID)
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Bool] :occupied
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Array(Int32)] :positions
  # @option opts [Bool] :positions__empty
  # @option opts [Array(Int32)] :positions__gt
  # @option opts [Array(Int32)] :positions__gte
  # @option opts [Array(Int32)] :positions__lt
  # @option opts [Array(Int32)] :positions__lte
  # @option opts [Array(Int32)] :positions__n
  # @option opts [String] :q Search
  # @option opts [Array(String)] :rack Rack (name)
  # @option opts [Array(String)] :rack__n Rack (name)
  # @option opts [Array(Int32)] :rack_id Rack (ID)
  # @option opts [Array(Int32)] :rack_id__n Rack (ID)
  # @option opts [Array(String)] :region
  # @option opts [Array(String)] :region__n
  # @option opts [Array(String)] :region_id
  # @option opts [Array(String)] :region_id__n
  # @option opts [Array(String)] :site Site name (slug)
  # @option opts [Array(String)] :site__n Site name (slug)
  # @option opts [Array(String)] :site_group
  # @option opts [Array(String)] :site_group__n
  # @option opts [Array(String)] :site_group_id
  # @option opts [Array(String)] :site_group_id__n
  # @option opts [Array(Int32)] :site_id Site (ID)
  # @option opts [Array(Int32)] :site_id__n Site (ID)
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [Array(String)] :tenant Tenant (slug)
  # @option opts [Array(String)] :tenant__n Tenant (slug)
  # @option opts [Array(Int32)] :tenant_id Tenant (ID)
  # @option opts [Array(Int32)] :tenant_id__n Tenant (ID)
  # @option opts [Array(String)] :_type
  # @option opts [Bool] :type__empty
  # @option opts [Array(String)] :type__ic
  # @option opts [Array(String)] :type__ie
  # @option opts [Array(String)] :type__iew
  # @option opts [Array(String)] :type__iregex
  # @option opts [Array(String)] :type__isw
  # @option opts [Array(String)] :type__n
  # @option opts [Array(String)] :type__nic
  # @option opts [Array(String)] :type__nie
  # @option opts [Array(String)] :type__niew
  # @option opts [Array(String)] :type__nisw
  # @option opts [Array(String)] :type__regex
  # @option opts [String] :updated_by_request
  # @option opts [Array(String)] :virtual_chassis Virtual Chassis
  # @option opts [Array(String)] :virtual_chassis__n Virtual Chassis
  # @option opts [Array(Int32)] :virtual_chassis_id Virtual Chassis (ID)
  # @option opts [Array(Int32)] :virtual_chassis_id__n Virtual Chassis (ID)
  # @return [PaginatedRearPortList]
  describe "dcim_rear_ports_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rear_ports_partial_update
  # Patch a rear port object.
  # @param id A unique integer value identifying this rear port.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableRearPortRequest] :patched_writable_rear_port_request
  # @return [RearPort]
  describe "dcim_rear_ports_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rear_ports_paths_retrieve
  # Return all CablePaths which traverse a given pass-through port.
  # @param id A unique integer value identifying this rear port.
  # @param [Hash] opts the optional parameters
  # @return [RearPort]
  describe "dcim_rear_ports_paths_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rear_ports_retrieve
  # Get a rear port object.
  # @param id A unique integer value identifying this rear port.
  # @param [Hash] opts the optional parameters
  # @return [RearPort]
  describe "dcim_rear_ports_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_rear_ports_update
  # Put a rear port object.
  # @param id A unique integer value identifying this rear port.
  # @param writable_rear_port_request
  # @param [Hash] opts the optional parameters
  # @return [RearPort]
  describe "dcim_rear_ports_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_regions_bulk_destroy
  # Delete a list of region objects.
  # @param region_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_regions_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_regions_bulk_partial_update
  # Patch a list of region objects.
  # @param region_request
  # @param [Hash] opts the optional parameters
  # @return [Array(Region)]
  describe "dcim_regions_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_regions_bulk_update
  # Put a list of region objects.
  # @param region_request
  # @param [Hash] opts the optional parameters
  # @return [Array(Region)]
  describe "dcim_regions_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_regions_create
  # Post a list of region objects.
  # @param dcim_regions_create_request
  # @param [Hash] opts the optional parameters
  # @return [Region]
  describe "dcim_regions_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_regions_destroy
  # Delete a region object.
  # @param id A unique integer value identifying this region.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_regions_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_regions_list
  # Get a list of region objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(String)] :ancestor
  # @option opts [Array(String)] :ancestor__n
  # @option opts [Array(String)] :ancestor_id
  # @option opts [Array(String)] :ancestor_id__n
  # @option opts [Array(Int32)] :contact Contact
  # @option opts [Array(Int32)] :contact__n Contact
  # @option opts [Array(String)] :contact_group
  # @option opts [Array(String)] :contact_group__n
  # @option opts [Array(Int32)] :contact_role Contact Role
  # @option opts [Array(Int32)] :contact_role__n Contact Role
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Array(String)] :parent Parent region (slug)
  # @option opts [Array(String)] :parent__n Parent region (slug)
  # @option opts [Array(Int32)] :parent_id Parent region (ID)
  # @option opts [Array(Int32)] :parent_id__n Parent region (ID)
  # @option opts [String] :q Search
  # @option opts [Array(String)] :slug
  # @option opts [Bool] :slug__empty
  # @option opts [Array(String)] :slug__ic
  # @option opts [Array(String)] :slug__ie
  # @option opts [Array(String)] :slug__iew
  # @option opts [Array(String)] :slug__iregex
  # @option opts [Array(String)] :slug__isw
  # @option opts [Array(String)] :slug__n
  # @option opts [Array(String)] :slug__nic
  # @option opts [Array(String)] :slug__nie
  # @option opts [Array(String)] :slug__niew
  # @option opts [Array(String)] :slug__nisw
  # @option opts [Array(String)] :slug__regex
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [String] :updated_by_request
  # @return [PaginatedRegionList]
  describe "dcim_regions_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_regions_partial_update
  # Patch a region object.
  # @param id A unique integer value identifying this region.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableRegionRequest] :patched_writable_region_request
  # @return [Region]
  describe "dcim_regions_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_regions_retrieve
  # Get a region object.
  # @param id A unique integer value identifying this region.
  # @param [Hash] opts the optional parameters
  # @return [Region]
  describe "dcim_regions_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_regions_update
  # Put a region object.
  # @param id A unique integer value identifying this region.
  # @param writable_region_request
  # @param [Hash] opts the optional parameters
  # @return [Region]
  describe "dcim_regions_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_site_groups_bulk_destroy
  # Delete a list of site group objects.
  # @param site_group_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_site_groups_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_site_groups_bulk_partial_update
  # Patch a list of site group objects.
  # @param site_group_request
  # @param [Hash] opts the optional parameters
  # @return [Array(SiteGroup)]
  describe "dcim_site_groups_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_site_groups_bulk_update
  # Put a list of site group objects.
  # @param site_group_request
  # @param [Hash] opts the optional parameters
  # @return [Array(SiteGroup)]
  describe "dcim_site_groups_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_site_groups_create
  # Post a list of site group objects.
  # @param dcim_site_groups_create_request
  # @param [Hash] opts the optional parameters
  # @return [SiteGroup]
  describe "dcim_site_groups_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_site_groups_destroy
  # Delete a site group object.
  # @param id A unique integer value identifying this site group.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_site_groups_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_site_groups_list
  # Get a list of site group objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(String)] :ancestor
  # @option opts [Array(String)] :ancestor__n
  # @option opts [Array(String)] :ancestor_id
  # @option opts [Array(String)] :ancestor_id__n
  # @option opts [Array(Int32)] :contact Contact
  # @option opts [Array(Int32)] :contact__n Contact
  # @option opts [Array(String)] :contact_group
  # @option opts [Array(String)] :contact_group__n
  # @option opts [Array(Int32)] :contact_role Contact Role
  # @option opts [Array(Int32)] :contact_role__n Contact Role
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Array(String)] :parent Parent site group (slug)
  # @option opts [Array(String)] :parent__n Parent site group (slug)
  # @option opts [Array(Int32)] :parent_id Parent site group (ID)
  # @option opts [Array(Int32)] :parent_id__n Parent site group (ID)
  # @option opts [String] :q Search
  # @option opts [Array(String)] :slug
  # @option opts [Bool] :slug__empty
  # @option opts [Array(String)] :slug__ic
  # @option opts [Array(String)] :slug__ie
  # @option opts [Array(String)] :slug__iew
  # @option opts [Array(String)] :slug__iregex
  # @option opts [Array(String)] :slug__isw
  # @option opts [Array(String)] :slug__n
  # @option opts [Array(String)] :slug__nic
  # @option opts [Array(String)] :slug__nie
  # @option opts [Array(String)] :slug__niew
  # @option opts [Array(String)] :slug__nisw
  # @option opts [Array(String)] :slug__regex
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [String] :updated_by_request
  # @return [PaginatedSiteGroupList]
  describe "dcim_site_groups_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_site_groups_partial_update
  # Patch a site group object.
  # @param id A unique integer value identifying this site group.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableSiteGroupRequest] :patched_writable_site_group_request
  # @return [SiteGroup]
  describe "dcim_site_groups_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_site_groups_retrieve
  # Get a site group object.
  # @param id A unique integer value identifying this site group.
  # @param [Hash] opts the optional parameters
  # @return [SiteGroup]
  describe "dcim_site_groups_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_site_groups_update
  # Put a site group object.
  # @param id A unique integer value identifying this site group.
  # @param writable_site_group_request
  # @param [Hash] opts the optional parameters
  # @return [SiteGroup]
  describe "dcim_site_groups_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_sites_bulk_destroy
  # Delete a list of site objects.
  # @param site_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_sites_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_sites_bulk_partial_update
  # Patch a list of site objects.
  # @param site_request
  # @param [Hash] opts the optional parameters
  # @return [Array(Site)]
  describe "dcim_sites_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_sites_bulk_update
  # Put a list of site objects.
  # @param site_request
  # @param [Hash] opts the optional parameters
  # @return [Array(Site)]
  describe "dcim_sites_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_sites_create
  # Post a list of site objects.
  # @param dcim_sites_create_request
  # @param [Hash] opts the optional parameters
  # @return [Site]
  describe "dcim_sites_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_sites_destroy
  # Delete a site object.
  # @param id A unique integer value identifying this site.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_sites_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_sites_list
  # Get a list of site objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(String)] :asn AS (ID)
  # @option opts [Array(String)] :asn__n AS (ID)
  # @option opts [Array(Int32)] :asn_id AS (ID)
  # @option opts [Array(Int32)] :asn_id__n AS (ID)
  # @option opts [Array(Int32)] :contact Contact
  # @option opts [Array(Int32)] :contact__n Contact
  # @option opts [Array(String)] :contact_group
  # @option opts [Array(String)] :contact_group__n
  # @option opts [Array(Int32)] :contact_role Contact Role
  # @option opts [Array(Int32)] :contact_role__n Contact Role
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(String)] :facility
  # @option opts [Bool] :facility__empty
  # @option opts [Array(String)] :facility__ic
  # @option opts [Array(String)] :facility__ie
  # @option opts [Array(String)] :facility__iew
  # @option opts [Array(String)] :facility__iregex
  # @option opts [Array(String)] :facility__isw
  # @option opts [Array(String)] :facility__n
  # @option opts [Array(String)] :facility__nic
  # @option opts [Array(String)] :facility__nie
  # @option opts [Array(String)] :facility__niew
  # @option opts [Array(String)] :facility__nisw
  # @option opts [Array(String)] :facility__regex
  # @option opts [Array(String)] :group
  # @option opts [Array(String)] :group__n
  # @option opts [Array(String)] :group_id
  # @option opts [Array(String)] :group_id__n
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Array(Float64)] :latitude
  # @option opts [Bool] :latitude__empty
  # @option opts [Array(Float64)] :latitude__gt
  # @option opts [Array(Float64)] :latitude__gte
  # @option opts [Array(Float64)] :latitude__lt
  # @option opts [Array(Float64)] :latitude__lte
  # @option opts [Array(Float64)] :latitude__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(Float64)] :longitude
  # @option opts [Bool] :longitude__empty
  # @option opts [Array(Float64)] :longitude__gt
  # @option opts [Array(Float64)] :longitude__gte
  # @option opts [Array(Float64)] :longitude__lt
  # @option opts [Array(Float64)] :longitude__lte
  # @option opts [Array(Float64)] :longitude__n
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [Array(String)] :region
  # @option opts [Array(String)] :region__n
  # @option opts [Array(String)] :region_id
  # @option opts [Array(String)] :region_id__n
  # @option opts [Array(String)] :slug
  # @option opts [Bool] :slug__empty
  # @option opts [Array(String)] :slug__ic
  # @option opts [Array(String)] :slug__ie
  # @option opts [Array(String)] :slug__iew
  # @option opts [Array(String)] :slug__iregex
  # @option opts [Array(String)] :slug__isw
  # @option opts [Array(String)] :slug__n
  # @option opts [Array(String)] :slug__nic
  # @option opts [Array(String)] :slug__nie
  # @option opts [Array(String)] :slug__niew
  # @option opts [Array(String)] :slug__nisw
  # @option opts [Array(String)] :slug__regex
  # @option opts [Array(String)] :status
  # @option opts [Bool] :status__empty
  # @option opts [Array(String)] :status__ic
  # @option opts [Array(String)] :status__ie
  # @option opts [Array(String)] :status__iew
  # @option opts [Array(String)] :status__iregex
  # @option opts [Array(String)] :status__isw
  # @option opts [Array(String)] :status__n
  # @option opts [Array(String)] :status__nic
  # @option opts [Array(String)] :status__nie
  # @option opts [Array(String)] :status__niew
  # @option opts [Array(String)] :status__nisw
  # @option opts [Array(String)] :status__regex
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [Array(String)] :tenant Tenant (slug)
  # @option opts [Array(String)] :tenant__n Tenant (slug)
  # @option opts [Array(String)] :tenant_group
  # @option opts [Array(String)] :tenant_group__n
  # @option opts [Array(String)] :tenant_group_id
  # @option opts [Array(String)] :tenant_group_id__n
  # @option opts [Array(Int32)] :tenant_id Tenant (ID)
  # @option opts [Array(Int32)] :tenant_id__n Tenant (ID)
  # @option opts [Array(String)] :time_zone
  # @option opts [Array(String)] :time_zone__ic
  # @option opts [Array(String)] :time_zone__ie
  # @option opts [Array(String)] :time_zone__iew
  # @option opts [Array(String)] :time_zone__iregex
  # @option opts [Array(String)] :time_zone__isw
  # @option opts [Array(String)] :time_zone__n
  # @option opts [Array(String)] :time_zone__nic
  # @option opts [Array(String)] :time_zone__nie
  # @option opts [Array(String)] :time_zone__niew
  # @option opts [Array(String)] :time_zone__nisw
  # @option opts [Array(String)] :time_zone__regex
  # @option opts [String] :updated_by_request
  # @return [PaginatedSiteList]
  describe "dcim_sites_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_sites_partial_update
  # Patch a site object.
  # @param id A unique integer value identifying this site.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableSiteRequest] :patched_writable_site_request
  # @return [Site]
  describe "dcim_sites_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_sites_retrieve
  # Get a site object.
  # @param id A unique integer value identifying this site.
  # @param [Hash] opts the optional parameters
  # @return [Site]
  describe "dcim_sites_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_sites_update
  # Put a site object.
  # @param id A unique integer value identifying this site.
  # @param writable_site_request
  # @param [Hash] opts the optional parameters
  # @return [Site]
  describe "dcim_sites_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_virtual_chassis_bulk_destroy
  # Delete a list of virtual chassis objects.
  # @param virtual_chassis_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_virtual_chassis_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_virtual_chassis_bulk_partial_update
  # Patch a list of virtual chassis objects.
  # @param virtual_chassis_request
  # @param [Hash] opts the optional parameters
  # @return [Array(VirtualChassis)]
  describe "dcim_virtual_chassis_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_virtual_chassis_bulk_update
  # Put a list of virtual chassis objects.
  # @param virtual_chassis_request
  # @param [Hash] opts the optional parameters
  # @return [Array(VirtualChassis)]
  describe "dcim_virtual_chassis_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_virtual_chassis_create
  # Post a list of virtual chassis objects.
  # @param dcim_virtual_chassis_create_request
  # @param [Hash] opts the optional parameters
  # @return [VirtualChassis]
  describe "dcim_virtual_chassis_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_virtual_chassis_destroy
  # Delete a virtual chassis object.
  # @param id A unique integer value identifying this virtual chassis.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_virtual_chassis_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_virtual_chassis_list
  # Get a list of virtual chassis objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(String)] :domain
  # @option opts [Bool] :domain__empty
  # @option opts [Array(String)] :domain__ic
  # @option opts [Array(String)] :domain__ie
  # @option opts [Array(String)] :domain__iew
  # @option opts [Array(String)] :domain__iregex
  # @option opts [Array(String)] :domain__isw
  # @option opts [Array(String)] :domain__n
  # @option opts [Array(String)] :domain__nic
  # @option opts [Array(String)] :domain__nie
  # @option opts [Array(String)] :domain__niew
  # @option opts [Array(String)] :domain__nisw
  # @option opts [Array(String)] :domain__regex
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(String)] :master Master (name)
  # @option opts [Array(String)] :master__n Master (name)
  # @option opts [Array(Int32)] :master_id Master (ID)
  # @option opts [Array(Int32)] :master_id__n Master (ID)
  # @option opts [Array(Int32)] :member_count
  # @option opts [Bool] :member_count__empty
  # @option opts [Array(Int32)] :member_count__gt
  # @option opts [Array(Int32)] :member_count__gte
  # @option opts [Array(Int32)] :member_count__lt
  # @option opts [Array(Int32)] :member_count__lte
  # @option opts [Array(Int32)] :member_count__n
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [Array(String)] :region
  # @option opts [Array(String)] :region__n
  # @option opts [Array(String)] :region_id
  # @option opts [Array(String)] :region_id__n
  # @option opts [Array(String)] :site Site name (slug)
  # @option opts [Array(String)] :site__n Site name (slug)
  # @option opts [Array(String)] :site_group
  # @option opts [Array(String)] :site_group__n
  # @option opts [Array(String)] :site_group_id
  # @option opts [Array(String)] :site_group_id__n
  # @option opts [Array(Int32)] :site_id Site (ID)
  # @option opts [Array(Int32)] :site_id__n Site (ID)
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [Array(String)] :tenant Tenant (slug)
  # @option opts [Array(String)] :tenant__n Tenant (slug)
  # @option opts [Array(Int32)] :tenant_id Tenant (ID)
  # @option opts [Array(Int32)] :tenant_id__n Tenant (ID)
  # @option opts [String] :updated_by_request
  # @return [PaginatedVirtualChassisList]
  describe "dcim_virtual_chassis_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_virtual_chassis_partial_update
  # Patch a virtual chassis object.
  # @param id A unique integer value identifying this virtual chassis.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableVirtualChassisRequest] :patched_writable_virtual_chassis_request
  # @return [VirtualChassis]
  describe "dcim_virtual_chassis_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_virtual_chassis_retrieve
  # Get a virtual chassis object.
  # @param id A unique integer value identifying this virtual chassis.
  # @param [Hash] opts the optional parameters
  # @return [VirtualChassis]
  describe "dcim_virtual_chassis_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_virtual_chassis_update
  # Put a virtual chassis object.
  # @param id A unique integer value identifying this virtual chassis.
  # @param writable_virtual_chassis_request
  # @param [Hash] opts the optional parameters
  # @return [VirtualChassis]
  describe "dcim_virtual_chassis_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_virtual_device_contexts_bulk_destroy
  # Delete a list of virtual device context objects.
  # @param virtual_device_context_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_virtual_device_contexts_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_virtual_device_contexts_bulk_partial_update
  # Patch a list of virtual device context objects.
  # @param virtual_device_context_request
  # @param [Hash] opts the optional parameters
  # @return [Array(VirtualDeviceContext)]
  describe "dcim_virtual_device_contexts_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_virtual_device_contexts_bulk_update
  # Put a list of virtual device context objects.
  # @param virtual_device_context_request
  # @param [Hash] opts the optional parameters
  # @return [Array(VirtualDeviceContext)]
  describe "dcim_virtual_device_contexts_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_virtual_device_contexts_create
  # Post a list of virtual device context objects.
  # @param dcim_virtual_device_contexts_create_request
  # @param [Hash] opts the optional parameters
  # @return [VirtualDeviceContext]
  describe "dcim_virtual_device_contexts_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_virtual_device_contexts_destroy
  # Delete a virtual device context object.
  # @param id A unique integer value identifying this virtual device context.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "dcim_virtual_device_contexts_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_virtual_device_contexts_list
  # Get a list of virtual device context objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :device Device model
  # @option opts [Array(Int32)] :device__n Device model
  # @option opts [Array(Int32)] :device_id VDC (ID)
  # @option opts [Array(Int32)] :device_id__n VDC (ID)
  # @option opts [Bool] :has_primary_ip Has a primary IP
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(Int32)] :identifier
  # @option opts [Bool] :identifier__empty
  # @option opts [Array(Int32)] :identifier__gt
  # @option opts [Array(Int32)] :identifier__gte
  # @option opts [Array(Int32)] :identifier__lt
  # @option opts [Array(Int32)] :identifier__lte
  # @option opts [Array(Int32)] :identifier__n
  # @option opts [Array(Int32)] :interface_id Interface (ID)
  # @option opts [Array(Int32)] :interface_id__n Interface (ID)
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Array(String)] :primary_ip4 Primary IPv4 (address)
  # @option opts [Array(String)] :primary_ip4__n Primary IPv4 (address)
  # @option opts [Array(Int32)] :primary_ip4_id Primary IPv4 (ID)
  # @option opts [Array(Int32)] :primary_ip4_id__n Primary IPv4 (ID)
  # @option opts [Array(String)] :primary_ip6 Primary IPv6 (address)
  # @option opts [Array(String)] :primary_ip6__n Primary IPv6 (address)
  # @option opts [Array(Int32)] :primary_ip6_id Primary IPv6 (ID)
  # @option opts [Array(Int32)] :primary_ip6_id__n Primary IPv6 (ID)
  # @option opts [String] :q Search
  # @option opts [Array(String)] :status
  # @option opts [Bool] :status__empty
  # @option opts [Array(String)] :status__ic
  # @option opts [Array(String)] :status__ie
  # @option opts [Array(String)] :status__iew
  # @option opts [Array(String)] :status__iregex
  # @option opts [Array(String)] :status__isw
  # @option opts [Array(String)] :status__n
  # @option opts [Array(String)] :status__nic
  # @option opts [Array(String)] :status__nie
  # @option opts [Array(String)] :status__niew
  # @option opts [Array(String)] :status__nisw
  # @option opts [Array(String)] :status__regex
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [Array(String)] :tenant Tenant (slug)
  # @option opts [Array(String)] :tenant__n Tenant (slug)
  # @option opts [Array(String)] :tenant_group
  # @option opts [Array(String)] :tenant_group__n
  # @option opts [Array(String)] :tenant_group_id
  # @option opts [Array(String)] :tenant_group_id__n
  # @option opts [Array(Int32)] :tenant_id Tenant (ID)
  # @option opts [Array(Int32)] :tenant_id__n Tenant (ID)
  # @option opts [String] :updated_by_request
  # @return [PaginatedVirtualDeviceContextList]
  describe "dcim_virtual_device_contexts_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_virtual_device_contexts_partial_update
  # Patch a virtual device context object.
  # @param id A unique integer value identifying this virtual device context.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableVirtualDeviceContextRequest] :patched_writable_virtual_device_context_request
  # @return [VirtualDeviceContext]
  describe "dcim_virtual_device_contexts_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_virtual_device_contexts_retrieve
  # Get a virtual device context object.
  # @param id A unique integer value identifying this virtual device context.
  # @param [Hash] opts the optional parameters
  # @return [VirtualDeviceContext]
  describe "dcim_virtual_device_contexts_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for dcim_virtual_device_contexts_update
  # Put a virtual device context object.
  # @param id A unique integer value identifying this virtual device context.
  # @param writable_virtual_device_context_request
  # @param [Hash] opts the optional parameters
  # @return [VirtualDeviceContext]
  describe "dcim_virtual_device_contexts_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end
end
