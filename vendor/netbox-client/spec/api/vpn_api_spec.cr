# #NetBox REST API
#
# #No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
#
# The version of the OpenAPI document: 4.4.9 (4.4)
#
# Generated by: https://openapi-generator.tech
# Generator version: 7.19.0-SNAPSHOT
#

require "../spec_helper"

# Unit tests for NetboxClient::VpnApi
# Automatically generated by openapi-generator (https://openapi-generator.tech)
# Please update as you see appropriate
Spectator.describe "VpnApi" do
  describe "test an instance of VpnApi" do
    it "should create an instance of VpnApi" do
      api_instance = NetboxClient::VpnApi.new
      expect(api_instance).to be_instance_of(NetboxClient::VpnApi)
    end
  end

  # unit tests for vpn_ike_policies_bulk_destroy
  # Delete a list of IKE policy objects.
  # @param ike_policy_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "vpn_ike_policies_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ike_policies_bulk_partial_update
  # Patch a list of IKE policy objects.
  # @param ike_policy_request
  # @param [Hash] opts the optional parameters
  # @return [Array(IKEPolicy)]
  describe "vpn_ike_policies_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ike_policies_bulk_update
  # Put a list of IKE policy objects.
  # @param ike_policy_request
  # @param [Hash] opts the optional parameters
  # @return [Array(IKEPolicy)]
  describe "vpn_ike_policies_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ike_policies_create
  # Post a list of IKE policy objects.
  # @param vpn_ike_policies_create_request
  # @param [Hash] opts the optional parameters
  # @return [IKEPolicy]
  describe "vpn_ike_policies_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ike_policies_destroy
  # Delete a IKE policy object.
  # @param id A unique integer value identifying this IKE policy.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "vpn_ike_policies_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ike_policies_list
  # Get a list of IKE policy objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :ike_proposal
  # @option opts [Array(String)] :ike_proposal__n
  # @option opts [Array(Int32)] :ike_proposal_id
  # @option opts [Array(Int32)] :ike_proposal_id__n
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(String)] :mode
  # @option opts [Bool] :mode__empty
  # @option opts [Array(String)] :mode__ic
  # @option opts [Array(String)] :mode__ie
  # @option opts [Array(String)] :mode__iew
  # @option opts [Array(String)] :mode__iregex
  # @option opts [Array(String)] :mode__isw
  # @option opts [Array(String)] :mode__n
  # @option opts [Array(String)] :mode__nic
  # @option opts [Array(String)] :mode__nie
  # @option opts [Array(String)] :mode__niew
  # @option opts [Array(String)] :mode__nisw
  # @option opts [Array(String)] :mode__regex
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :preshared_key
  # @option opts [String] :preshared_key__ic
  # @option opts [String] :preshared_key__ie
  # @option opts [String] :preshared_key__iew
  # @option opts [String] :preshared_key__iregex
  # @option opts [String] :preshared_key__isw
  # @option opts [String] :preshared_key__n
  # @option opts [String] :preshared_key__nic
  # @option opts [String] :preshared_key__nie
  # @option opts [String] :preshared_key__niew
  # @option opts [String] :preshared_key__nisw
  # @option opts [String] :preshared_key__regex
  # @option opts [String] :q Search
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [String] :updated_by_request
  # @option opts [Array(Int32)] :version
  # @option opts [Array(Int32)] :version__ic
  # @option opts [Array(Int32)] :version__ie
  # @option opts [Array(Int32)] :version__iew
  # @option opts [Array(Int32)] :version__iregex
  # @option opts [Array(Int32)] :version__isw
  # @option opts [Array(Int32)] :version__n
  # @option opts [Array(Int32)] :version__nic
  # @option opts [Array(Int32)] :version__nie
  # @option opts [Array(Int32)] :version__niew
  # @option opts [Array(Int32)] :version__nisw
  # @option opts [Array(Int32)] :version__regex
  # @return [PaginatedIKEPolicyList]
  describe "vpn_ike_policies_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ike_policies_partial_update
  # Patch a IKE policy object.
  # @param id A unique integer value identifying this IKE policy.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableIKEPolicyRequest] :patched_writable_ike_policy_request
  # @return [IKEPolicy]
  describe "vpn_ike_policies_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ike_policies_retrieve
  # Get a IKE policy object.
  # @param id A unique integer value identifying this IKE policy.
  # @param [Hash] opts the optional parameters
  # @return [IKEPolicy]
  describe "vpn_ike_policies_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ike_policies_update
  # Put a IKE policy object.
  # @param id A unique integer value identifying this IKE policy.
  # @param writable_ike_policy_request
  # @param [Hash] opts the optional parameters
  # @return [IKEPolicy]
  describe "vpn_ike_policies_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ike_proposals_bulk_destroy
  # Delete a list of IKE proposal objects.
  # @param ike_proposal_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "vpn_ike_proposals_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ike_proposals_bulk_partial_update
  # Patch a list of IKE proposal objects.
  # @param ike_proposal_request
  # @param [Hash] opts the optional parameters
  # @return [Array(IKEProposal)]
  describe "vpn_ike_proposals_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ike_proposals_bulk_update
  # Put a list of IKE proposal objects.
  # @param ike_proposal_request
  # @param [Hash] opts the optional parameters
  # @return [Array(IKEProposal)]
  describe "vpn_ike_proposals_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ike_proposals_create
  # Post a list of IKE proposal objects.
  # @param vpn_ike_proposals_create_request
  # @param [Hash] opts the optional parameters
  # @return [IKEProposal]
  describe "vpn_ike_proposals_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ike_proposals_destroy
  # Delete a IKE proposal object.
  # @param id A unique integer value identifying this IKE proposal.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "vpn_ike_proposals_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ike_proposals_list
  # Get a list of IKE proposal objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(String)] :authentication_algorithm
  # @option opts [Bool] :authentication_algorithm__empty
  # @option opts [Array(String)] :authentication_algorithm__ic
  # @option opts [Array(String)] :authentication_algorithm__ie
  # @option opts [Array(String)] :authentication_algorithm__iew
  # @option opts [Array(String)] :authentication_algorithm__iregex
  # @option opts [Array(String)] :authentication_algorithm__isw
  # @option opts [Array(String)] :authentication_algorithm__n
  # @option opts [Array(String)] :authentication_algorithm__nic
  # @option opts [Array(String)] :authentication_algorithm__nie
  # @option opts [Array(String)] :authentication_algorithm__niew
  # @option opts [Array(String)] :authentication_algorithm__nisw
  # @option opts [Array(String)] :authentication_algorithm__regex
  # @option opts [Array(String)] :authentication_method
  # @option opts [Bool] :authentication_method__empty
  # @option opts [Array(String)] :authentication_method__ic
  # @option opts [Array(String)] :authentication_method__ie
  # @option opts [Array(String)] :authentication_method__iew
  # @option opts [Array(String)] :authentication_method__iregex
  # @option opts [Array(String)] :authentication_method__isw
  # @option opts [Array(String)] :authentication_method__n
  # @option opts [Array(String)] :authentication_method__nic
  # @option opts [Array(String)] :authentication_method__nie
  # @option opts [Array(String)] :authentication_method__niew
  # @option opts [Array(String)] :authentication_method__nisw
  # @option opts [Array(String)] :authentication_method__regex
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(String)] :encryption_algorithm
  # @option opts [Bool] :encryption_algorithm__empty
  # @option opts [Array(String)] :encryption_algorithm__ic
  # @option opts [Array(String)] :encryption_algorithm__ie
  # @option opts [Array(String)] :encryption_algorithm__iew
  # @option opts [Array(String)] :encryption_algorithm__iregex
  # @option opts [Array(String)] :encryption_algorithm__isw
  # @option opts [Array(String)] :encryption_algorithm__n
  # @option opts [Array(String)] :encryption_algorithm__nic
  # @option opts [Array(String)] :encryption_algorithm__nie
  # @option opts [Array(String)] :encryption_algorithm__niew
  # @option opts [Array(String)] :encryption_algorithm__nisw
  # @option opts [Array(String)] :encryption_algorithm__regex
  # @option opts [Array(Int32)] :group Diffie-Hellman group ID
  # @option opts [Array(Int32)] :group__ic Diffie-Hellman group ID
  # @option opts [Array(Int32)] :group__ie Diffie-Hellman group ID
  # @option opts [Array(Int32)] :group__iew Diffie-Hellman group ID
  # @option opts [Array(Int32)] :group__iregex Diffie-Hellman group ID
  # @option opts [Array(Int32)] :group__isw Diffie-Hellman group ID
  # @option opts [Array(Int32)] :group__n Diffie-Hellman group ID
  # @option opts [Array(Int32)] :group__nic Diffie-Hellman group ID
  # @option opts [Array(Int32)] :group__nie Diffie-Hellman group ID
  # @option opts [Array(Int32)] :group__niew Diffie-Hellman group ID
  # @option opts [Array(Int32)] :group__nisw Diffie-Hellman group ID
  # @option opts [Array(Int32)] :group__regex Diffie-Hellman group ID
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :ike_policy IKE policy (name)
  # @option opts [Array(String)] :ike_policy__n IKE policy (name)
  # @option opts [Array(Int32)] :ike_policy_id IKE policy (ID)
  # @option opts [Array(Int32)] :ike_policy_id__n IKE policy (ID)
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [Array(Int32)] :sa_lifetime
  # @option opts [Bool] :sa_lifetime__empty
  # @option opts [Array(Int32)] :sa_lifetime__gt
  # @option opts [Array(Int32)] :sa_lifetime__gte
  # @option opts [Array(Int32)] :sa_lifetime__lt
  # @option opts [Array(Int32)] :sa_lifetime__lte
  # @option opts [Array(Int32)] :sa_lifetime__n
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [String] :updated_by_request
  # @return [PaginatedIKEProposalList]
  describe "vpn_ike_proposals_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ike_proposals_partial_update
  # Patch a IKE proposal object.
  # @param id A unique integer value identifying this IKE proposal.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableIKEProposalRequest] :patched_writable_ike_proposal_request
  # @return [IKEProposal]
  describe "vpn_ike_proposals_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ike_proposals_retrieve
  # Get a IKE proposal object.
  # @param id A unique integer value identifying this IKE proposal.
  # @param [Hash] opts the optional parameters
  # @return [IKEProposal]
  describe "vpn_ike_proposals_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ike_proposals_update
  # Put a IKE proposal object.
  # @param id A unique integer value identifying this IKE proposal.
  # @param writable_ike_proposal_request
  # @param [Hash] opts the optional parameters
  # @return [IKEProposal]
  describe "vpn_ike_proposals_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_policies_bulk_destroy
  # Delete a list of IPSec policy objects.
  # @param ip_sec_policy_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "vpn_ipsec_policies_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_policies_bulk_partial_update
  # Patch a list of IPSec policy objects.
  # @param ip_sec_policy_request
  # @param [Hash] opts the optional parameters
  # @return [Array(IPSecPolicy)]
  describe "vpn_ipsec_policies_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_policies_bulk_update
  # Put a list of IPSec policy objects.
  # @param ip_sec_policy_request
  # @param [Hash] opts the optional parameters
  # @return [Array(IPSecPolicy)]
  describe "vpn_ipsec_policies_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_policies_create
  # Post a list of IPSec policy objects.
  # @param vpn_ipsec_policies_create_request
  # @param [Hash] opts the optional parameters
  # @return [IPSecPolicy]
  describe "vpn_ipsec_policies_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_policies_destroy
  # Delete a IPSec policy object.
  # @param id A unique integer value identifying this IPSec policy.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "vpn_ipsec_policies_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_policies_list
  # Get a list of IPSec policy objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :ipsec_proposal
  # @option opts [Array(String)] :ipsec_proposal__n
  # @option opts [Array(Int32)] :ipsec_proposal_id
  # @option opts [Array(Int32)] :ipsec_proposal_id__n
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Array(Int32)] :pfs_group Diffie-Hellman group for Perfect Forward Secrecy
  # @option opts [Array(Int32)] :pfs_group__ic Diffie-Hellman group for Perfect Forward Secrecy
  # @option opts [Array(Int32)] :pfs_group__ie Diffie-Hellman group for Perfect Forward Secrecy
  # @option opts [Array(Int32)] :pfs_group__iew Diffie-Hellman group for Perfect Forward Secrecy
  # @option opts [Array(Int32)] :pfs_group__iregex Diffie-Hellman group for Perfect Forward Secrecy
  # @option opts [Array(Int32)] :pfs_group__isw Diffie-Hellman group for Perfect Forward Secrecy
  # @option opts [Array(Int32)] :pfs_group__n Diffie-Hellman group for Perfect Forward Secrecy
  # @option opts [Array(Int32)] :pfs_group__nic Diffie-Hellman group for Perfect Forward Secrecy
  # @option opts [Array(Int32)] :pfs_group__nie Diffie-Hellman group for Perfect Forward Secrecy
  # @option opts [Array(Int32)] :pfs_group__niew Diffie-Hellman group for Perfect Forward Secrecy
  # @option opts [Array(Int32)] :pfs_group__nisw Diffie-Hellman group for Perfect Forward Secrecy
  # @option opts [Array(Int32)] :pfs_group__regex Diffie-Hellman group for Perfect Forward Secrecy
  # @option opts [String] :q Search
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [String] :updated_by_request
  # @return [PaginatedIPSecPolicyList]
  describe "vpn_ipsec_policies_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_policies_partial_update
  # Patch a IPSec policy object.
  # @param id A unique integer value identifying this IPSec policy.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableIPSecPolicyRequest] :patched_writable_ip_sec_policy_request
  # @return [IPSecPolicy]
  describe "vpn_ipsec_policies_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_policies_retrieve
  # Get a IPSec policy object.
  # @param id A unique integer value identifying this IPSec policy.
  # @param [Hash] opts the optional parameters
  # @return [IPSecPolicy]
  describe "vpn_ipsec_policies_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_policies_update
  # Put a IPSec policy object.
  # @param id A unique integer value identifying this IPSec policy.
  # @param writable_ip_sec_policy_request
  # @param [Hash] opts the optional parameters
  # @return [IPSecPolicy]
  describe "vpn_ipsec_policies_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_profiles_bulk_destroy
  # Delete a list of IPSec profile objects.
  # @param ip_sec_profile_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "vpn_ipsec_profiles_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_profiles_bulk_partial_update
  # Patch a list of IPSec profile objects.
  # @param ip_sec_profile_request
  # @param [Hash] opts the optional parameters
  # @return [Array(IPSecProfile)]
  describe "vpn_ipsec_profiles_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_profiles_bulk_update
  # Put a list of IPSec profile objects.
  # @param ip_sec_profile_request
  # @param [Hash] opts the optional parameters
  # @return [Array(IPSecProfile)]
  describe "vpn_ipsec_profiles_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_profiles_create
  # Post a list of IPSec profile objects.
  # @param vpn_ipsec_profiles_create_request
  # @param [Hash] opts the optional parameters
  # @return [IPSecProfile]
  describe "vpn_ipsec_profiles_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_profiles_destroy
  # Delete a IPSec profile object.
  # @param id A unique integer value identifying this IPSec profile.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "vpn_ipsec_profiles_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_profiles_list
  # Get a list of IPSec profile objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :ike_policy IKE policy (name)
  # @option opts [Array(String)] :ike_policy__n IKE policy (name)
  # @option opts [Array(Int32)] :ike_policy_id IKE policy (ID)
  # @option opts [Array(Int32)] :ike_policy_id__n IKE policy (ID)
  # @option opts [Array(String)] :ipsec_policy IPSec policy (name)
  # @option opts [Array(String)] :ipsec_policy__n IPSec policy (name)
  # @option opts [Array(Int32)] :ipsec_policy_id IPSec policy (ID)
  # @option opts [Array(Int32)] :ipsec_policy_id__n IPSec policy (ID)
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [Array(String)] :mode
  # @option opts [Bool] :mode__empty
  # @option opts [Array(String)] :mode__ic
  # @option opts [Array(String)] :mode__ie
  # @option opts [Array(String)] :mode__iew
  # @option opts [Array(String)] :mode__iregex
  # @option opts [Array(String)] :mode__isw
  # @option opts [Array(String)] :mode__n
  # @option opts [Array(String)] :mode__nic
  # @option opts [Array(String)] :mode__nie
  # @option opts [Array(String)] :mode__niew
  # @option opts [Array(String)] :mode__nisw
  # @option opts [Array(String)] :mode__regex
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [String] :updated_by_request
  # @return [PaginatedIPSecProfileList]
  describe "vpn_ipsec_profiles_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_profiles_partial_update
  # Patch a IPSec profile object.
  # @param id A unique integer value identifying this IPSec profile.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableIPSecProfileRequest] :patched_writable_ip_sec_profile_request
  # @return [IPSecProfile]
  describe "vpn_ipsec_profiles_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_profiles_retrieve
  # Get a IPSec profile object.
  # @param id A unique integer value identifying this IPSec profile.
  # @param [Hash] opts the optional parameters
  # @return [IPSecProfile]
  describe "vpn_ipsec_profiles_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_profiles_update
  # Put a IPSec profile object.
  # @param id A unique integer value identifying this IPSec profile.
  # @param writable_ip_sec_profile_request
  # @param [Hash] opts the optional parameters
  # @return [IPSecProfile]
  describe "vpn_ipsec_profiles_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_proposals_bulk_destroy
  # Delete a list of IPSec proposal objects.
  # @param ip_sec_proposal_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "vpn_ipsec_proposals_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_proposals_bulk_partial_update
  # Patch a list of IPSec proposal objects.
  # @param ip_sec_proposal_request
  # @param [Hash] opts the optional parameters
  # @return [Array(IPSecProposal)]
  describe "vpn_ipsec_proposals_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_proposals_bulk_update
  # Put a list of IPSec proposal objects.
  # @param ip_sec_proposal_request
  # @param [Hash] opts the optional parameters
  # @return [Array(IPSecProposal)]
  describe "vpn_ipsec_proposals_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_proposals_create
  # Post a list of IPSec proposal objects.
  # @param vpn_ipsec_proposals_create_request
  # @param [Hash] opts the optional parameters
  # @return [IPSecProposal]
  describe "vpn_ipsec_proposals_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_proposals_destroy
  # Delete a IPSec proposal object.
  # @param id A unique integer value identifying this IPSec proposal.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "vpn_ipsec_proposals_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_proposals_list
  # Get a list of IPSec proposal objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(String)] :authentication_algorithm
  # @option opts [Bool] :authentication_algorithm__empty
  # @option opts [Array(String)] :authentication_algorithm__ic
  # @option opts [Array(String)] :authentication_algorithm__ie
  # @option opts [Array(String)] :authentication_algorithm__iew
  # @option opts [Array(String)] :authentication_algorithm__iregex
  # @option opts [Array(String)] :authentication_algorithm__isw
  # @option opts [Array(String)] :authentication_algorithm__n
  # @option opts [Array(String)] :authentication_algorithm__nic
  # @option opts [Array(String)] :authentication_algorithm__nie
  # @option opts [Array(String)] :authentication_algorithm__niew
  # @option opts [Array(String)] :authentication_algorithm__nisw
  # @option opts [Array(String)] :authentication_algorithm__regex
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(String)] :encryption_algorithm
  # @option opts [Bool] :encryption_algorithm__empty
  # @option opts [Array(String)] :encryption_algorithm__ic
  # @option opts [Array(String)] :encryption_algorithm__ie
  # @option opts [Array(String)] :encryption_algorithm__iew
  # @option opts [Array(String)] :encryption_algorithm__iregex
  # @option opts [Array(String)] :encryption_algorithm__isw
  # @option opts [Array(String)] :encryption_algorithm__n
  # @option opts [Array(String)] :encryption_algorithm__nic
  # @option opts [Array(String)] :encryption_algorithm__nie
  # @option opts [Array(String)] :encryption_algorithm__niew
  # @option opts [Array(String)] :encryption_algorithm__nisw
  # @option opts [Array(String)] :encryption_algorithm__regex
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :ipsec_policy IPSec policy (name)
  # @option opts [Array(String)] :ipsec_policy__n IPSec policy (name)
  # @option opts [Array(Int32)] :ipsec_policy_id IPSec policy (ID)
  # @option opts [Array(Int32)] :ipsec_policy_id__n IPSec policy (ID)
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [Array(Int32)] :sa_lifetime_data
  # @option opts [Bool] :sa_lifetime_data__empty
  # @option opts [Array(Int32)] :sa_lifetime_data__gt
  # @option opts [Array(Int32)] :sa_lifetime_data__gte
  # @option opts [Array(Int32)] :sa_lifetime_data__lt
  # @option opts [Array(Int32)] :sa_lifetime_data__lte
  # @option opts [Array(Int32)] :sa_lifetime_data__n
  # @option opts [Array(Int32)] :sa_lifetime_seconds
  # @option opts [Bool] :sa_lifetime_seconds__empty
  # @option opts [Array(Int32)] :sa_lifetime_seconds__gt
  # @option opts [Array(Int32)] :sa_lifetime_seconds__gte
  # @option opts [Array(Int32)] :sa_lifetime_seconds__lt
  # @option opts [Array(Int32)] :sa_lifetime_seconds__lte
  # @option opts [Array(Int32)] :sa_lifetime_seconds__n
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [String] :updated_by_request
  # @return [PaginatedIPSecProposalList]
  describe "vpn_ipsec_proposals_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_proposals_partial_update
  # Patch a IPSec proposal object.
  # @param id A unique integer value identifying this IPSec proposal.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableIPSecProposalRequest] :patched_writable_ip_sec_proposal_request
  # @return [IPSecProposal]
  describe "vpn_ipsec_proposals_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_proposals_retrieve
  # Get a IPSec proposal object.
  # @param id A unique integer value identifying this IPSec proposal.
  # @param [Hash] opts the optional parameters
  # @return [IPSecProposal]
  describe "vpn_ipsec_proposals_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_ipsec_proposals_update
  # Put a IPSec proposal object.
  # @param id A unique integer value identifying this IPSec proposal.
  # @param writable_ip_sec_proposal_request
  # @param [Hash] opts the optional parameters
  # @return [IPSecProposal]
  describe "vpn_ipsec_proposals_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_l2vpn_terminations_bulk_destroy
  # Delete a list of L2VPN termination objects.
  # @param l2_vpn_termination_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "vpn_l2vpn_terminations_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_l2vpn_terminations_bulk_partial_update
  # Patch a list of L2VPN termination objects.
  # @param l2_vpn_termination_request
  # @param [Hash] opts the optional parameters
  # @return [Array(L2VPNTermination)]
  describe "vpn_l2vpn_terminations_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_l2vpn_terminations_bulk_update
  # Put a list of L2VPN termination objects.
  # @param l2_vpn_termination_request
  # @param [Hash] opts the optional parameters
  # @return [Array(L2VPNTermination)]
  describe "vpn_l2vpn_terminations_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_l2vpn_terminations_create
  # Post a list of L2VPN termination objects.
  # @param vpn_l2vpn_terminations_create_request
  # @param [Hash] opts the optional parameters
  # @return [L2VPNTermination]
  describe "vpn_l2vpn_terminations_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_l2vpn_terminations_destroy
  # Delete a L2VPN termination object.
  # @param id A unique integer value identifying this L2VPN termination.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "vpn_l2vpn_terminations_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_l2vpn_terminations_list
  # Get a list of L2VPN termination objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Int32)] :assigned_object_id
  # @option opts [Bool] :assigned_object_id__empty
  # @option opts [Array(Int32)] :assigned_object_id__gt
  # @option opts [Array(Int32)] :assigned_object_id__gte
  # @option opts [Array(Int32)] :assigned_object_id__lt
  # @option opts [Array(Int32)] :assigned_object_id__lte
  # @option opts [Array(Int32)] :assigned_object_id__n
  # @option opts [String] :assigned_object_type
  # @option opts [String] :assigned_object_type__n
  # @option opts [Array(Int32)] :assigned_object_type_id
  # @option opts [Array(Int32)] :assigned_object_type_id__n
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :device Device (name)
  # @option opts [Array(String)] :device__n Device (name)
  # @option opts [Array(Int32)] :device_id Device (ID)
  # @option opts [Array(Int32)] :device_id__n Device (ID)
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :interface Interface (name)
  # @option opts [Array(String)] :interface__n Interface (name)
  # @option opts [Array(Int32)] :interface_id Interface (ID)
  # @option opts [Array(Int32)] :interface_id__n Interface (ID)
  # @option opts [Array(String)] :l2vpn L2VPN (slug)
  # @option opts [Array(String)] :l2vpn__n L2VPN (slug)
  # @option opts [Array(Int32)] :l2vpn_id L2VPN (ID)
  # @option opts [Array(Int32)] :l2vpn_id__n L2VPN (ID)
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [String] :modified_by_request
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [Array(String)] :region
  # @option opts [Array(Int32)] :region_id
  # @option opts [Array(String)] :site
  # @option opts [Array(Int32)] :site_id
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [String] :updated_by_request
  # @option opts [Array(String)] :virtual_machine Virtual machine (name)
  # @option opts [Array(String)] :virtual_machine__n Virtual machine (name)
  # @option opts [Array(Int32)] :virtual_machine_id Virtual machine (ID)
  # @option opts [Array(Int32)] :virtual_machine_id__n Virtual machine (ID)
  # @option opts [Array(String)] :vlan VLAN (name)
  # @option opts [Array(String)] :vlan__n VLAN (name)
  # @option opts [Array(Int32)] :vlan_id VLAN (ID)
  # @option opts [Array(Int32)] :vlan_id__n VLAN (ID)
  # @option opts [Int32] :vlan_vid VLAN number (1-4094)
  # @option opts [Int32] :vlan_vid__empty VLAN number (1-4094)
  # @option opts [Int32] :vlan_vid__gt VLAN number (1-4094)
  # @option opts [Int32] :vlan_vid__gte VLAN number (1-4094)
  # @option opts [Int32] :vlan_vid__lt VLAN number (1-4094)
  # @option opts [Int32] :vlan_vid__lte VLAN number (1-4094)
  # @option opts [Int32] :vlan_vid__n VLAN number (1-4094)
  # @option opts [Array(String)] :vminterface VM interface (name)
  # @option opts [Array(String)] :vminterface__n VM interface (name)
  # @option opts [Array(Int32)] :vminterface_id VM Interface (ID)
  # @option opts [Array(Int32)] :vminterface_id__n VM Interface (ID)
  # @return [PaginatedL2VPNTerminationList]
  describe "vpn_l2vpn_terminations_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_l2vpn_terminations_partial_update
  # Patch a L2VPN termination object.
  # @param id A unique integer value identifying this L2VPN termination.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedL2VPNTerminationRequest] :patched_l2_vpn_termination_request
  # @return [L2VPNTermination]
  describe "vpn_l2vpn_terminations_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_l2vpn_terminations_retrieve
  # Get a L2VPN termination object.
  # @param id A unique integer value identifying this L2VPN termination.
  # @param [Hash] opts the optional parameters
  # @return [L2VPNTermination]
  describe "vpn_l2vpn_terminations_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_l2vpn_terminations_update
  # Put a L2VPN termination object.
  # @param id A unique integer value identifying this L2VPN termination.
  # @param l2_vpn_termination_request
  # @param [Hash] opts the optional parameters
  # @return [L2VPNTermination]
  describe "vpn_l2vpn_terminations_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_l2vpns_bulk_destroy
  # Delete a list of L2VPN objects.
  # @param l2_vpn_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "vpn_l2vpns_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_l2vpns_bulk_partial_update
  # Patch a list of L2VPN objects.
  # @param l2_vpn_request
  # @param [Hash] opts the optional parameters
  # @return [Array(L2VPN)]
  describe "vpn_l2vpns_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_l2vpns_bulk_update
  # Put a list of L2VPN objects.
  # @param l2_vpn_request
  # @param [Hash] opts the optional parameters
  # @return [Array(L2VPN)]
  describe "vpn_l2vpns_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_l2vpns_create
  # Post a list of L2VPN objects.
  # @param vpn_l2vpns_create_request
  # @param [Hash] opts the optional parameters
  # @return [L2VPN]
  describe "vpn_l2vpns_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_l2vpns_destroy
  # Delete a L2VPN object.
  # @param id A unique integer value identifying this L2VPN.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "vpn_l2vpns_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_l2vpns_list
  # Get a list of L2VPN objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Int32)] :contact Contact
  # @option opts [Array(Int32)] :contact__n Contact
  # @option opts [Array(String)] :contact_group
  # @option opts [Array(String)] :contact_group__n
  # @option opts [Array(Int32)] :contact_role Contact Role
  # @option opts [Array(Int32)] :contact_role__n Contact Role
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(String)] :export_target Export target (name)
  # @option opts [Array(String)] :export_target__n Export target (name)
  # @option opts [Array(Int32)] :export_target_id Export target
  # @option opts [Array(Int32)] :export_target_id__n Export target
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(Int32)] :identifier
  # @option opts [Bool] :identifier__empty
  # @option opts [Array(Int32)] :identifier__gt
  # @option opts [Array(Int32)] :identifier__gte
  # @option opts [Array(Int32)] :identifier__lt
  # @option opts [Array(Int32)] :identifier__lte
  # @option opts [Array(Int32)] :identifier__n
  # @option opts [Array(String)] :import_target Import target (name)
  # @option opts [Array(String)] :import_target__n Import target (name)
  # @option opts [Array(Int32)] :import_target_id Import target
  # @option opts [Array(Int32)] :import_target_id__n Import target
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [Array(String)] :slug
  # @option opts [Bool] :slug__empty
  # @option opts [Array(String)] :slug__ic
  # @option opts [Array(String)] :slug__ie
  # @option opts [Array(String)] :slug__iew
  # @option opts [Array(String)] :slug__iregex
  # @option opts [Array(String)] :slug__isw
  # @option opts [Array(String)] :slug__n
  # @option opts [Array(String)] :slug__nic
  # @option opts [Array(String)] :slug__nie
  # @option opts [Array(String)] :slug__niew
  # @option opts [Array(String)] :slug__nisw
  # @option opts [Array(String)] :slug__regex
  # @option opts [Array(String)] :status
  # @option opts [Bool] :status__empty
  # @option opts [Array(String)] :status__ic
  # @option opts [Array(String)] :status__ie
  # @option opts [Array(String)] :status__iew
  # @option opts [Array(String)] :status__iregex
  # @option opts [Array(String)] :status__isw
  # @option opts [Array(String)] :status__n
  # @option opts [Array(String)] :status__nic
  # @option opts [Array(String)] :status__nie
  # @option opts [Array(String)] :status__niew
  # @option opts [Array(String)] :status__nisw
  # @option opts [Array(String)] :status__regex
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [Array(String)] :tenant Tenant (slug)
  # @option opts [Array(String)] :tenant__n Tenant (slug)
  # @option opts [Array(String)] :tenant_group
  # @option opts [Array(String)] :tenant_group__n
  # @option opts [Array(String)] :tenant_group_id
  # @option opts [Array(String)] :tenant_group_id__n
  # @option opts [Array(Int32)] :tenant_id Tenant (ID)
  # @option opts [Array(Int32)] :tenant_id__n Tenant (ID)
  # @option opts [Array(String)] :_type
  # @option opts [Bool] :type__empty
  # @option opts [Array(String)] :type__ic
  # @option opts [Array(String)] :type__ie
  # @option opts [Array(String)] :type__iew
  # @option opts [Array(String)] :type__iregex
  # @option opts [Array(String)] :type__isw
  # @option opts [Array(String)] :type__n
  # @option opts [Array(String)] :type__nic
  # @option opts [Array(String)] :type__nie
  # @option opts [Array(String)] :type__niew
  # @option opts [Array(String)] :type__nisw
  # @option opts [Array(String)] :type__regex
  # @option opts [String] :updated_by_request
  # @return [PaginatedL2VPNList]
  describe "vpn_l2vpns_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_l2vpns_partial_update
  # Patch a L2VPN object.
  # @param id A unique integer value identifying this L2VPN.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableL2VPNRequest] :patched_writable_l2_vpn_request
  # @return [L2VPN]
  describe "vpn_l2vpns_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_l2vpns_retrieve
  # Get a L2VPN object.
  # @param id A unique integer value identifying this L2VPN.
  # @param [Hash] opts the optional parameters
  # @return [L2VPN]
  describe "vpn_l2vpns_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_l2vpns_update
  # Put a L2VPN object.
  # @param id A unique integer value identifying this L2VPN.
  # @param writable_l2_vpn_request
  # @param [Hash] opts the optional parameters
  # @return [L2VPN]
  describe "vpn_l2vpns_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnel_groups_bulk_destroy
  # Delete a list of tunnel group objects.
  # @param tunnel_group_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "vpn_tunnel_groups_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnel_groups_bulk_partial_update
  # Patch a list of tunnel group objects.
  # @param tunnel_group_request
  # @param [Hash] opts the optional parameters
  # @return [Array(TunnelGroup)]
  describe "vpn_tunnel_groups_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnel_groups_bulk_update
  # Put a list of tunnel group objects.
  # @param tunnel_group_request
  # @param [Hash] opts the optional parameters
  # @return [Array(TunnelGroup)]
  describe "vpn_tunnel_groups_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnel_groups_create
  # Post a list of tunnel group objects.
  # @param vpn_tunnel_groups_create_request
  # @param [Hash] opts the optional parameters
  # @return [TunnelGroup]
  describe "vpn_tunnel_groups_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnel_groups_destroy
  # Delete a tunnel group object.
  # @param id A unique integer value identifying this tunnel group.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "vpn_tunnel_groups_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnel_groups_list
  # Get a list of tunnel group objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Int32)] :contact Contact
  # @option opts [Array(Int32)] :contact__n Contact
  # @option opts [Array(String)] :contact_group
  # @option opts [Array(String)] :contact_group__n
  # @option opts [Array(Int32)] :contact_role Contact Role
  # @option opts [Array(Int32)] :contact_role__n Contact Role
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [Array(String)] :slug
  # @option opts [Bool] :slug__empty
  # @option opts [Array(String)] :slug__ic
  # @option opts [Array(String)] :slug__ie
  # @option opts [Array(String)] :slug__iew
  # @option opts [Array(String)] :slug__iregex
  # @option opts [Array(String)] :slug__isw
  # @option opts [Array(String)] :slug__n
  # @option opts [Array(String)] :slug__nic
  # @option opts [Array(String)] :slug__nie
  # @option opts [Array(String)] :slug__niew
  # @option opts [Array(String)] :slug__nisw
  # @option opts [Array(String)] :slug__regex
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [String] :updated_by_request
  # @return [PaginatedTunnelGroupList]
  describe "vpn_tunnel_groups_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnel_groups_partial_update
  # Patch a tunnel group object.
  # @param id A unique integer value identifying this tunnel group.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedTunnelGroupRequest] :patched_tunnel_group_request
  # @return [TunnelGroup]
  describe "vpn_tunnel_groups_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnel_groups_retrieve
  # Get a tunnel group object.
  # @param id A unique integer value identifying this tunnel group.
  # @param [Hash] opts the optional parameters
  # @return [TunnelGroup]
  describe "vpn_tunnel_groups_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnel_groups_update
  # Put a tunnel group object.
  # @param id A unique integer value identifying this tunnel group.
  # @param tunnel_group_request
  # @param [Hash] opts the optional parameters
  # @return [TunnelGroup]
  describe "vpn_tunnel_groups_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnel_terminations_bulk_destroy
  # Delete a list of tunnel termination objects.
  # @param tunnel_termination_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "vpn_tunnel_terminations_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnel_terminations_bulk_partial_update
  # Patch a list of tunnel termination objects.
  # @param tunnel_termination_request
  # @param [Hash] opts the optional parameters
  # @return [Array(TunnelTermination)]
  describe "vpn_tunnel_terminations_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnel_terminations_bulk_update
  # Put a list of tunnel termination objects.
  # @param tunnel_termination_request
  # @param [Hash] opts the optional parameters
  # @return [Array(TunnelTermination)]
  describe "vpn_tunnel_terminations_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnel_terminations_create
  # Post a list of tunnel termination objects.
  # @param vpn_tunnel_terminations_create_request
  # @param [Hash] opts the optional parameters
  # @return [TunnelTermination]
  describe "vpn_tunnel_terminations_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnel_terminations_destroy
  # Delete a tunnel termination object.
  # @param id A unique integer value identifying this tunnel termination.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "vpn_tunnel_terminations_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnel_terminations_list
  # Get a list of tunnel termination objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :interface Interface (name)
  # @option opts [Array(String)] :interface__n Interface (name)
  # @option opts [Array(Int32)] :interface_id Interface (ID)
  # @option opts [Array(Int32)] :interface_id__n Interface (ID)
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [String] :modified_by_request
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [Array(Int32)] :outside_ip_id Outside IP (ID)
  # @option opts [Array(Int32)] :outside_ip_id__n Outside IP (ID)
  # @option opts [String] :q Search
  # @option opts [Array(String)] :role
  # @option opts [Bool] :role__empty
  # @option opts [Array(String)] :role__ic
  # @option opts [Array(String)] :role__ie
  # @option opts [Array(String)] :role__iew
  # @option opts [Array(String)] :role__iregex
  # @option opts [Array(String)] :role__isw
  # @option opts [Array(String)] :role__n
  # @option opts [Array(String)] :role__nic
  # @option opts [Array(String)] :role__nie
  # @option opts [Array(String)] :role__niew
  # @option opts [Array(String)] :role__nisw
  # @option opts [Array(String)] :role__regex
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [Array(Int32)] :termination_id
  # @option opts [Bool] :termination_id__empty
  # @option opts [Array(Int32)] :termination_id__gt
  # @option opts [Array(Int32)] :termination_id__gte
  # @option opts [Array(Int32)] :termination_id__lt
  # @option opts [Array(Int32)] :termination_id__lte
  # @option opts [Array(Int32)] :termination_id__n
  # @option opts [String] :termination_type
  # @option opts [String] :termination_type__n
  # @option opts [Array(String)] :tunnel Tunnel (name)
  # @option opts [Array(String)] :tunnel__n Tunnel (name)
  # @option opts [Array(Int32)] :tunnel_id Tunnel (ID)
  # @option opts [Array(Int32)] :tunnel_id__n Tunnel (ID)
  # @option opts [String] :updated_by_request
  # @option opts [Array(String)] :vminterface VM interface (name)
  # @option opts [Array(String)] :vminterface__n VM interface (name)
  # @option opts [Array(Int32)] :vminterface_id VM interface (ID)
  # @option opts [Array(Int32)] :vminterface_id__n VM interface (ID)
  # @return [PaginatedTunnelTerminationList]
  describe "vpn_tunnel_terminations_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnel_terminations_partial_update
  # Patch a tunnel termination object.
  # @param id A unique integer value identifying this tunnel termination.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableTunnelTerminationRequest] :patched_writable_tunnel_termination_request
  # @return [TunnelTermination]
  describe "vpn_tunnel_terminations_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnel_terminations_retrieve
  # Get a tunnel termination object.
  # @param id A unique integer value identifying this tunnel termination.
  # @param [Hash] opts the optional parameters
  # @return [TunnelTermination]
  describe "vpn_tunnel_terminations_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnel_terminations_update
  # Put a tunnel termination object.
  # @param id A unique integer value identifying this tunnel termination.
  # @param writable_tunnel_termination_request
  # @param [Hash] opts the optional parameters
  # @return [TunnelTermination]
  describe "vpn_tunnel_terminations_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnels_bulk_destroy
  # Delete a list of tunnel objects.
  # @param tunnel_request
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "vpn_tunnels_bulk_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnels_bulk_partial_update
  # Patch a list of tunnel objects.
  # @param tunnel_request
  # @param [Hash] opts the optional parameters
  # @return [Array(Tunnel)]
  describe "vpn_tunnels_bulk_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnels_bulk_update
  # Put a list of tunnel objects.
  # @param tunnel_request
  # @param [Hash] opts the optional parameters
  # @return [Array(Tunnel)]
  describe "vpn_tunnels_bulk_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnels_create
  # Post a list of tunnel objects.
  # @param vpn_tunnels_create_request
  # @param [Hash] opts the optional parameters
  # @return [Tunnel]
  describe "vpn_tunnels_create test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnels_destroy
  # Delete a tunnel object.
  # @param id A unique integer value identifying this tunnel.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe "vpn_tunnels_destroy test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnels_list
  # Get a list of tunnel objects.
  # @param [Hash] opts the optional parameters
  # @option opts [Array(Int32)] :contact Contact
  # @option opts [Array(Int32)] :contact__n Contact
  # @option opts [Array(String)] :contact_group
  # @option opts [Array(String)] :contact_group__n
  # @option opts [Array(Int32)] :contact_role Contact Role
  # @option opts [Array(Int32)] :contact_role__n Contact Role
  # @option opts [Array(Time)] :created
  # @option opts [Array(Time)] :created__empty
  # @option opts [Array(Time)] :created__gt
  # @option opts [Array(Time)] :created__gte
  # @option opts [Array(Time)] :created__lt
  # @option opts [Array(Time)] :created__lte
  # @option opts [Array(Time)] :created__n
  # @option opts [String] :created_by_request
  # @option opts [Array(String)] :description
  # @option opts [Bool] :description__empty
  # @option opts [Array(String)] :description__ic
  # @option opts [Array(String)] :description__ie
  # @option opts [Array(String)] :description__iew
  # @option opts [Array(String)] :description__iregex
  # @option opts [Array(String)] :description__isw
  # @option opts [Array(String)] :description__n
  # @option opts [Array(String)] :description__nic
  # @option opts [Array(String)] :description__nie
  # @option opts [Array(String)] :description__niew
  # @option opts [Array(String)] :description__nisw
  # @option opts [Array(String)] :description__regex
  # @option opts [Array(String)] :encapsulation
  # @option opts [Bool] :encapsulation__empty
  # @option opts [Array(String)] :encapsulation__ic
  # @option opts [Array(String)] :encapsulation__ie
  # @option opts [Array(String)] :encapsulation__iew
  # @option opts [Array(String)] :encapsulation__iregex
  # @option opts [Array(String)] :encapsulation__isw
  # @option opts [Array(String)] :encapsulation__n
  # @option opts [Array(String)] :encapsulation__nic
  # @option opts [Array(String)] :encapsulation__nie
  # @option opts [Array(String)] :encapsulation__niew
  # @option opts [Array(String)] :encapsulation__nisw
  # @option opts [Array(String)] :encapsulation__regex
  # @option opts [Array(String)] :group Tunnel group (slug)
  # @option opts [Array(String)] :group__n Tunnel group (slug)
  # @option opts [Array(Int32)] :group_id Tunnel group (ID)
  # @option opts [Array(Int32)] :group_id__n Tunnel group (ID)
  # @option opts [Array(Int32)] :id
  # @option opts [Bool] :id__empty
  # @option opts [Array(Int32)] :id__gt
  # @option opts [Array(Int32)] :id__gte
  # @option opts [Array(Int32)] :id__lt
  # @option opts [Array(Int32)] :id__lte
  # @option opts [Array(Int32)] :id__n
  # @option opts [Array(String)] :ipsec_profile IPSec profile (name)
  # @option opts [Array(String)] :ipsec_profile__n IPSec profile (name)
  # @option opts [Array(Int32)] :ipsec_profile_id IPSec profile (ID)
  # @option opts [Array(Int32)] :ipsec_profile_id__n IPSec profile (ID)
  # @option opts [Array(Time)] :last_updated
  # @option opts [Array(Time)] :last_updated__empty
  # @option opts [Array(Time)] :last_updated__gt
  # @option opts [Array(Time)] :last_updated__gte
  # @option opts [Array(Time)] :last_updated__lt
  # @option opts [Array(Time)] :last_updated__lte
  # @option opts [Array(Time)] :last_updated__n
  # @option opts [Int32] :limit Number of results to return per page.
  # @option opts [String] :modified_by_request
  # @option opts [Array(String)] :name
  # @option opts [Bool] :name__empty
  # @option opts [Array(String)] :name__ic
  # @option opts [Array(String)] :name__ie
  # @option opts [Array(String)] :name__iew
  # @option opts [Array(String)] :name__iregex
  # @option opts [Array(String)] :name__isw
  # @option opts [Array(String)] :name__n
  # @option opts [Array(String)] :name__nic
  # @option opts [Array(String)] :name__nie
  # @option opts [Array(String)] :name__niew
  # @option opts [Array(String)] :name__nisw
  # @option opts [Array(String)] :name__regex
  # @option opts [Int32] :offset The initial index from which to return the results.
  # @option opts [String] :ordering Which field to use when ordering the results.
  # @option opts [String] :q Search
  # @option opts [Array(String)] :status
  # @option opts [Bool] :status__empty
  # @option opts [Array(String)] :status__ic
  # @option opts [Array(String)] :status__ie
  # @option opts [Array(String)] :status__iew
  # @option opts [Array(String)] :status__iregex
  # @option opts [Array(String)] :status__isw
  # @option opts [Array(String)] :status__n
  # @option opts [Array(String)] :status__nic
  # @option opts [Array(String)] :status__nie
  # @option opts [Array(String)] :status__niew
  # @option opts [Array(String)] :status__nisw
  # @option opts [Array(String)] :status__regex
  # @option opts [Array(String)] :tag
  # @option opts [Array(String)] :tag__n
  # @option opts [Array(String)] :tag_id
  # @option opts [Array(String)] :tag_id__n
  # @option opts [Array(String)] :tenant Tenant (slug)
  # @option opts [Array(String)] :tenant__n Tenant (slug)
  # @option opts [Array(String)] :tenant_group
  # @option opts [Array(String)] :tenant_group__n
  # @option opts [Array(String)] :tenant_group_id
  # @option opts [Array(String)] :tenant_group_id__n
  # @option opts [Array(Int32)] :tenant_id Tenant (ID)
  # @option opts [Array(Int32)] :tenant_id__n Tenant (ID)
  # @option opts [Array(Int32)] :tunnel_id
  # @option opts [Bool] :tunnel_id__empty
  # @option opts [Array(Int32)] :tunnel_id__gt
  # @option opts [Array(Int32)] :tunnel_id__gte
  # @option opts [Array(Int32)] :tunnel_id__lt
  # @option opts [Array(Int32)] :tunnel_id__lte
  # @option opts [Array(Int32)] :tunnel_id__n
  # @option opts [String] :updated_by_request
  # @return [PaginatedTunnelList]
  describe "vpn_tunnels_list test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnels_partial_update
  # Patch a tunnel object.
  # @param id A unique integer value identifying this tunnel.
  # @param [Hash] opts the optional parameters
  # @option opts [PatchedWritableTunnelRequest] :patched_writable_tunnel_request
  # @return [Tunnel]
  describe "vpn_tunnels_partial_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnels_retrieve
  # Get a tunnel object.
  # @param id A unique integer value identifying this tunnel.
  # @param [Hash] opts the optional parameters
  # @return [Tunnel]
  describe "vpn_tunnels_retrieve test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end

  # unit tests for vpn_tunnels_update
  # Put a tunnel object.
  # @param id A unique integer value identifying this tunnel.
  # @param writable_tunnel_request
  # @param [Hash] opts the optional parameters
  # @return [Tunnel]
  describe "vpn_tunnels_update test" do
    skip "should work" do
      # assertion here. ref: https://crystal-lang.org/reference/guides/testing.html
    end
  end
end
